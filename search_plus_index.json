{"./":{"url":"./","title":"本书简介","keywords":"","body":"本书简介 本书地址为https://zlogs.net/learn-c 本书为个人学习markdown系列笔记，其他更多系列笔记可以关注https://zlogs.net/learn-books 本书标准 本书标准参考https://www.runoob.com/cprogramming 其他参考均在文中列出，如有为列出或者侵权行为请在对应文章下方留言 本书版权 本书转载菜鸟教程为主体，添加部分个人笔记，转载部分版权归原作者所有 关于版权和转载请阅读learn-books简介 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1010.html":{"url":"books/1010.html","title":"速查","keywords":"","body":"速查 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1011.html":{"url":"books/1011.html","title":"简介","keywords":"","body":"简介 C 语言是一种通用的、面向过程式的计算机程序设计语言。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1012.html":{"url":"books/1012.html","title":"发展","keywords":"","body":"发展 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1147.html":{"url":"books/1147.html","title":"原理","keywords":"","body":"原理 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1013.html":{"url":"books/1013.html","title":"配置","keywords":"","body":"配置 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1014.html":{"url":"books/1014.html","title":"基础","keywords":"","body":"基础 基本框架 #include int main() { /*有效代码*/ printf(\"Hello, World!\\n\"); return 0； } 这是c语言的基本结构，任何一个程序都必须包含这个结构。括号内可以不写任何内容，那么该程序将不执行任何结果。 #include 告诉预处理器将指定头文件的内容插入到预处理器命令的相应位值，导入头文件的预编译指令，表示系统自带的库，\" \"表示用户自定义库 在c语言中称之为“主函数”，一个c程序有且仅有一个main函数，任何一个c程序总是从main函数开始执行，main函数后面的一对圆括号不能省略。 被大括号{ }括起来的内容称为main函数的函数体，这部分内容就是计算机要执行的内容.在{ }里面每一句话后面都有一个分号（；）在c语言中，以一个分号结尾的一句话叫做一个c语言的语句，分号是语句结束的标志。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1136.html":{"url":"books/1136.html","title":"标识符","keywords":"","body":"标识符 在编写程序时，必须为函数、变量等命名，这个名字称为标识符。 标识符分类（都是小写） ①关键字（32个）（有固定含义，不可改变） 类型说明符：int,float,double等 修饰符：auto等 语句定义符：if，for,while等 动作符 ②预定义标识符（有特殊含义，可以改变） 库函数的名字：printf , scanf 等 编译预处理命令名：include等 ③用户自定义的标识符 ⅰ格式合法，ⅱ不能使用关键字，ⅲ见名知意 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1137.html":{"url":"books/1137.html","title":"关键字","keywords":"","body":"关键字 关键字 关键字是具有特定含义的，专门用来说明c语言特定成分的一类标识符，不能用作用户的标识符。 auto break case char union do double else enum extern goto if int long short signed static sizeof struct switch unsigned void for while typedef continue float return typedef default 关键字 说明 auto 声明自动变量 break 跳出当前循环 case 开关语句分支 char 声明字符型变量或函数返回值类型 const 声明只读变量 continue 结束当前循环，开始下一轮循环 default 开关语句中的\"其它\"分支 do 循环语句的循环体 double 声明双精度浮点型变量或函数返回值类型 else 条件语句否定分支（与 if 连用） enum 声明枚举类型 extern 声明变量或函数是在其它文件或本文件的其他位置定义 float 声明浮点型变量或函数返回值类型 for 一种循环语句 goto 无条件跳转语句 if 条件语句 int 声明整型变量或函数 long 声明长整型变量或函数返回值类型 register 声明寄存器变量 return 子程序返回语句（可以带参数，也可不带参数） short 声明短整型变量或函数 signed 声明有符号类型变量或函数 sizeof 计算数据类型或变量长度（即所占字节数） static 声明静态变量 struct 声明结构体类型 switch 用于开关语句 typedef 用以给数据类型取别名 unsigned 声明无符号类型变量或函数 union 声明共用体类型 void 声明函数无返回值或无参数，声明无类型指针 volatile 说明变量在程序执行中可被隐含地改变 while 循环语句的循环条件 C99 新增关键字 _Bool _Complex _Imaginary inline restrict C11 新增关键字 _Alignas _Alignof _Atomic _Generic _Noreturn _Static_assert _Thread_local 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1138.html":{"url":"books/1138.html","title":"预定义标识符","keywords":"","body":"预定义标识符 预定义标识符在c语言中也有特定的含义，但可以用作用户标识符，预定义标识符分为两类： （1）、库函数名字，比如（printf，scanf,sin，isdigit等） （2）、编译处理命令名，比如（define,include） 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1139.html":{"url":"books/1139.html","title":"用户自定义标识符","keywords":"","body":"用户自定义标识符 用户标识符 用户根据需要自己定义的标识符称为用户标识符。无论如何自定义标识符，都必须符合标识符的三条命名规则。 注意：正常系统函数由_开头，因此不建议自定义函数以下划线开 C语言中标识符的命名规则如下： 1、标识符只能由字母、数字、下划线组成； 2、标识符的第一个字母必须是字母和下划线；(开头) 3、标识符区分大小写字母，如If和if是两个完全不同的标识符。 合法标识符如下： A6 b_3 _mn _ 非法的标识符如下： ab#12, 8m , tr3:4 , yes no 标识符不能与程序中具有特殊意义的关键字相同， 不能与用户编制的函数名、C语言库函数相同， 在程序中各种标识符尽量不要重复，以便区分。 选择变量名和其他标识符时，应注意做到 “见名知义”。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1133.html":{"url":"books/1133.html","title":"行与缩进","keywords":"","body":"空格与空行 连续多个空格和空行视为一个空格和空行 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1134.html":{"url":"books/1134.html","title":"大小写","keywords":"","body":"大小写 C语言区分大小写 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1135.html":{"url":"books/1135.html","title":"注释","keywords":"","body":"注释 关于注释 程序中以 /*开头并且以*/结尾的部分表示程序的注释部分，注释可以添加在程序的任何位置，为了提高程序的可读性而添加，但计算机在执行主函数内容时完全忽略注释部分，换而言之就是计算机当做注释部分不存在于主函数中。 //注释嵌套 1.F // /* */ 2.F /* /* */ */ 3.T // // 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1146.html":{"url":"books/1146.html","title":"编码","keywords":"","body":"编码 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1015.html":{"url":"books/1015.html","title":"风格","keywords":"","body":"风格 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1016.html":{"url":"books/1016.html","title":"数据类型","keywords":"","body":"数据类型 数据类型决定 数据占内存字节数 数据取值范围 其上可进行的操作 C数据类型 . ├── 基本类型 | ├── 数值类型 | | ├── 整型 | | | ├── 短整型short | | | ├── 整型int | | | └── 长整型long | | └── 浮点型 | | ├── 单精度型float | | └── 双精度型double | └── 字符类型char ├── 构造类型 | ├── 数组 | ├── 结构体struct | ├── 共用体union | └── 枚举类型enum ├── 指针类型 ├── 自定义类型 └── 空类型void 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1148.html":{"url":"books/1148.html","title":"组成","keywords":"","body":"组成 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1017.html":{"url":"books/1017.html","title":"基本类型","keywords":"","body":"基本类型 . ├── 基本类型分法一 | ├── 数值类型 | | ├── 整型 | | | ├── 短整型short | | | ├── 整型int | | | └── 长整型long | | └── 浮点型 | | ├── 单精度型float | | └── 双精度型double | └── 字符类型char └── 基本类型分法二 ├── 变量 └── 常量 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1018.html":{"url":"books/1018.html","title":"数值类型","keywords":"","body":"数值类型 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1019.html":{"url":"books/1019.html","title":"整型","keywords":"","body":"整数类型 类型 存储大小 值范围 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295 short 2 字节 -32,768 到 32,767 unsigned short 2 字节 0 到 65,535 long 4 字节 -2,147,483,648 到 2,147,483,647 unsigned long 4 字节 0 到 4,294,967,295 注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。 int，long int，short int的宽度都可能随编译器而异。但有几条铁定的原则（ANSI/ISO制订的）： •sizeof(shortint) •sizeof(int) •shortint至少应为16位（2字节） •longint至少应为32位。 以下列出了32位系统与64位系统的存储大小的差别（windows 相同）： 变量 类型 描述 int 对机器而言，整数的最自然的大小。 常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 下面列举几个整数常量的实例： 212 /* 合法的 */ 215u /* 合法的 */ 0xFeeL /* 合法的 */ 078 /* 非法的：8 不是八进制的数字 */ 032UU /* 非法的：不能重复后缀 */ 以下是各种类型的整数常量的实例： 85 /* 十进制 */ 0213 /* 八进制 */ 0x4b /* 十六进制 */ 30 /* 整数 */ 30u /* 无符号整数 */ 30l /* 长整数 */ 30ul /* 无符号长整数 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1020.html":{"url":"books/1020.html","title":"浮点型","keywords":"","body":"浮点类型 类型 存储大小 值范围 精度 float 4 字节 1.2E-38 到 3.4E+38 6 位小数 double 8 字节 2.3E-308 到 1.7E+308 15 位小数 long double 16 字节 3.4E-4932 到 1.1E+4932 19 位小数 头文件 float.h 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。下面的实例将输出浮点类型占用的存储空间以及它的范围值： #include #include int main() { printf(\"float 存储最大字节数 : %lu \\n\", sizeof(float)); printf(\"float 最小值: %E\\n\", FLT_MIN ); printf(\"float 最大值: %E\\n\", FLT_MAX ); printf(\"精度值: %d\\n\", FLT_DIG ); return 0; } /* float 存储最大字节数 : 4 float 最小值: 1.175494E-38 float 最大值: 3.402823E+38 精度值: 6 */ 变量 类型 描述 float 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。 double 双精度浮点值。双精度是1位符号，11位指数，52位小数。 浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 下面列举几个浮点常量的实例： 3.14159 /* 合法的 */ 314159E-5L /* 合法的 */ 510E /* 非法的：不完整的指数 */ 210f /* 非法的：没有小数或指数 */ .e55 /* 非法的：缺少整数或分数 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1040.html":{"url":"books/1040.html","title":"字符类型","keywords":"","body":"字符类型 类型 存储大小 值范围 char 1 字节 -128 到 127 或 0 到 255 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 变量 类型 描述 char 通常是一个字节（八位）。这是一个整数类型。 字符常量 字符常量是括在单引号中，例如，'x' 可以存储在 char 类型的简单变量中。 字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\\t'），或一个通用的字符（例如 '\\u02C0'）。 在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码： 转义序列 含义 \\ \\ 字符 \\' ' 字符 \\\" \" 字符 \\? ? 字符 \\a 警报铃声 \\b 退格键 \\f 换页符 \\n 换行符 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\ooo 一到三位的八进制数 \\xhh . . . 一个或多个数字的十六进制数 字符串常量 字符串字面值或常量是括在双引号 \"\" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。 您可以使用空格做分隔符，把一个很长的字符串常量进行分行。 下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。 \"hello, dear\" \"hello, \\ dear\" \"hello, \" \"d\" \"ear\" 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1021.html":{"url":"books/1021.html","title":"构造类型","keywords":"","body":"构造类型 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1022.html":{"url":"books/1022.html","title":"数组","keywords":"","body":"数组 C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、...、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1074.html":{"url":"books/1074.html","title":"使用过程","keywords":"","body":"使用过程 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1075.html":{"url":"books/1075.html","title":"一维数组","keywords":"","body":"一维数组 声明数组 在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示： type arrayName [ arraySize ]; 这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 balance，声明语句如下： double balance[10]; 现在 balance 是一个可用的数组，可以容纳 10 个类型为 double 的数字。 初始化数组 在 C 中，可以逐个初始化数组，也可以使用一个初始化语句，如下所示： double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。 如果省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果： double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 将创建一个数组，它与前一个实例中所创建的数组是完全相同的。 下面是一个为数组中某个元素赋值的实例： balance[4] = 50.0; 上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示： 访问数组元素 数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如： double salary = balance[9]; 上面的语句将把数组中第 10 个元素的值赋给 salary 变量。 //下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组： include int main () { int n[ 10 ]; /* n 是一个包含 10 个整数的数组 */ int i,j; /* 初始化数组元素 */ for ( i = 0; i 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1076.html":{"url":"books/1076.html","title":"多维数组","keywords":"","body":"多维数组 C 语言支持多维数组。多维数组声明的一般形式如下： type name[size1][size2]...[sizeN]; //例如，下面的声明创建了一个三维 5 . 10 . 4 整型数组： int threedim[5][10][4]; 二维数组 声明二维数组 多维数组最简单的形式是二维数组。一个二维数组，在本质上，是一个一维数组的列表。声明一个 x 行 y 列的二维整型数组，形式如下： type arrayName [ x ][ y ]; 其中，type 可以是任意有效的 C 数据类型，arrayName 是一个有效的 C 标识符。一个二维数组可以被认为是一个带有 x 行和 y 列的表格。 //下面是一个二维数组，包含 3 行和 4 列： int x[3][4]; 因此，数组中的每个元素是使用形式为 a[ i , j ] 的元素名称来标识的，其中 a 是数组名称，i 和 j 是唯一标识 a 中每个元素的下标。 初始化二维数组 多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。 int a[3][4] = { {0, 1, 2, 3} , /* 初始化索引号为 0 的行 */ {4, 5, 6, 7} , /* 初始化索引号为 1 的行 */ {8, 9, 10, 11} /* 初始化索引号为 2 的行 */ }; 内部嵌套的括号是可选的，下面的初始化与上面是等同的： int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11}; 访问二维数组元素 二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的。例如： int val = a[2][3]; 上面的语句将获取数组中第 3 行第 4 个元素。 //用嵌套循环来处理二维数组： #include int main () { /* 一个带有 5 行 2 列的数组 */ int a[5][2] = { {0,0}, {1,2}, {2,4}, {3,6},{4,8}}; int i, j; /* 输出数组中每个元素的值 */ for ( i = 0; i 可以创建任意维度的数组，但是一般情况下，我们创建的数组是一维数组和二维数组。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1081.html":{"url":"books/1081.html","title":"字符数组(字符串)","keywords":"","body":"字符数组(字符串) 在 C 语言中，字符串实际上是使用 null 字符 '\\0' 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 下面的声明和初始化创建了一个 \"Hello\" 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 \"Hello\" 的字符数多一个。 char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\\0'}; 依据数组初始化规则，您可以把上面的语句写成以下语句： char greeting[] = \"Hello\"; 以下是 C/C++ 中定义的字符串的内存表示： 不需要把 null 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 '\\0' 放在字符串的末尾。让我们尝试输出上面的字符串： #include int main () { char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\\0'}; printf(\"Greeting message: %s\\n\", greeting ); return 0; } //Greeting message: Hello C 中有大量操作字符串的函数： 序号 函数 & 目的 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。 3 strlen(s1); 返回字符串 s1 的长度。 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1则返回小于 0；如果 s1>s2 则返回大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 下面的实例使用了上述的一些函数： #include #include int main () { char str1[12] = \"Hello\"; char str2[12] = \"World\"; char str3[12]; int len ; /* 复制 str1 到 str3 */ strcpy(str3, str1); printf(\"strcpy( str3, str1) : %s\\n\", str3 ); /* 连接 str1 和 str2 */ strcat( str1, str2); printf(\"strcat( str1, str2): %s\\n\", str1 ); /* 连接后，str1 的总长度 */ len = strlen(str1); printf(\"strlen(str1) : %d\\n\", len ); return 0; } /* strcpy( str3, str1) : Hello strcat( str1, str2): HelloWorld strlen(str1) : 10 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1077.html":{"url":"books/1077.html","title":"功能补充","keywords":"","body":"功能补充 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1078.html":{"url":"books/1078.html","title":"传递数组给函数","keywords":"","body":"传递数组给函数 在函数中传递一个一维数组作为参数，必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针。同样地，也可以传递一个多维数组作为形式参数。 方式 1 形式参数是一个指针 void myFunction(int *param) { . . . } 方式 2 形式参数是一个已定义大小的数组： void myFunction(int param[10]) { . . . } 方式 3 形式参数是一个未定义大小的数组： void myFunction(int param[]) { . . . } #include //现在，让我们来看下面这个函数，它把数组作为参数，同时还传递了另一个参数，根据所传的参数，会返回数组中各元素的平均值： double getAverage(int arr[], int size) { int i; double avg; double sum; for (i = 0; i 就函数而言，数组的长度是无关紧要的，因为 C 不会对形式参数执行边界检查。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1079.html":{"url":"books/1079.html","title":"从函数返回数组","keywords":"","body":"从函数返回数组 C 语言不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针. 如果想要从函数返回一个一维数组，必须声明一个返回指针的函数，如下： int * myFunction() { . . . } 另外，C 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。 //现在，让我们来看下面的函数，它会生成 10 个随机数，并使用数组来返回它们，具体如下： #include #include #include /* 要生成和返回随机数的函数 */ int * getRandom( ) { static int r[10]; int i; /* 设置种子 */ srand( (unsigned)time( NULL ) ); for ( i = 0; i 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1080.html":{"url":"books/1080.html","title":"指向数组的指针","keywords":"","body":"指向数组的指针 数组名是一个指向数组中第一个元素的常量指针。因此，在下面的声明中： double balance[50]; balance 是一个指向 &balance[0] 的指针，即数组 balance 的第一个元素的地址。 因此，下面的程序片段把 p 赋值为 balance 的第一个元素的地址： double *p; double balance[10]; p = balance; 使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4]数据的合法方式。 一旦您把第一个元素的地址存储在p 中，您就可以使用*p 、*(p+1)、*(p+2) 等来访问数组元素。 #include int main () { /* 带有 5 个元素的整型数组 */ double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0}; double *p; int i; p = balance; /* 输出数组中每个元素的值 */ printf( \"使用指针的数组值\\n\"); for ( i = 0; i 在上面的实例中，p 是一个指向 double 型的指针，这意味着它可以存储一个 double 类型的变量。一旦我们有了 p 中的地址，*p 将给出存储在 p 中相应地址的值，正如上面实例中所演示的。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1023.html":{"url":"books/1023.html","title":"结构体","keywords":"","body":"结构体 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1091.html":{"url":"books/1091.html","title":"使用","keywords":"","body":"使用 C 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。 结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性： Title Author Subject Book ID 定义结构 为了定义结构，必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下： struct tag { member-list member-list member-list ... } variable-list ; tag 是结构体标签。 member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。 variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式： 在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。以下为实例： //此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c //同时又声明了结构体变量s1 //这个结构体并没有标明其标签 struct { int a; char b; double c; } s1; //此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c //结构体的标签被命名为SIMPLE,没有声明变量 struct SIMPLE { int a; char b; double c; }; //用SIMPLE标签的结构体，另外声明了变量t1、t2、t3 struct SIMPLE t1, t2[20], *t3; //也可以用typedef创建新类型 typedef struct { int a; char b; double c; } Simple2; //现在可以用Simple2作为类型声明新的结构体变量 Simple2 u1, u2[20], *u3; 在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=&s1，则是非法的。 结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。 //此结构体的声明包含了其他的结构体 struct COMPLEX { char string[100]; struct SIMPLE a; }; //此结构体的声明包含了指向自己类型的指针 struct NODE { char string[100]; struct NODE *next_node; }; 如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示： struct B; //对结构体B进行不完整声明 //结构体A中包含指向结构体B的指针 struct A { struct B *partner; //other members; }; //结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明 struct B { struct A *partner; //other members; }; 结构体变量的初始化 和其它类型变量一样，对结构体变量可以在定义时指定初始值。 #include struct Books { char title[50]; char author[50]; char subject[100]; int book_id; } book = {\"C 语言\", \"RUNOOB\", \"编程语言\", 123456}; int main() { printf(\"title : %s\\nauthor: %s\\nsubject: %s\\nbook_id: %d\\n\", book.title, book.author, book.subject, book.book_id); } /* title : C 语言 author: RUNOOB subject: 编程语言 book_id: 123456 */ 访问结构成员 为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。可以使用 struct 关键字来定义结构类型的变量。下面的实例演示了结构的用法： #include #include struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main( ) { struct Books Book1; /* 声明 Book1，类型为 Books */ struct Books Book2; /* 声明 Book2，类型为 Books */ /* Book1 详述 */ strcpy( Book1.title, \"C Programming\"); strcpy( Book1.author, \"Nuha Ali\"); strcpy( Book1.subject, \"C Programming Tutorial\"); Book1.book_id = 6495407; /* Book2 详述 */ strcpy( Book2.title, \"Telecom Billing\"); strcpy( Book2.author, \"Zara Ali\"); strcpy( Book2.subject, \"Telecom Billing Tutorial\"); Book2.book_id = 6495700; /* 输出 Book1 信息 */ printf( \"Book 1 title : %s\\n\", Book1.title); printf( \"Book 1 author : %s\\n\", Book1.author); printf( \"Book 1 subject : %s\\n\", Book1.subject); printf( \"Book 1 book_id : %d\\n\", Book1.book_id); /* 输出 Book2 信息 */ printf( \"Book 2 title : %s\\n\", Book2.title); printf( \"Book 2 author : %s\\n\", Book2.author); printf( \"Book 2 subject : %s\\n\", Book2.subject); printf( \"Book 2 book_id : %d\\n\", Book2.book_id); return 0; } /* Book 1 title : C Programming Book 1 author : Nuha Ali Book 1 subject : C Programming Tutorial Book 1 book_id : 6495407 Book 2 title : Telecom Billing Book 2 author : Zara Ali Book 2 subject : Telecom Billing Tutorial Book 2 book_id : 6495700 */ 结构作为函数参数 可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量： #include #include struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; /* 函数声明 */ void printBook( struct Books book ); int main( ) { struct Books Book1; /* 声明 Book1，类型为 Books */ struct Books Book2; /* 声明 Book2，类型为 Books */ /* Book1 详述 */ strcpy( Book1.title, \"C Programming\"); strcpy( Book1.author, \"Nuha Ali\"); strcpy( Book1.subject, \"C Programming Tutorial\"); Book1.book_id = 6495407; /* Book2 详述 */ strcpy( Book2.title, \"Telecom Billing\"); strcpy( Book2.author, \"Zara Ali\"); strcpy( Book2.subject, \"Telecom Billing Tutorial\"); Book2.book_id = 6495700; /* 输出 Book1 信息 */ printBook( Book1 ); /* 输出 Book2 信息 */ printBook( Book2 ); return 0; } void printBook( struct Books book ) { printf( \"Book title : %s\\n\", book.title); printf( \"Book author : %s\\n\", book.author); printf( \"Book subject : %s\\n\", book.subject); printf( \"Book book_id : %d\\n\", book.book_id); } /* Book title : C Programming Book author : Nuha Ali Book subject : C Programming Tutorial Book book_id : 6495407 Book title : Telecom Billing Book author : Zara Ali Book subject : Telecom Billing Tutorial Book book_id : 6495700 */ 指向结构的指针 可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示： struct Books *struct_pointer; 现在，可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 & 运算符放在结构名称的前面，如下所示： struct_pointer = &Book1; 为了使用指向该结构的指针访问结构的成员，必须使用 -> 运算符，如下所示： struct_pointer->title; 让我们使用结构指针来重写上面的实例，这将有助于理解结构指针的概念： #include #include struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; /* 函数声明 */ void printBook( struct Books *book ); int main( ) { struct Books Book1; /* 声明 Book1，类型为 Books */ struct Books Book2; /* 声明 Book2，类型为 Books */ /* Book1 详述 */ strcpy( Book1.title, \"C Programming\"); strcpy( Book1.author, \"Nuha Ali\"); strcpy( Book1.subject, \"C Programming Tutorial\"); Book1.book_id = 6495407; /* Book2 详述 */ strcpy( Book2.title, \"Telecom Billing\"); strcpy( Book2.author, \"Zara Ali\"); strcpy( Book2.subject, \"Telecom Billing Tutorial\"); Book2.book_id = 6495700; /* 通过传 Book1 的地址来输出 Book1 信息 */ printBook( &Book1 ); /* 通过传 Book2 的地址来输出 Book2 信息 */ printBook( &Book2 ); return 0; } void printBook( struct Books *book ) { printf( \"Book title : %s\\n\", book->title); printf( \"Book author : %s\\n\", book->author); printf( \"Book subject : %s\\n\", book->subject); printf( \"Book book_id : %d\\n\", book->book_id); } /* Book title : C Programming Book author : Nuha Ali Book subject : C Programming Tutorial Book book_id : 6495407 Book title : Telecom Billing Book author : Zara Ali Book subject : Telecom Billing Tutorial Book book_id : 6495700 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1092.html":{"url":"books/1092.html","title":"位域","keywords":"","body":"位域 有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为\"位域\"或\"位段\"。 所谓\"位域\"是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。 典型的实例： 用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。 读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。 位域的定义和位域变量的说明 位域定义与结构定义相仿，其形式为： struct 位域结构名 { 位域列表 }; 其中位域列表的形式为： 类型说明符 位域名: 位域长度 例如： struct bs{ int a:8; int b:2; int c:6; }data; 说明 data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。 让我们再来看一个实例： struct packed_struct { unsigned int f1:1; unsigned int f2:1; unsigned int f3:1; unsigned int f4:1; unsigned int type:4; unsigned int my_int:9; } pack; 在这里，packed_struct 包含了 6 个成员：四个 1 位的标识符 f1..f4、一个 4 位的 type 和一个 9 位的 my_int。 对于位域的定义尚有以下几点说明： 一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如： struct bs{ unsigned a:4; unsigned :4; /* 空域 */ unsigned b:4; /* 从下一单元开始存放 */ unsigned c:4 } 在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。如果最大长度大于计算机的整数字长，一些编译器可能会允许域的内存重叠，另外一些编译器可能会把大于一个域的部分存储在下一个字中。 struct k{ int a:1; int :2; /* 该 2 位不能使用 */ int b:3; int c:2; }; 从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。 位域的使用 位域的使用和结构成员的使用相同，其一般形式为： 位域变量名.位域名 位域变量名地址->位域名 位域允许用各种格式输出。 请看下面的实例： main(){ struct bs{ unsigned a:1; unsigned b:3; unsigned c:4; } bit,*pbit; bit.a=1; /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */ bit.b=7; /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */ bit.c=15; /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */ printf(\"%d,%d,%d\\n\",bit.a,bit.b,bit.c); /* 以整型量格式输出三个域的内容 */ pbit=&bit; /* 把位域变量 bit 的地址送给指针变量 pbit */ pbit->a=0; /* 用指针方式给位域 a 重新赋值，赋为 0 */ pbit->b&=3; /* 使用了复合的位运算符 \"&=\"，相当于：pbit->b=pbit->b&3，位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&011=011，十进制值为 3） */ pbit->c|=1; /* 使用了复合位运算符\"|=\"，相当于：pbit->c=pbit->c|1，其结果为 15 */ printf(\"%d,%d,%d\\n\",pbit->a,pbit->b,pbit->c); /* 用指针方式输出了这三个域的值 */ } 上例程序中定义了位域结构 bs，三个位域为 a、b、c。说明了 bs 类型的变量 bit 和指向 bs 类型的指针变量 pbit。这表示位域也是可以使用指针的。 如果程序的结构中包含多个开关量，只有 TRUE/FALSE 变量，如下： struct { unsigned int widthValidated; unsigned int heightValidated; } status; 这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1。在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成： struct { unsigned int widthValidated : 1; unsigned int heightValidated : 1; } status; 现在，上面的结构中，status 变量将占用 4 个字节的内存空间，但是只有 2 位被用来存储值。如果用了 32 个变量，每一个变量宽度为 1 位，那么 status 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。让我们看看下面的实例来理解这个概念： #include #include /* 定义简单的结构 */ struct { unsigned int widthValidated; unsigned int heightValidated; } status1; /* 定义位域结构 */ struct { unsigned int widthValidated : 1; unsigned int heightValidated : 1; } status2; int main( ) { printf( \"Memory size occupied by status1 : %d\\n\", sizeof(status1)); printf( \"Memory size occupied by status2 : %d\\n\", sizeof(status2)); return 0; } /* Memory size occupied by status1 : 8 Memory size occupied by status2 : 4 */ 位域声明 在结构内声明位域的形式如下： struct { type [member_name] : width ; }; 下面是有关位域中变量元素的描述： 元素 描述 type 整数类型，决定了如何解释位域的值。类型可以是整型、有符号整型、无符号整型。 member_name 位域的名称。 width 位域中位的数量。宽度必须小于或等于指定类型的位宽度。 带有预定义宽度的变量被称为位域。位域可以存储多于 1 位的数，例如，需要一个变量来存储从 0 到 7 的值，您可以定义一个宽度为 3 位的位域，如下： struct { unsigned int age : 3; } Age; 上面的结构定义指示 C 编译器，age 变量将只使用 3 位来存储这个值，如果您试图使用超过 3 位，则无法完成。让我们来看下面的实例： #include #include struct { unsigned int age : 3; } Age; int main( ) { Age.age = 4; printf( \"Sizeof( Age ) : %d\\n\", sizeof(Age) ); printf( \"Age.age : %d\\n\", Age.age ); Age.age = 7; printf( \"Age.age : %d\\n\", Age.age ); Age.age = 8; // 二进制表示为 1000 有四位，超出 printf( \"Age.age : %d\\n\", Age.age ); return 0; } /* Sizeof( Age ) : 4 Age.age : 4 Age.age : 7 Age.age : 0 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1024.html":{"url":"books/1024.html","title":"共用体","keywords":"","body":"共用体 共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。 定义共用体 为了定义共用体，必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下： union [union tag] { member definition; member definition; ... member definition; } [one or more union variables]; union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str： union Data { int i; float f; char str[20]; } data; 现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。 共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。下面的实例将显示上面的共用体占用的总内存大小： #include #include union Data { int i; float f; char str[20]; }; int main( ) { union Data data; printf( \"Memory size occupied by data : %d\\n\", sizeof(data)); return 0; } //Memory size occupied by data : 20 访问共用体成员 为了访问共用体的成员，我们使用成员访问运算符（.）。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。可以使用 union 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法： #include #include union Data { int i; float f; char str[20]; }; int main( ) { union Data data; data.i = 10; data.f = 220.5; strcpy( data.str, \"C Programming\"); printf( \"data.i : %d\\n\", data.i); printf( \"data.f : %f\\n\", data.f); printf( \"data.str : %s\\n\", data.str); return 0; } /* data.i : 1917853763 data.f : 4122360580327794860452759994368.000000 data.str : C Programming */ 在这里，我们可以看到共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次我们在同一时间只使用一个变量，这也演示了使用共用体的主要目的： #include #include union Data { int i; float f; char str[20]; }; int main( ) { union Data data; data.i = 10; printf( \"data.i : %d\\n\", data.i); data.f = 220.5; printf( \"data.f : %f\\n\", data.f); strcpy( data.str, \"C Programming\"); printf( \"data.str : %s\\n\", data.str); return 0; } /* data.i : 10 data.f : 220.500000 data.str : C Programming */ 在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1039.html":{"url":"books/1039.html","title":"枚举类型","keywords":"","body":"enum(枚举) 枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。 枚举语法定义格式为： enum　枚举名　{枚举元素1,枚举元素2,……}; 接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名： #define MON 1 #define TUE 2 #define WED 3 #define THU 4 #define FRI 5 #define SAT 6 #define SUN 7 这个看起来代码量就比较多，接下来我们看看使用枚举的方式： enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }; 这样看起来是不是更简洁了。 注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。 可以在定义枚举类型时改变枚举元素的值： enum season {spring, summer=3, autumn, winter}; 没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5 枚举变量的定义 前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。 我们可以通过以下三种方式来定义枚举变量 1、先定义枚举类型，再定义枚举变量 enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }; enum DAY day; 2、定义枚举类型的同时定义枚举变量 enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN } day; 3、省略枚举名称，直接定义枚举变量 enum { MON=1, TUE, WED, THU, FRI, SAT, SUN } day; #include enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }; int main() { enum DAY day; day = WED; printf(\"%d\",day); return 0; } //3 在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。 不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。 //以下实例使用 for 来遍历枚举的元素： #include enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN } day; int main() { // 遍历枚举元素 for (day = MON; day //以下枚举类型不连续，这种枚举无法遍历。 enum { ENUM_0, ENUM_10 = 10, ENUM_11 }; //枚举在 switch 中的使用： #include #include int main() { enum color { red=1, green, blue }; enum color favorite_color; /* ask user to choose color */ printf(\"请输入你喜欢的颜色: (1. red, 2. green, 3. blue): \"); scanf(\"%d\", &favorite_color); /* 输出结果 */ switch (favorite_color) { case red: printf(\"你喜欢的颜色是红色\"); break; case green: printf(\"你喜欢的颜色是绿色\"); break; case blue: printf(\"你喜欢的颜色是蓝色\"); break; default: printf(\"你没有选择你喜欢的颜色\"); } return 0; } /* 请输入你喜欢的颜色: (1. red, 2. green, 3. blue): 1 你喜欢的颜色是红色 */ 将整数转换为枚举 //以下实例将整数转换为枚举： #include #include int main() { enum day { saturday, sunday, monday, tuesday, wednesday, thursday, friday } workday; int a = 1; enum day weekend; weekend = ( enum day ) a; //类型转换 //weekend = a; //错误 printf(\"weekend:%d\",weekend); return 0; } //weekend:1 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1025.html":{"url":"books/1025.html","title":"指针类型","keywords":"","body":"指针类型 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1115.html":{"url":"books/1115.html","title":"使用过程","keywords":"","body":"end 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1116.html":{"url":"books/1116.html","title":"指针","keywords":"","body":"指针 每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址 //下面的实例，它将输出定义的变量地址： #include int main () { int var1; char var2[10]; printf(\"var1 变量的地址： %p\\n\", &var1 ); printf(\"var2 变量的地址： %p\\n\", &var2 ); return 0; } //var1 变量的地址： 0x7fff5cc109d4 //var2 变量的地址： 0x7fff5cc109de 什么是指针？ 指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： type *var-name; 在这里，type 是指针的基类型，它必须是一个有效的 C 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： int *ip; /* 一个整型的指针 */ double *dp; /* 一个 double 型的指针 */ float *fp; /* 一个浮点型的指针 */ char *ch; /* 一个字符型的指针 */ 所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 如何使用指针？ 使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： #include int main () { int var = 20; /* 实际变量的声明 */ int *ip; /* 指针变量的声明 */ ip = &var; /* 在指针变量中存储 var 的地址 */ printf(\"Address of var variable: %p\\n\", &var ); /* 在指针变量中存储的地址 */ printf(\"Address stored in ip variable: %p\\n\", ip ); /* 使用指针访问值 */ printf(\"Value of *ip variable: %d\\n\", *ip ); return 0; } //Address of var variable: bffd8b3c //Address stored in ip variable: bffd8b3c //Value of *ip variable: 20 C 中的 NULL 指针 在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。 NULL 指针是一个定义在标准库中的值为零的常量。 #include int main () { int *ptr = NULL; printf(\"ptr 的地址是 %p\\n\", ptr ); return 0; } //ptr 的地址是 0x0 在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。 如需检查一个空指针，您可以使用 if 语句，如下所示： if(ptr) /* 如果 p 非空，则完成 */ if(!ptr) /* 如果 p 为空，则完成 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1117.html":{"url":"books/1117.html","title":"指针数组","keywords":"","body":"指针数组 在我们讲解指针数组的概念之前，先让我们来看一个实例，它用到了一个由 3 个整数组成的数组： #include const int MAX = 3; int main () { int var[] = {10, 100, 200}; int i; for (i = 0; i 可能有一种情况，我们想要让数组存储指向 int 或 char 或其他数据类型的指针。下面是一个指向整数的指针数组的声明： int *ptr[MAX]; 在这里，把 ptr 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。 //因此，ptr 中的每个元素，都是一个指向 int 值的指针。下面的实例用到了三个整数，它们将存储在一个指针数组中，如下所示： #include const int MAX = 3; int main () { int var[] = {10, 100, 200}; int i, *ptr[MAX]; for ( i = 0; i 也可以用一个指向字符的指针数组来存储一个字符串列表 #include const int MAX = 4; int main () { const char *names[] = { \"Zara Ali\", \"Hina Ali\", \"Nuha Ali\", \"Sara Ali\", }; int i = 0; for ( i = 0; i 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1123.html":{"url":"books/1123.html","title":"函数指针","keywords":"","body":"函数指针 函数指针是指向函数的指针变量。 通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。 函数指针可以像一般函数一样，用于调用函数、传递参数。 函数指针变量的声明： typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型 //以下实例声明了函数指针变量 p，指向函数 max： #include int max(int x, int y) { return x > y ? x : y; } int main(void) { /* p 是函数指针 */ int (* p)(int, int) = & max; // &可以省略 int a, b, c, d; printf(\"请输入三个数字:\"); scanf(\"%d %d %d\", & a, & b, & c); /* 与直接调用函数等价，d = max(max(a, b), c) */ d = p(p(a, b), c); printf(\"最大的数字是: %d\\n\", d); return 0; } //请输入三个数字:1 2 3 //最大的数字是: 3 回调函数 函数指针作为某个函数的参数 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。 简单讲：回调函数是由别人的函数执行时调用你实现的函数。 以下是来自知乎作者常溪玲的解说： 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。 实例 实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。 实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。 populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。 #include #include // 回调函数 void populate_array(int *array, size_t arraySize, int (*getNextValue)(void)) { for (size_t i=0; i 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1118.html":{"url":"books/1118.html","title":"功能补充","keywords":"","body":"功能补充 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1119.html":{"url":"books/1119.html","title":"指针的运算","keywords":"","body":"指针的运算 C 指针是一个用数值表示的地址。因此，可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-。 假设 ptr 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算： ptr++ 在执行完上述的运算之后，ptr 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 个字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 ptr 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。 递增一个指针 我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，数组可以看成一个指针常量。下面的程序递增变量指针，以便顺序访问数组中的每一个元素： #include const int MAX = 3; int main () { int var[] = {10, 100, 200}; int i, *ptr; /* 指针中的数组地址 */ ptr = var; for ( i = 0; i 递减一个指针 同样地，对指针进行递减运算，即把值减去其数据类型的字节数，如下所示： #include const int MAX = 3; int main () { int var[] = {10, 100, 200}; int i, *ptr; /* 指针中最后一个元素的地址 */ ptr = &var[MAX-1]; for ( i = MAX; i > 0; i--) { printf(\"存储地址：var[%d] = %x\\n\", i-1, ptr ); printf(\"存储值：var[%d] = %d\\n\", i-1, *ptr ); /* 移动到下一个位置 */ ptr--; } return 0; } /* 存储地址：var[2] = 518a0ae4 存储值：var[2] = 200 存储地址：var[1] = 518a0ae0 存储值：var[1] = 100 存储地址：var[0] = 518a0adc 存储值：var[0] = 10 */ 指针的比较 指针可以用关系运算符进行比较，如 ==、。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。 下面的程序修改了上面的实例，只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 &var[MAX - 1]，则把变量指针进行递增： #include const int MAX = 3; int main () { int var[] = {10, 100, 200}; int i, *ptr; /* 指针中第一个元素的地址 */ ptr = var; i = 0; while ( ptr 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1120.html":{"url":"books/1120.html","title":"指向指针的指针","keywords":"","body":"指向指针的指针 指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。 一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针： int **var; 当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示： #include int main () { int var; int *ptr; int **pptr; var = 3000; /* 获取 var 的地址 */ ptr = &var; /* 使用运算符 & 获取 ptr 的地址 */ pptr = &ptr; /* 使用 pptr 获取值 */ printf(\"Value of var = %d\\n\", var ); printf(\"Value available at *ptr = %d\\n\", *ptr ); printf(\"Value available at **pptr = %d\\n\", **pptr); return 0; } /* Value of var = 3000 Value available at *ptr = 3000 Value available at **pptr = 3000 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1121.html":{"url":"books/1121.html","title":"传递指针给函数","keywords":"","body":"传递指针给函数 C 语言允许您传递指针给函数，只需要简单地声明函数参数为指针类型即可。 //下面的实例中，我们传递一个无符号的 long 型指针给函数，并在函数内改变这个值： #include #include void getSeconds(unsigned long *par); int main () { unsigned long sec; getSeconds( &sec ); /* 输出实际值 */ printf(\"Number of seconds: %ld\\n\", sec ); return 0; } void getSeconds(unsigned long *par) { /* 获取当前的秒数 */ *par = time( NULL ); return; } //Number of seconds :1294450468 能接受指针作为参数的函数，也能接受数组作为参数，如下所示： #include /* 函数声明 */ double getAverage(int *arr, int size); int main () { /* 带有 5 个元素的整型数组 */ int balance[5] = {1000, 2, 3, 17, 50}; double avg; /* 传递一个指向数组的指针作为参数 */ avg = getAverage( balance, 5 ) ; /* 输出返回值 */ printf(\"Average value is: %f\\n\", avg ); return 0; } double getAverage(int *arr, int size) { int i, sum = 0; double avg; for (i = 0; i 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1122.html":{"url":"books/1122.html","title":"从函数返回指针","keywords":"","body":"从函数返回指针 C 允许从函数返回指针。为了做到这点，必须声明一个返回指针的函数，如下所示： int * myFunction() { . . . } 另外，C 语言不支持在调用函数时返回局部变量的地址，除非定义局部变量为 static 变量。 //现在，让我们来看下面的函数，它会生成 10 个随机数，并使用表示指针的数组名（即第一个数组元素的地址）来返回它们，具体如下 #include #include #include /* 要生成和返回随机数的函数 */ int * getRandom( ) { static int r[10]; int i; /* 设置种子 */ srand( (unsigned)time( NULL ) ); for ( i = 0; i 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1026.html":{"url":"books/1026.html","title":"空类型","keywords":"","body":"空类型 void 类型指定没有可用的值。它通常用于以下三种情况下： 序号 类型与描述 1 函数返回为空 C 中有各种函数都不返回值，或者可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status); 2 函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void); 3 指针指向 void 类型为 void 的指针代表对象的地址，而不是类型。例如，内存分配函数 `void malloc( size_t size );` 返回指向 void 的指针，可以转换为任何数据类型。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1027.html":{"url":"books/1027.html","title":"自定义类型","keywords":"","body":"自定义类型 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1093.html":{"url":"books/1093.html","title":"使用","keywords":"","body":"使用 typedef C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE： typedef unsigned char BYTE; 在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如： BYTE b1, b2; 按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下： typedef unsigned char byte; 也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。 例如，可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下： #include #include typedef struct Books { char title[50]; char author[50]; char subject[100]; int book_id; } Book; int main( ) { Book book; strcpy( book.title, \"C 教程\"); strcpy( book.author, \"Runoob\"); strcpy( book.subject, \"编程语言\"); book.book_id = 12345; printf( \"书标题 : %s\\n\", book.title); printf( \"书作者 : %s\\n\", book.author); printf( \"书类目 : %s\\n\", book.subject); printf( \"书 ID : %d\\n\", book.book_id); return 0; } /* 书标题 : C 教程 书作者 : Runoob 书类目 : 编程语言 书 ID : 12345 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1094.html":{"url":"books/1094.html","title":"区别","keywords":"","body":"区别 typedef vs #define #define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同： typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。 typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。 下面是 #define 的最简单的用法： #include #define TRUE 1 #define FALSE 0 int main( ) { printf( \"TRUE 的值: %d\\n\", TRUE); printf( \"FALSE 的值: %d\\n\", FALSE); return 0; } //TRUE 的值: 1 //FALSE 的值: 0 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1124.html":{"url":"books/1124.html","title":"类型转换","keywords":"","body":"类型转换 强制类型转换是把变量从一种类型转换为另一种数据类型。例如，如果您想存储一个 long 类型的值到一个简单的整型中，您需要把 long 类型强制转换为 int 类型。您可以使用强制类型转换运算符来把值显式地从一种类型转换为另一种类型，如下所示： (type_name) expression 请看下面的实例，使用强制类型转换运算符把一个整数变量除以另一个整数变量，得到一个浮点数： #include int main() { int sum = 17, count = 5; double mean; mean = (double) sum / count; printf(\"Value of mean : %f\\n\", mean ); } //Value of mean : 3.400000 这里要注意的是强制类型转换运算符的优先级大于除法，因此 sum 的值首先被转换为 double 型，然后除以 count，得到一个类型为 double 的值。 类型转换可以是隐式的，由编译器自动执行，也可以是显式的，通过使用强制类型转换运算符来指定。在编程时，有需要类型转换的时候都用上强制类型转换运算符，是一种良好的编程习惯。 整数提升 整数提升是指把小于 int 或 unsigned int 的整数类型转换为 int 或 unsigned int 的过程。请看下面的实例，在 int 中添加一个字符： #include int main() { int i = 17; char c = 'c'; /* ascii 值是 99 */ int sum; sum = i + c; printf(\"Value of sum : %d\\n\", sum ); } //Value of sum : 116 在这里，sum 的值为 116，因为编译器进行了整数提升，在执行实际加法运算时，把 'c' 的值转换为对应的 ascii 值。 常用的算术转换 常用的算术转换是隐式地把值强制转换为相同的类型。编译器首先执行整数提升，如果操作数类型不同，则它们会被转换为下列层次中出现的最高层次的类型： double 常用的算术转换不适用于赋值运算符、逻辑运算符 && 和 ||。让我们看看下面的实例来理解这个概念： #include int main() { int i = 17; char c = 'c'; /* ascii 值是 99 */ float sum; sum = i + c; printf(\"Value of sum : %f\\n\", sum ); } //Value of sum : 116.000000 在这里，c 首先被转换为整数，但是由于最后的值是 float 型的，所以会应用常用的算术转换，编译器会把 i 和 c 转换为浮点型，并把它们相加得到一个浮点数。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1042.html":{"url":"books/1042.html","title":"常量与变量","keywords":"","body":"常量与变量 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。 常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。 变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1043.html":{"url":"books/1043.html","title":"常量","keywords":"","body":"常量 定义常量 在 C 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 使用 const 关键字。 #define 预处理器 下面是使用 #define 预处理器定义常量的形式： #define identifier value 具体请看下面的实例： #include #define LENGTH 10 #define WIDTH 5 #define NEWLINE '\\n' int main() { int area; area = LENGTH * WIDTH; printf(\"value of area : %d\", area); printf(\"%c\", NEWLINE); return 0; } //value of area : 50 const 关键字 您可以使用 const 前缀声明指定类型的常量，如下所示： const type variable = value; 具体请看下面的实例： #include int main() { const int LENGTH = 10; const int WIDTH = 5; const char NEWLINE = '\\n'; int area; area = LENGTH * WIDTH; printf(\"value of area : %d\", area); printf(\"%c\", NEWLINE); return 0; } //value of area : 50 注意:常把常量定义为大写字母形式 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1044.html":{"url":"books/1044.html","title":"变量","keywords":"","body":"变量 全局变量和局部变量 在C语言中，用户命名的标识符都有一个有效的作用域。 所谓标识符的“作用域”就是指程序中的某一部分，在这部分中，该标识符是有定义的，可以被C编译和连接程序所识别。 我们知道每个变量都有自己的作用域，在一个函数内定义的变量，不能在其他函数中引用。显然，变量的作用域与其定义语句在程序中出现的位置有直接的关系，据此变量可以划分为局部变量和全局变量。 注意“定义”和 “说明”两个词的区别。“定义”是指给变量分配确定的存储单元；“说明”只是说明变量的性质。 （一）局部变量 在一个函数内部定义的变量，它们只在本函数范围内有效，即只有本函数才能使用它们，其他函数不能使用这些变量，我们将这些变量称为“局部变量”。不同函数中可以使用相同名字的局部变量，它们代表不同的对象，在内存中占不同的单元，互不干扰。 （二）全局变量 在函数之外定义的变量称为外部变量，外部变量是全局变量。全局变量可以为本文件中其他函数所共用，它的有效范围从定义变量开始到本文件结束。 如果在同一个源文件中，外部变量与局部变量同名，则在局部变量的作用范围内，外部变量被“屏蔽”，即它不起作用。 变量作用域和生存期 生存期:什么时候这个变量开始出现了，到什么时候消亡了，变量值存在的时间(即生存期) 作用域: 在(代码的) 什么范围内可以访问这个变量(这个变量可以起作用) 对于本地变量，这两个问题的答案是统一的:大括号内一块 变量的存储类别 静态存储方式和动态存储方式。 所谓静态存储方式是指在程序运行期间 分配固定的存储空间的方式，而动态存储方式是在程序运行期间 根据需要动态分配存储空间的方式 在内存中供用户使用的空间可以分为程序区、静态存储区和动态存储区3个部分。数据分别被存放在静态存储区和动态存储区中。静态存储区中存放的是全局变量，在程序开始执行时就给全局变量分配存储区。程序执行过程中它们占据固定的存储单元，程序执行完毕这些存储单元就被释放。 每一个变量和函数所具有的属性是：数据的存储类别(存在哪里,存的硬件空间)和数据类型(怎么存,存的格式)。所谓的存储类别指的是数据在内存中存储的方法，其可分为两类：静态存储类和动态存储类。具体包括自动(auto)、静态(static)、寄存器(register)和外部(extern)，共4种。 （一）auto变量 当在函数内部或复合语句内定义变量时，如果没有指定存储类别，或使用了auto说明符，系统就认为所定义的变量具有自动类别。如： float a;等价于auto float a; auto变量的存储单元被分配在内存的动态存储区，每当进入函数体(或复合语句)时，系统自动为auto变量分配存储单元，退出时自动释放这些存储单元另做他用。因此，这类局部变量的作用域是从定义的位置起，到函数体(或复合语句)结束止。 所有自动类局部变量的存储单元都是在进入这些局部变量所在的函数体(或复合语句)时生成，退出其所在的函数体(或复合语句)时消失(变为无定义)。这就是自动类局部变量的“生存期“。当再次进入函数体(或复合语句)时，系统将为它们另行分配存储单元，因此变量的值不可能被保留。随着函数的频繁调用，动态存储区内为某个变量分配的存储单元位置会随程序的运行而改变。 （二）register变量 寄存器变量也是自动类变量。它与auto变量的区别仅在于：用register说明变量是建议编译程序将变量的值保留在CPU的寄存器中，而不是像一般变量那样占用内存单元。程序运行时，访问寄存器内的值要比访问内存中的值快得多。因此，当程序对运行速度有较高要求时，把那些频繁引用的少数变量，指定为register变量，有助于提高程序运行的效率。 说明： (1)CPU中寄存器的数目是有限的，因此只能说明少量的寄存器变量。在同一个函数中，允许说明为寄存器变量的数目不仅取决于CPU的类型，也与所用的C编译程序有关。当没有足够的寄存器来存放指定的变量，或编译程序认为指定的变量不适合放在寄存器中时，将自动按auto变量来处理。因此，register说明只是对编译程序的一种建议，而不是强制性的。 (2)由于register变量的值存放在寄存器内而不是存放在内存中，所以register变量没有地址，也就不能对它实行求地址运算。 (3)register变量的说明应尽量靠近其使用的地方，用完之后尽快释放，以便提高寄存器的利用效率。 （三）static变量 静态存储类别的局部变量，当函数体(或复合语句)内部用static来说明一个变量时，可以称该变量为静态局部变量。它与auto变量、register变量的本质区别是： (1)在整个程序运行期间，静态局部变量在内存中的静态存储区中占据着永久性的存储单元。即使退出函数后，下次再进入该函数时，静态局部变量仍使用原来的存储单元。由于不释放这些存储单元，这些存储单元中的值得以保留，因而可以继续使用存储单元中原来的值。由此可知，静态局部变量的生存期将一直延长到程序运行结束。 (2)静态局部变量的初值是在编译时赋予的，在程序执行期间不再赋以初值。对未赋值的局部变量，C语言编译程序自动给它赋初值为0。 用static声明外部变量，有时在程序设计中希望某些外部变量只限于本文件使用，而不能被其他文件引用，这时可以在定义外部变量时加一个static声明。 并不是对外部变量加上static才是静态存储而不加static的是动态存储。两种形式的外部变量都是静态存储方式，只是作用范围不同而已。 （四）用extern声明外部变量 ①　在一个文件内声明外部变量 当全局变量定义在后，引用它的函数在前时，应该在引用它的函数中用extern对此全局变量进行说明，以便通知编译程序，该变量是一个已在外部定义了的全局变量，已经分配了存储单元，不需要为它另开辟存储单元。这时其作用域从extern说明处起，延伸到该函数末尾。 全局变量的说明与全局变量的定义不同。变量的定义(开辟存储单元)只能出现一次，在定义全局变量时，不可使用extern说明符；而对全局变量的说明，则可以多次出现在需要的地方，这时必须用extern进行说明。 ②　在多文件的程序中声明外部变量 当一个程序由多个单独编译的源文件组成，并且在每个文件中均需要引用同一个全局变量时，若在每个文件中都定义了所需的同名全局变量，则在“连接”时将会产生“重复定义”的错误。在这种情况下，单独编译每个文件时并无异常，编译程序将按定义分别给它们开辟存储空间，而当进行连接时，就会显示出错信息。解决的方法是：在其中一个文件中定义所有全局变量，而在其他用到这些全局变量的文件中用extern对这些变量进行说明。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1125.html":{"url":"books/1125.html","title":"修饰符","keywords":"","body":"end 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1126.html":{"url":"books/1126.html","title":"修饰符","keywords":"","body":"修饰符 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1127.html":{"url":"books/1127.html","title":"auto","keywords":"","body":"auto auto变量 当在函数内部或复合语句内定义变量时，如果没有指定存储类别，或使用了auto说明符，系统就认为所定义的变量具有自动类别。如： float a;等价于auto float a; auto变量的存储单元被分配在内存的动态存储区，每当进入函数体(或复合语句)时，系统自动为auto变量分配存储单元，退出时自动释放这些存储单元另做他用。因此，这类局部变量的作用域是从定义的位置起，到函数体(或复合语句)结束止。 所有自动类局部变量的存储单元都是在进入这些局部变量所在的函数体(或复合语句)时生成，退出其所在的函数体(或复合语句)时消失(变为无定义)。这就是自动类局部变量的“生存期“。当再次进入函数体(或复合语句)时，系统将为它们另行分配存储单元，因此变量的值不可能被保留。随着函数的频繁调用，动态存储区内为某个变量分配的存储单元位置会随程序的运行而改变。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1128.html":{"url":"books/1128.html","title":"register","keywords":"","body":"register register变量 寄存器变量也是自动类变量。它与auto变量的区别仅在于：用register说明变量是建议编译程序将变量的值保留在CPU的寄存器中，而不是像一般变量那样占用内存单元。程序运行时，访问寄存器内的值要比访问内存中的值快得多。因此，当程序对运行速度有较高要求时，把那些频繁引用的少数变量，指定为register变量，有助于提高程序运行的效率。 说明： (1)CPU中寄存器的数目是有限的，因此只能说明少量的寄存器变量。在同一个函数中，允许说明为寄存器变量的数目不仅取决于CPU的类型，也与所用的C编译程序有关。当没有足够的寄存器来存放指定的变量，或编译程序认为指定的变量不适合放在寄存器中时，将自动按auto变量来处理。因此，register说明只是对编译程序的一种建议，而不是强制性的。 (2)由于register变量的值存放在寄存器内而不是存放在内存中，所以register变量没有地址，也就不能对它实行求地址运算。 (3)register变量的说明应尽量靠近其使用的地方，用完之后尽快释放，以便提高寄存器的利用效率。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1129.html":{"url":"books/1129.html","title":"static","keywords":"","body":"static static变量 静态存储类别的局部变量，当函数体(或复合语句)内部用static来说明一个变量时，可以称该变量为静态局部变量。它与auto变量、register变量的本质区别是： (1)在整个程序运行期间，静态局部变量在内存中的静态存储区中占据着永久性的存储单元。即使退出函数后，下次再进入该函数时，静态局部变量仍使用原来的存储单元。由于不释放这些存储单元，这些存储单元中的值得以保留，因而可以继续使用存储单元中原来的值。由此可知，静态局部变量的生存期将一直延长到程序运行结束。 (2)静态局部变量的初值是在编译时赋予的，在程序执行期间不再赋以初值。对未赋值的局部变量，C语言编译程序自动给它赋初值为0。 用static声明外部变量，有时在程序设计中希望某些外部变量只限于本文件使用，而不能被其他文件引用，这时可以在定义外部变量时加一个static声明。 并不是对外部变量加上static才是静态存储而不加static的是动态存储。两种形式的外部变量都是静态存储方式，只是作用范围不同而已。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1130.html":{"url":"books/1130.html","title":"extern","keywords":"","body":"extern 用extern声明外部变量 ①　在一个文件内声明外部变量 当全局变量定义在后，引用它的函数在前时，应该在引用它的函数中用extern对此全局变量进行说明，以便通知编译程序，该变量是一个已在外部定义了的全局变量，已经分配了存储单元，不需要为它另开辟存储单元。这时其作用域从extern说明处起，延伸到该函数末尾。 全局变量的说明与全局变量的定义不同。变量的定义(开辟存储单元)只能出现一次，在定义全局变量时，不可使用extern说明符；而对全局变量的说明，则可以多次出现在需要的地方，这时必须用extern进行说明。 ②　在多文件的程序中声明外部变量 当一个程序由多个单独编译的源文件组成，并且在每个文件中均需要引用同一个全局变量时，若在每个文件中都定义了所需的同名全局变量，则在“连接”时将会产生“重复定义”的错误。在这种情况下，单独编译每个文件时并无异常，编译程序将按定义分别给它们开辟存储空间，而当进行连接时，就会显示出错信息。解决的方法是：在其中一个文件中定义所有全局变量，而在其他用到这些全局变量的文件中用extern对这些变量进行说明。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1131.html":{"url":"books/1131.html","title":"const","keywords":"","body":"const const 关键字 您可以使用 const 前缀声明指定类型的常量，如下所示： const type variable = value; 具体请看下面的实例： #include int main() { const int LENGTH = 10; const int WIDTH = 5; const char NEWLINE = '\\n'; int area; area = LENGTH * WIDTH; printf(\"value of area : %d\", area); printf(\"%c\", NEWLINE); return 0; } //value of area : 50 注意:常把常量定义为大写字母形式 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1132.html":{"url":"books/1132.html","title":"volatile","keywords":"","body":"volatile 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1035.html":{"url":"books/1035.html","title":"运算符与表达式","keywords":"","body":"运算符 C语言的运算符范围很广，可分为以下几类： 1、算术运算符:用于各类数值运算。包括加(+)、减(-)、乘(*)、除(/)、求余(%)、自增(++)、自减(--)共七种。 2、赋值运算符:用于赋值运算，分为简单赋值(=)、复合算术赋值(+=,-=,*=,/=,%=)和复合位运算赋值(&=,|=,^=,>>=, 3、逗号运算符:用于把若干表达式组合成一个表达式(，)。 4、关系运算符:用于比较运算。包括大于(>)、小于(=)、小于等于( 5、逻辑运算符:用于逻辑运算。包括与(&&)、或(||)、非(!)三种。 6、条件运算符:这是一个三目运算符，用于条件求值(?:)。 真前假后 7、位操作运算符:参与运算的量，按二进制位进行运算。包括位与(&)、位或(|)、位非(~)、位异或(^)、左移(>)六种。 8、指针运算符:用于取内容(*)和取地址(&)二种运算。 9.、求字节数运算符:用于计算数据类型所占的字节数(sizeof)。 10、特殊运算符:有括号()，下标[]，成员(→，.)等几种。 另外，按参与运算的对象个数，C语言运算符可分为：单目运算符 (如 ！)、双目运算符 (如+，- )和三目运算符 (如 ? ： )。 级别由大到小:(逻辑)非 >算(术运算符) >关(系运算符) >(逻辑)与 >(逻辑)或 >条(件运算符) >赋(值运算符) 表达式 是表达式就一定有数值。算术表达式是用算术运算符和括号将运算量(也称操作数)连接起来的、符合C语言语法规则的表达式。运算对象包括函数、常量和变量等。 赋值表达式： 表达式数值是最左边的数值，a=b=5;该表达式为5，常量不可以赋值。 自加、自减表达式： 假设a=5，++a（是为6）， a++（为5）；运行的机理：++a 是先把变量的数值加上1，然后把得到的数值放到变量a中，然后再用这个++a表达式的数值为6，而a++是先用该表达式的数值为5，然后再把a的数值加上1为6，再放到变量a中。 进行了++a和a++后 在下面的程序中再用到a的话都是变量a中的6了。 考试口诀：++在前先加后用，++在后先用后加。 逗号表达式： 优先级别最低 ；表达式的数值逗号最右边的那个表达式的数值。（2，3，4）的表达式的数值就是4。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1045.html":{"url":"books/1045.html","title":"按照属性分类","keywords":"","body":"end 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1063.html":{"url":"books/1063.html","title":"基本","keywords":"","body":"基本运算符 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1047.html":{"url":"books/1047.html","title":"赋值","keywords":"","body":"赋值运算符 下表列出了 C 语言支持的赋值运算符： 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C = A 相当于 C = C A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A 左移且赋值运算符 C >>= 右移且赋值运算符 C >>= 2 等同于 C = C >> 2 &= 按位与且赋值运算符 C &= 2 等同于 C = C & 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 \\ = 按位或且赋值运算符 C \\ = 2 等同于 C = C \\ 2 #include main() { int a = 21; int c ; c = a; printf(\"Line 1 - = 运算符实例，c 的值 = %d\\n\", c ); c += a; printf(\"Line 2 - += 运算符实例，c 的值 = %d\\n\", c ); c -= a; printf(\"Line 3 - -= 运算符实例，c 的值 = %d\\n\", c ); c *= a; printf(\"Line 4 - *= 运算符实例，c 的值 = %d\\n\", c ); c /= a; printf(\"Line 5 - /= 运算符实例，c 的值 = %d\\n\", c ); c = 200; c %= a; printf(\"Line 6 - %= 运算符实例，c 的值 = %d\\n\", c ); c >= 2; printf(\"Line 8 - >>= 运算符实例，c 的值 = %d\\n\", c ); c &= 2; printf(\"Line 9 - &= 运算符实例，c 的值 = %d\\n\", c ); c ^= 2; printf(\"Line 10 - ^= 运算符实例，c 的值 = %d\\n\", c ); c |= 2; printf(\"Line 11 - |= 运算符实例，c 的值 = %d\\n\", c ); } /* Line 1 - = 运算符实例，c 的值 = 21 Line 2 - += 运算符实例，c 的值 = 42 Line 3 - -= 运算符实例，c 的值 = 21 Line 4 - *= 运算符实例，c 的值 = 441 Line 5 - /= 运算符实例，c 的值 = 21 Line 6 - %= 运算符实例，c 的值 = 11 Line 7 - >= 运算符实例，c 的值 = 11 Line 9 - &= 运算符实例，c 的值 = 2 Line 10 - ^= 运算符实例，c 的值 = 0 Line 11 - |= 运算符实例，c 的值 = 2 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1055.html":{"url":"books/1055.html","title":"括号","keywords":"","body":"括号运算符 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1048.html":{"url":"books/1048.html","title":"逗号","keywords":"","body":"逗号运算符 优先级别最低 ；表达式的数值逗号最右边的那个表达式的数值。（2，3，4）的表达式的数值就是4。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1064.html":{"url":"books/1064.html","title":"计算","keywords":"","body":"计算运算符 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1046.html":{"url":"books/1046.html","title":"算术","keywords":"","body":"算术运算符 下表显示了 C 语言支持的所有算术运算符。假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 -- 自减运算符，整数值减少 1 A-- 将得到 9 #include int main() { int a = 21; int b = 10; int c ; c = a + b; printf(\"Line 1 - c 的值是 %d\\n\", c ); c = a - b; printf(\"Line 2 - c 的值是 %d\\n\", c ); c = a * b; printf(\"Line 3 - c 的值是 %d\\n\", c ); c = a / b; printf(\"Line 4 - c 的值是 %d\\n\", c ); c = a % b; printf(\"Line 5 - c 的值是 %d\\n\", c ); c = a++; // 赋值后再加 1 ，c 为 21，a 为 22 printf(\"Line 6 - c 的值是 %d\\n\", c ); c = a--; // 赋值后再减 1 ，c 为 22 ，a 为 21 printf(\"Line 7 - c 的值是 %d\\n\", c ); } /* Line 1 - c 的值是 31 Line 2 - c 的值是 11 Line 3 - c 的值是 210 Line 4 - c 的值是 2 Line 5 - c 的值是 1 Line 6 - c 的值是 21 Line 7 - c 的值是 22 */ 除法运算符 /的运算分为两种情况： a、“除”的左右两边都为整数时，所得结果必然是整数（注意：仅取整数部分，不是四舍五入） 比如：5/2的值为2，不是2.5,1/2的值为0。 b、“除”的左右两边至少有一个是实型数据（即小数）时，所得结果为实型数据。 比如：5/2.0的值为2.5,7.0/2.0的值为3.5. 求模运算符 %(模运算符或称求余运算符，%两侧均应为整型数据，如9%7的值为2)。 需要说明的是：当运算对象为负数时，所得结果随编译器不同而不同，在vc中，结果的符号与被除数相同，比如：13%-2值为1，而-15%2值为-1. %符号两边要求是整数。不是整数就错了 自加自减 作用：使变量的值增1或减1。 前后区别 假设a=5，++a（表达式值为6）， a++（表达式值为5）； ++a 是先把变量的数值加上1，然后把得到的数值放到变量a中，然后再用这个++a表达式的数值为6， a++是先用该表达式的数值为5，然后再把a的数值加上1为6，再放到变量a中。 即进行了++a和a++后 在下面的程序中再用到a的话都是变量a中的6了。 考试口诀：++在前先加后用，++在后先用后加。 ++i，--i (在使用i之前，先使i的值加1、减1)。 i++，i-- (在使用i之后，使i的值加1、减1)。 在循环语句中常用到自增（减）运算符，在指针中也常用到该运算符，区别“i++”和“++i”及“i--”和“--i”,表达式的值和变量的值。 例：变量n的初始值为2，则 - 表达式类型 i++ ++i i-- --i - n值为2时各表达式的值 2 3 2 1 - 经过各表达式运算后变量n的值变化为 3 3 1 1 对象 只有变量才能用自增运算符 (++)和自减运算符(--)，而常量或表达式不能用，如10++或(x+y)++都是不合法的。 方向 ++和--的结合方向是“自右向左“，如 -i++ ，i的左边是负号运算符，右边是自增运算符，负号运算和自增运算都是 “自右向左“结合的，相当于-(i++)。 printf语句 当++或—与printf语句结合时， 若++/--x的形式，则先自增/自减，然后输出； 若x++/--的形式，则先输出x原值，再进行自增/自减操作； 且printf运算方向为从右向左。 #include main() { int x=011; printf(\"%d\\n\",++x); //10 } //011是一个八进制的数，转为十进制则为1*8+1=9； //++x是x先自增1再参与其他运算，所以先x自增1为10再输出即为10 算术表达式和运算符的优先级与结合性 在计算机语言中，算术表达式的求值规律与数学中的四则运算的规律类似，其运算规则和要求如下。 (1)在算术表达式中，可使用多层圆括号，但括号必须配对。运算时从内层圆括号开始，由内向外依次计算各表达式的值。 (2)在算术表达式中，对于不同优先级的运算符，可按运算符的优先级由高到低进行运算，若表达式中运算符的优先级相同，则按运算符的结合方向进行运算。 (3)如果一个运算符两侧的操作数类型不同，则先利用自动转换或强制类型转换，使两者具有相同类型，然后进行运算。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1052.html":{"url":"books/1052.html","title":"位操作","keywords":"","body":"位操作运算符 位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示： p q p & q p \\ q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 ----------------- A&B = 0000 1100 A|B = 0011 1101 A^B = 0011 0001 ~A = 1100 0011 下表显示了 C 语言支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则： 运算符 描述 实例 & 按位与操作，按二进制位进行\"与\"运算。运算规则：0&0=0; 0&1=0; 1&0=0; 1&1=1; (A & B) 将得到 12，即为 0000 1100 \\ 按位或运算符，按二进制位进行\"或\"运算。运算规则：`0 0=0; 0 1=1; 1 0=1; 1 1=1;` (A \\ B) 将得到 61，即为 0011 1101 ^ 异或运算符，按二进制位进行\"异或\"运算。运算规则：0^0=0; 0^1=1; 1^0=1; 1^1=0; (A ^ B) 将得到 49，即为 0011 0001 ~ 取反运算符，按二进制位进行\"取反\"运算。运算规则：~1=0; ~0=1; (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 A >> 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 #include int main() { unsigned int a = 60; /* 60 = 0011 1100 */ unsigned int b = 13; /* 13 = 0000 1101 */ int c = 0; c = a & b; /* 12 = 0000 1100 */ printf(\"Line 1 - c 的值是 %d\\n\", c ); c = a | b; /* 61 = 0011 1101 */ printf(\"Line 2 - c 的值是 %d\\n\", c ); c = a ^ b; /* 49 = 0011 0001 */ printf(\"Line 3 - c 的值是 %d\\n\", c ); c = ~a; /*-61 = 1100 0011 */ printf(\"Line 4 - c 的值是 %d\\n\", c ); c = a > 2; /* 15 = 0000 1111 */ printf(\"Line 6 - c 的值是 %d\\n\", c ); } /* Line 1 - c 的值是 12 Line 2 - c 的值是 61 Line 3 - c 的值是 49 Line 4 - c 的值是 -61 Line 5 - c 的值是 240 Line 6 - c 的值是 15 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1054.html":{"url":"books/1054.html","title":"求字节","keywords":"","body":"求字节运算符 运算符 描述 实例 sizeof() 返回变量的大小。 sizeof(a) 将返回 4，其中 a 是整数。 #include int main() { int a = 4; short b; double c; /* sizeof 运算符实例 */ printf(\"Line 1 - 变量 a 的大小 = %lu\\n\", sizeof(a) ); printf(\"Line 2 - 变量 b 的大小 = %lu\\n\", sizeof(b) ); printf(\"Line 3 - 变量 c 的大小 = %lu\\n\", sizeof(c) ); } /* Line 1 - 变量 a 的大小 = 4 Line 2 - 变量 b 的大小 = 2 Line 3 - 变量 c 的大小 = 8 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1065.html":{"url":"books/1065.html","title":"判断","keywords":"","body":"判断 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1049.html":{"url":"books/1049.html","title":"关系","keywords":"","body":"关系运算符 下表显示了 C 语言支持的所有关系运算符。假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 > 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A > B) 不为真。 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A >= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A >= B) 不为真。 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A #include int main() { int a = 21; int b = 10; int c ; if( a == b ) { printf(\"Line 1 - a 等于 b\\n\" ); } else { printf(\"Line 1 - a 不等于 b\\n\" ); } if ( a b ) { printf(\"Line 3 - a 大于 b\\n\" ); } else { printf(\"Line 3 - a 不大于 b\\n\" ); } /* 改变 a 和 b 的值 */ a = 5; b = 20; if ( a = a ) { printf(\"Line 5 - b 大于或等于 a\\n\" ); } } /* Line 1 - a 不等于 b Line 2 - a 不小于 b Line 3 - a 大于 b Line 4 - a 小于或等于 b Line 5 - b 大于或等于 a */ C语言中的逻辑值 C语言中的逻辑值只有两个：真（true)和假（flase)。用非零代表真，用零代表假。 因此，对于任意一个表达式，如果它的值为零，就代表一个假值，如果它的值为非零，就代表一个真值。 只要值不是零，不管是正数，负数，整数，实数，都代表一个真值。例如-5的逻辑值为真。 关系运算符 由两个字符组成的运算符之间不可以加空格，关系运算符都是双目运算符。 (1)结合性：自左向右。 (2)优先次序：前4种关系运算符( =，> )的优先级别相同，后两种 (==，!=)优先级相同，且前4种优先级高于后两种；关系运算符的优先级低于算术运算符，高于赋值运算符。 关系表达式 由关系运算符连接而成的表达式称为关系表达式。 例如：a>b,（a=7)>(b=10)等都是合法的关系表达式。 关系表达式的结果有两个：0和1。其中0表示假，1表示真。如果关系表达式成立，则值为真，如果关系表达式不成立，则值为假。 例：变量a的值为5，b的值为6，那么关系表达式a>b的值为假，即为0.而关系表达式 （a=13)>(b=10)的值为真，即为1。 当关系运算符两边值的类型不一致时，若一边是整型，一边是实型，系统将自动把整型数转化为实型数，然后再进行比较。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1050.html":{"url":"books/1050.html","title":"逻辑","keywords":"","body":"逻辑运算符 下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符 描述 实例 && 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A && B) 为假。 \\ \\ 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 (A \\ \\ B) 为真。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !(A && B) 为真。 #include int main() { int a = 5; int b = 20; int c ; if ( a && b ) { printf(\"Line 1 - 条件为真\\n\" ); } if ( a || b ) { printf(\"Line 2 - 条件为真\\n\" ); } /* 改变 a 和 b 的值 */ a = 0; b = 10; if ( a && b ) { printf(\"Line 3 - 条件为真\\n\" ); } else { printf(\"Line 3 - 条件不为真\\n\" ); } if ( !(a && b) ) { printf(\"Line 4 - 条件为真\\n\" ); } } /* Line 1 - 条件为真 Line 2 - 条件为真 Line 3 - 条件不为真 Line 4 - 条件为真 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1051.html":{"url":"books/1051.html","title":"条件","keywords":"","body":"条件运算符 运算符 描述 实例 ? : 条件表达式 如果条件为真 ? 则值为 X : 否则值为 Y #include int main() { int a = 4; short b; double c; /* 三元运算符实例 */ a = 10; b = (a == 1) ? 20: 30; printf( \"b 的值是 %d\\n\", b ); b = (a == 10) ? 20: 30; printf( \"b 的值是 %d\\n\", b ); } /* b 的值是 30 b 的值是 20 */ 条件运算符? : 可以用来替代 if...else 语句。它的一般形式如下： Exp1 ? Exp2 : Exp3; 其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。 ? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。 //以下实例通过输入一个数字来判断它是否为奇数或偶数 #include int main() { int num; printf(\"输入一个数字 : \"); scanf(\"%d\",&num); (num%2==0)?printf(\"偶数\"):printf(\"奇数\"); } 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1066.html":{"url":"books/1066.html","title":"构件","keywords":"","body":"构件运算符 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1056.html":{"url":"books/1056.html","title":"下标","keywords":"","body":"下标作运算符 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1057.html":{"url":"books/1057.html","title":"成员","keywords":"","body":"成员运算符 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1053.html":{"url":"books/1053.html","title":"指针","keywords":"","body":"指针运算符 运算符 描述 实例 & 返回变量的地址。 &a; 将给出变量的实际地址。 * 指向一个变量。 *a; 将指向一个变量。 #include int main() { int a = 4; short b; double c; int* ptr; /* & 和 * 运算符实例 */ ptr = &a; /* 'ptr' 现在包含 'a' 的地址 */ printf(\"a 的值是 %d\\n\", a); printf(\"*ptr 是 %d\\n\", *ptr); } /* a 的值是 4 *ptr 是 4 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1058.html":{"url":"books/1058.html","title":"按照参与个数分类","keywords":"","body":"按照参与个数分类 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1059.html":{"url":"books/1059.html","title":"单目","keywords":"","body":"单目运算符 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1060.html":{"url":"books/1060.html","title":"双目","keywords":"","body":"双目运算符 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1061.html":{"url":"books/1061.html","title":"三目","keywords":"","body":"三目运算符 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1062.html":{"url":"books/1062.html","title":"优先级","keywords":"","body":"优先级 运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。 例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。 下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。 类别 运算符 结合性 后缀 () [] -> . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* & sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 > 从左到右 关系 >= 从左到右 相等 == != 从左到右 位与 AND & 从左到右 位异或 XOR ^ 从左到右 位或 OR \\ 从左到右 逻辑与 AND && 从左到右 逻辑或 OR \\ \\ 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=>>= = 从右到左 逗号 , 从左到右 #include main() { int a = 20; int b = 10; int c = 15; int d = 5; int e; e = (a + b) * c / d; // ( 30 * 15 ) / 5 printf(\"(a + b) * c / d 的值是 %d\\n\", e ); e = ((a + b) * c) / d; // (30 * 15 ) / 5 printf(\"((a + b) * c) / d 的值是 %d\\n\" , e ); e = (a + b) * (c / d); // (30) * (15/5) printf(\"(a + b) * (c / d) 的值是 %d\\n\", e ); e = a + (b * c) / d; // 20 + (150/5) printf(\"a + (b * c) / d 的值是 %d\\n\" , e ); return 0; } /* (a + b) * c / d 的值是 90 ((a + b) * c) / d 的值是 90 (a + b) * (c / d) 的值是 90 a + (b * c) / d 的值是 50 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1032.html":{"url":"books/1032.html","title":"语句","keywords":"","body":"顺序结构 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1151.html":{"url":"books/1151.html","title":"语句块","keywords":"","body":"语句块 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1031.html":{"url":"books/1031.html","title":"控制语句","keywords":"","body":"流程设计 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1033.html":{"url":"books/1033.html","title":"选择结构","keywords":"","body":"选择结构 判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。 C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。 分类 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if...else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 可以在一个 switch 语句内使用另一个 switch 语句。 if 语句 if(boolean_expression) { /* 如果布尔表达式为真将执行的语句 */ } 如果布尔表达式为 true，则 if 语句内的代码块将被执行。如果布尔表达式为 false，则 if 语句结束后的第一组代码（闭括号后）将被执行。 C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。 #include int main () { /* 局部变量定义 */ int a = 10; /* 使用 if 语句检查布尔条件 */ if( a if...else语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为 false 时执行。 C 语言中 if...else 语句的语法： if(boolean_expression) { /* 如果布尔表达式为真将执行的语句 */ } else { /* 如果布尔表达式为假将执行的语句 */ } 如果布尔表达式为 true，则执行 if 块内的代码。如果布尔表达式为 false，则执行 else 块内的代码。 C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。 #include int main () { /* 局部变量定义 */ int a = 100; /* 检查布尔条件 */ if( a if...else if...else 语句 一个 if 语句后可跟一个可选的 else if...else 语句，这可用于测试多种条件。 当使用 if...else if...else 语句时，以下几点需要注意： 一个 if 后可跟零个或一个 else，else 必须在所有 else if 之后。 一个 if 后可跟零个或多个 else if，else if 必须在 else 之前。 一旦某个 else if 匹配成功，其他的 else if 或 else 将不会被测试。 C 语言中的 if...else if...else 语句的语法： if(boolean_expression 1) { /* 当布尔表达式 1 为真时执行 */ } else if( boolean_expression 2) { /* 当布尔表达式 2 为真时执行 */ } else if( boolean_expression 3) { /* 当布尔表达式 3 为真时执行 */ } else { /* 当上面条件都不为真时执行 */ } #include int main () { /* 局部变量定义 */ int a = 100; /* 检查布尔条件 */ if( a == 10 ) { /* 如果 if 条件为真，则输出下面的语句 */ printf(\"a 的值是 10\\n\" ); } else if( a == 20 ) { /* 如果 else if 条件为真，则输出下面的语句 */ printf(\"a 的值是 20\\n\" ); } else if( a == 30 ) { /* 如果 else if 条件为真，则输出下面的语句 */ printf(\"a 的值是 30\\n\" ); } else { /* 如果上面条件都不为真，则输出下面的语句 */ printf(\"没有匹配的值\\n\" ); } printf(\"a 的准确值是 %d\\n\", a ); return 0; } /* 没有匹配的值 a 的准确值是 100 */ 嵌套if语句 在 C 语言中，嵌套 if-else 语句是合法的，这意味着您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 C 语言中 嵌套 if 语句的语法： if( boolean_expression 1) { /* 当布尔表达式 1 为真时执行 */ if(boolean_expression 2) { /* 当布尔表达式 2 为真时执行 */ } } 可以嵌套 else if...else，方式与嵌套 if 语句相似。 #include int main () { /* 局部变量定义 */ int a = 100; int b = 200; /* 检查布尔条件 */ if( a == 100 ) { /* 如果条件为真，则检查下面的条件 */ if( b == 200 ) { /* 如果条件为真，则输出下面的语句 */ printf(\"a 的值是 100，且 b 的值是 200\\n\" ); } } printf(\"a 的准确值是 %d\\n\", a ); printf(\"b 的准确值是 %d\\n\", b ); return 0; } /* a 的值是 100，且 b 的值是 200 a 的准确值是 100 b 的准确值是 200 */ switch语句 一个 switch 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 switch case 进行检查。 C 语言中 switch 语句的语法： switch(expression){ case constant-expression : statement(s); break; /* 可选的 */ case constant-expression : statement(s); break; /* 可选的 */ /* 您可以有任意数量的 case 语句 */ default : /* 可选的 */ statement(s); } switch 语句必须遵循下面的规则： switch 语句中的 expression 是一个常量表达式，必须是一个整型或枚举类型。 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。 case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为止。 当遇到 break 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。 不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会 继续 后续的 case，直到遇到 break 为止。 一个 switch 语句可以有一个可选的 default case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 break 语句不是必需的。 #include int main () { /* 局部变量定义 */ char grade = 'B'; switch(grade) { case 'A' : printf(\"很棒！\\n\" ); break; case 'B' : case 'C' : printf(\"做得好\\n\" ); break; case 'D' : printf(\"您通过了\\n\" ); break; case 'F' : printf(\"最好再试一下\\n\" ); break; default : printf(\"无效的成绩\\n\" ); } printf(\"您的成绩是 %c\\n\", grade ); return 0; } /* 做得好 您的成绩是 B */ 嵌套switch语句 可以把一个 switch 作为一个外部 switch 的语句序列的一部分，即可以在一个 switch 语句内使用另一个 switch 语句。即使内部和外部 switch 的 case 常量包含共同的值，也没有矛盾。 C 语言中 嵌套 switch 语句的语法： switch(ch1) { case 'A': printf(\"这个 A 是外部 switch 的一部分\" ); switch(ch2) { case 'A': printf(\"这个 A 是内部 switch 的一部分\" ); break; case 'B': /* 内部 B case 代码 */ } break; case 'B': /* 外部 B case 代码 */ } #include int main () { /* 局部变量定义 */ int a = 100; int b = 200; switch(a) { case 100: printf(\"这是外部 switch 的一部分\\n\"); switch(b) { case 200: printf(\"这是内部 switch 的一部分\\n\"); } } printf(\"a 的准确值是 %d\\n\", a ); printf(\"b 的准确值是 %d\\n\", b ); return 0; } /* 这是外部 switch 的一部分 这是内部 switch 的一部分 a 的准确值是 100 b 的准确值是 200 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1034.html":{"url":"books/1034.html","title":"循环结构","keywords":"","body":"循环结构 有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。 编程语言提供了更为复杂执行路径的多种控制结构。 循环类型 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do...while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 while循环 只要给定的条件为真，C 语言中的 while 循环语句会重复执行一个目标语句。 C 语言中 while 循环的语法： while(condition) { statement(s); } 在这里，statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。 condition 可以是任意的表达式，当为任意非零值时都为 true。当条件为 true 时执行循环。 当条件为 false 时，退出循环，程序流将继续执行紧接着循环的下一条语句。 在这里，while 循环的关键点是循环可能一次都不会执行。当条件为 false 时，会跳过循环主体，直接执行紧接着 while 循环的下一条语句。 #include int main () { /* 局部变量定义 */ int a = 10; /* while 循环执行 */ while( a for循环 for 循环允许编写一个执行指定次数的循环控制结构。 C 语言中 for 循环的语法： for ( init; condition; increment ) { statement(s); } 下面是 for 循环的控制流： init 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。 接下来，会判断 condition。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。 在执行完 for 循环主体后，控制流会跳回上面的 increment 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。 #include int main () { /* for 循环执行 */ for( int a = 10; a do...while 循环 不像 for 和 while 循环，它们是在循环头部测试循环条件。在 C 语言中，do...while 循环是在循环的尾部检查它的条件。 do...while 循环与 while 循环类似，但是 do...while 循环会确保至少执行一次循环。 C 语言中 do...while 循环的语法： do { statement(s); }while( condition ); 请注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。 如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。 #include int main () { /* 局部变量定义 */ int a = 10; /* do 循环执行 */ do { printf(\"a 的值： %d\\n\", a); a = a + 1; }while( a 嵌套循环 C 语言允许在一个循环内使用另一个循环，下面演示几个实例来说明这个概念。 C 语言中 嵌套 for 循环 语句的语法： for (initialization; condition; increment/decrement) { statement(s); for (initialization; condition; increment/decrement) { statement(s); ... ... ... } ... ... ... } //下面的程序使用了一个嵌套的 for 循环来查找 2 到 100 中的质数： #include int main () { /* 局部变量定义 */ int i, j; for(i=2; i (i/j)) printf(\"%d 是质数\\n\", i); } return 0; } /* 2 是质数 3 是质数 5 是质数 7 是质数 11 是质数 13 是质数 17 是质数 19 是质数 23 是质数 29 是质数 31 是质数 37 是质数 41 是质数 43 是质数 47 是质数 53 是质数 59 是质数 61 是质数 67 是质数 71 是质数 73 是质数 79 是质数 83 是质数 89 是质数 97 是质数 */ C 语言中 嵌套 while 循环 语句的语法： while (condition1) { statement(s); while (condition2) { statement(s); ... ... ... } ... ... ... } #include int main() { int i=1,j; while (i C 语言中 嵌套 do...while 循环 语句的语法： do { statement(s); do { statement(s); ... ... ... }while (condition2); ... ... ... }while (condition1); 可以在任何类型的循环内嵌套其他任何类型的循环。比如，一个 for 循环可以嵌套在一个 while 循环内，反之亦然。 #include int main() { int i=1,j; do { j=1; do { printf(\"*\"); j++; }while(j 循环控制语句 循环控制语句改变你代码的执行顺序。通过它你可以实现代码的跳转。 控制语句 描述 break 语句 终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。 continue 语句 告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 break语句 C 语言中 break 语句有以下两种用法： 当 break 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。 它可用于终止 switch 语句中的一个 case。 如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。 C 语言中 break 语句的语法： break; #include int main () { /* 局部变量定义 */ int a = 10; /* while 循环执行 */ while( a 15) { /* 使用 break 语句终止循环 */ break; } } return 0; } /* a 的值： 10 a 的值： 11 a 的值： 12 a 的值： 13 a 的值： 14 a 的值： 15 */ continue语句 C 语言中的 continue 语句有点像 break 语句。但它不是强制终止，continue 会跳过当前循环中的代码，强迫开始下一次循环。 对于 for 循环，continue 语句执行后自增语句仍然会执行。对于 while 和 do...while 循环，continue 语句\b重新执行条件判断语句。 C 语言中 continue 语句的语法： continue; #include int main () { /* 局部变量定义 */ int a = 10; /* do 循环执行 */ do { if( a == 15) { /* 跳过迭代 */ a = a + 1; continue; } printf(\"a 的值： %d\\n\", a); a++; }while( a goto语句 C 语言中的 goto 语句允许把控制无条件转移到同一函数内的被标记的语句。 注意：在任何编程语言中，都不建议使用 goto 语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。任何使用 goto 语句的程序可以改写成不需要使用 goto 语句的写法。 C 语言中 goto 语句的语法： goto label; .. . label: statement; 在这里，label 可以是任何除 C 关键字以外的纯文本，它可以设置在 C 程序中 goto 语句的前面或者后面。 #include int main () { /* 局部变量定义 */ int a = 10; /* do 循环执行 */ LOOP:do { if( a == 15) { /* 跳过迭代 */ a = a + 1; goto LOOP; } printf(\"a 的值： %d\\n\", a); a++; }while( a 无限循环 如果条件永远不为假，则循环将变成无限循环。for 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。 #include int main () { for( ; ; ) { printf(\"该循环会永远执行下去！\\n\"); } return 0; } 当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C 程序员偏向于使用 for(;;) 结构来表示一个无限循环。 注意：您可以按 Ctrl + C 键终止一个无限循环。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1036.html":{"url":"books/1036.html","title":"函数","keywords":"","body":"函数 函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。 您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。 函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。 C 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。 函数还有很多叫法，比如方法、子例程或程序，等等。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1067.html":{"url":"books/1067.html","title":"使用过程","keywords":"","body":"使用过程 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1068.html":{"url":"books/1068.html","title":"定义函数","keywords":"","body":"定义函数 C 语言中的函数定义的一般形式如下： return_type function_name( parameter list ) { body of the function } 在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体：函数主体包含一组定义函数执行任务的语句。 //以下是 max() 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数： /* 函数返回两个数中较大的那个数 */ int max(int num1, int num2) { /* 局部变量声明 */ int result; if (num1 > num2) result = num1; else result = num2; return result; } 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1069.html":{"url":"books/1069.html","title":"函数声明","keywords":"","body":"函数声明 函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数声明包括以下几个部分： return_type function_name( parameter list ); 针对上面定义的函数 max()，以下是函数声明： int max(int num1, int num2); 在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明： int max(int, int); 在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，应该在调用函数的文件顶部声明函数。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1070.html":{"url":"books/1070.html","title":"调用函数","keywords":"","body":"调用函数 创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。 当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。 调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。 #include /* 函数声明 */ int max(int num1, int num2); int main () { /* 局部变量定义 */ int a = 100; int b = 200; int ret; /* 调用函数来获取最大值 */ ret = max(a, b); printf( \"Max value is : %d\\n\", ret ); return 0; } /* 函数返回两个数中较大的那个数 */ int max(int num1, int num2) { /* 局部变量声明 */ int result; if (num1 > num2) result = num1; else result = num2; return result; } //把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果： //Max value is : 200 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1071.html":{"url":"books/1071.html","title":"函数参数","keywords":"","body":"函数参数 如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。 形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。 当调用函数时，有两种向函数传递参数的方式： 调用类型 描述 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 引用调用 通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。 默认情况下，C 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。 C 传值方式调用函数 向函数传递参数的传值调用方法，把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 默认情况下，C 语言使用传值调用方法来传递参数。一般来说，这意味着函数内的代码不会改变用于调用函数的实际参数。 //函数 swap() 定义如下： /* 函数定义 */ void swap(int x, int y) { int temp; temp = x; /* 保存 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 temp 赋值给 y */ return; } //---------------------------------------------- //现在，让我们通过传递实际参数来调用函数 swap()： #include /* 函数声明 */ void swap(int x, int y); int main () { /* 局部变量定义 */ int a = 100; int b = 200; printf(\"交换前，a 的值： %d\\n\", a ); printf(\"交换前，b 的值： %d\\n\", b ); /* 调用函数来交换值 */ swap(a, b); printf(\"交换后，a 的值： %d\\n\", a ); printf(\"交换后，b 的值： %d\\n\", b ); return 0; } //----------------------------------------------- //当上面的代码被编译和执行时，它会产生下列结果： /* 交换前，a 的值： 100 交换前，b 的值： 200 交换后，a 的值： 100 交换后，b 的值： 200 */ //上面的实例表明了，虽然在函数内改变了 a 和 b 的值，但是实际上 a 和 b 的值没有发生变化。 C 引用方式调用函数 通过引用传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。 传递指针可以让多个函数访问指针所引用的对象，而不用把对象声明为全局可访问。 /* 函数定义 */ void swap(int *x, int *y) { int temp; temp = *x; /* 保存地址 x 的值 */ *x = *y; /* 把 y 赋值给 x */ *y = temp; /* 把 temp 赋值给 y */ return; } //--------------------------------------------- // 现在，让我们通过引用传值来调用函数 swap()： #include /* 函数声明 */ void swap(int *x, int *y); int main () { /* 局部变量定义 */ int a = 100; int b = 200; printf(\"交换前，a 的值： %d\\n\", a ); printf(\"交换前，b 的值： %d\\n\", b ); /* 调用函数来交换值 * &a 表示指向 a 的指针，即变量 a 的地址 * &b 表示指向 b 的指针，即变量 b 的地址 */ swap(&a, &b); printf(\"交换后，a 的值： %d\\n\", a ); printf(\"交换后，b 的值： %d\\n\", b ); return 0; } //--------------------------------------------- //当上面的代码被编译和执行时，它会产生下列结果： /* 交换前，a 的值： 100 交换前，b 的值： 200 交换后，a 的值： 200 交换后，b 的值： 100 */ //上面的实例表明了，与传值调用不同，引用调用在函数内改变了 a 和 b 的值，实际上也改变了函数外 a 和 b 的值。 可变参数 有时，可能会碰到这样的情况，希望函数带有可变数量的参数，而不是预定义数量的参数。C 语言为这种情况提供了一个解决方案，它允许定义一个函数，能根据具体的需求接受可变数量的参数。下面的实例演示了这种函数的定义。 int func(int, ... ) { . . . } int main() { func(2, 2, 3); func(3, 2, 3, 4); } 请注意，函数 func() 最后一个参数写成省略号，即三个点号（...），省略号之前的那个参数是 int，代表了要传递的可变参数的总数。为了使用这个功能，需要使用 stdarg.h 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下： 定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。 在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。 使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。 使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。 使用宏 va_end 来清理赋予 va_list 变量的内存。 现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值： #include #include double average(int num,...) { va_list valist; double sum = 0.0; int i; /* 为 num 个参数初始化 valist */ va_start(valist, num); /* 访问所有赋给 valist 的参数 */ for (i = 0; i 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1072.html":{"url":"books/1072.html","title":"作用域规则","keywords":"","body":"作用域规则 任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量： 在函数或块内部的局部变量 在所有函数外部的全局变量 在形式参数的函数参数定义中 让我们来看看什么是局部变量、全局变量和形式参数。 局部变量 在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。下面是使用局部变量的实例。在这里，所有的变量 a、b 和 c 是 main() 函数的局部变量。 #include int main () { /* 局部变量声明 */ int a, b; int c; /* 实际初始化 */ a = 10; b = 20; c = a + b; printf (\"value of a = %d, b = %d and c = %d\\n\", a, b, c); return 0; } 全局变量 全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。 全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。下面是使用全局变量和局部变量的实例： #include /* 全局变量声明 */ int g; int main () { /* 局部变量声明 */ int a, b; /* 实际初始化 */ a = 10; b = 20; g = a + b; printf (\"value of a = %d, b = %d and g = %d\\n\", a, b, g); return 0; } 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。 #include /* 全局变量声明 */ int g = 20; int main () { /* 局部变量声明 */ int g = 10; printf (\"value of g = %d\\n\", g); return 0; } //value of g = 10 形式参数 函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。 #include /* 全局变量声明 */ int a = 20; int main () { /* 在主函数中的局部变量声明 */ int a = 10; int b = 20; int c = 0; int sum(int, int); printf (\"value of a in main() = %d\\n\", a); c = sum( a, b); printf (\"value of c in main() = %d\\n\", c); return 0; } /* 添加两个整数的函数 */ int sum(int a, int b) { printf (\"value of a in sum() = %d\\n\", a); printf (\"value of b in sum() = %d\\n\", b); return a + b; } /* value of a in main() = 10 value of a in sum() = 10 value of b in sum() = 20 value of c in main() = 30 */ 初始化局部变量和全局变量 当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示： 数据类型 初始化默认值 int 0 char '\\0' float 0 double 0 pointer NULL 正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。 全局变量与局部变量在内存中的区别： 全局变量保存在内存的全局存储区中，占用静态的存储单元； 局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。 更多内容可参考：C/C++ 中 static 的用法全局变量与局部变量 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1145.html":{"url":"books/1145.html","title":"特殊的函数","keywords":"","body":"特殊的函数 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1144.html":{"url":"books/1144.html","title":"主函数","keywords":"","body":"关于main C99中的定义 //在最新的 C99 标准中，只有以下两种定义方式是正确的： int main(void){} //整数类型主函数(无类型) = int main() int main(int　argc,char **argv) //整数类型主函数(整数类型　统计参数个数,字符类型*数组指针至字符[]) //第一个参数是表示输入的字符串的数目，第二个参数是指向存放的字符串 C++98中的定义 //如下两种main函数的定义方式： int main( ) int main( int argc, char *argv[] ) C语言中int main()和int main(void)区别 K&R书上main函数定义写成main(){...} 形式，不写返回值类型也不写参数列表，这是Old Style C的风格。Old Style C规定不写返回值类型就表示返回int型，不写参数列表 就表示参数类型和个数没有明确指出。这种宽松的规定会导致很多复杂的Bug产生，不幸的是现在的C标准为了兼容旧的代码仍然保留了这种语法。 其实系统在调用main函数时是传参数的，所以main函数最标准的形式应 该是int main(int argc, char *argv[])。C标准也规定了int main(void) 这种形式，如果不使用系统传进来的两个参数也可以写成这种形式。但除了这两种形式之外，以其它形式定义main函数都是错误的或不可移植的。 C 命令行参数 执行程序时，可以从命令行传值给 C 程序。这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。 命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。 main 的两个参数的参数名如下: int main( int argc, char *argv[] ) 并不一定这样写，只是约定俗成。也可以写成下面这样，或者其他名字 int main( int test_argc, char *test_argv[] ) 下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作： #include int main( int argc, char *argv[] ) { if( argc == 2 ) { printf(\"The argument supplied is %s\\n\", argv[1]); } else if( argc > 2 ) { printf(\"Too many arguments supplied.\\n\"); } else { printf(\"One argument expected.\\n\"); } } 使用一个参数，编译并执行上面的代码，它会产生下列结果： $./a.out testing The argument supplied is testing 使用两个参数，编译并执行上面的代码，它会产生下列结果： $./a.out testing1 testing2 Too many arguments supplied. 不传任何参数，编译并执行上面的代码，它会产生下列结果： $./a.out One argument expected 应当指出的是，argv[0] 存储程序的名称，argv[1] 是一个指向第一个命令行参数的指针，argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，*argc 将被设置为 2。 多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 \"\" 或单引号 '' 内部。让我们重新编写上面的实例，有一个空间，那么你可以通过这样的观点，把它们放在双引号或单引号\"\"\"\"。让我们重新编写上面的实例，向程序传递一个放置在双引号内部的命令行参数： #include int main( int argc, char *argv[] ) { printf(\"Program name %s\\n\", argv[0]); if( argc == 2 ) { printf(\"The argument supplied is %s\\n\", argv[1]); } else if( argc > 2 ) { printf(\"Too many arguments supplied.\\n\"); } else { printf(\"One argument expected.\\n\"); } } 使用一个用空格分隔的简单参数，参数括在双引号中，编译并执行上面的代码，它会产生下列结果： $./a.out \"testing1 testing2\" Progranm name ./a.out The argument supplied is testing1 testing2 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1149.html":{"url":"books/1149.html","title":"导入机制","keywords":"","body":"导入机制 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1096.html":{"url":"books/1096.html","title":"头文件","keywords":"","body":"头文件 头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。 在程序中要使用头文件，需要使用 C 预处理指令 #include 来引用它。前面我们已经看过 stdio.h 头文件，它是编译器自带的头文件。 引用头文件相当于复制头文件的内容，但是我们不会直接在源文件中复制头文件的内容，因为这么做很容易出错，特别在程序是由多个源文件组成的时候。 A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。 引用头文件的语法 使用预处理指令 #include 可以引用用户和系统头文件。它的形式有以下两种： #include 这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。 #include \"file\" 这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。 引用头文件的操作 #include 指令会指示 C 预处理器浏览指定的文件作为输入。预处理器的输出包含了已经生成的输出，被引用文件生成的输出以及 #include 指令之后的文本输出。例如，如果您有一个头文件 header.h，如下： char *test (void); 和一个使用了头文件的主程序 program.c，如下： int x; #include \"header.h\" int main (void) { puts (test ()); } 编译器会看到如下的代码信息： int x; char *test (void); int main (void) { puts (test ()); } 只引用一次头文件 如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下： #ifndef HEADER_FILE #define HEADER_FILE the entire header file file #endif 这种结构就是通常所说的包装器 #ifndef。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。 有条件引用 有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下： #if SYSTEM_1 # include \"system_1.h\" #elif SYSTEM_2 # include \"system_2.h\" #elif SYSTEM_3 ... #endif 但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的有条件引用。它不是用头文件的名称作为 #include 的直接参数，您只需要使用宏名称代替即可： #define SYSTEM_H \"system_1.h\" ... #include SYSTEM_H SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 #include 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。 关于#include 预处理，这一行没有分号，所以不是语句，在c语言中称之为命令行，或者叫做“预编译处理命令”。 编译预处理不是C语言的一部分，不占运行时间，不要加分号。C语言编译的程序称为源程序，它以ASCII数值存放在文本文件中。 #include “stdio.h”与#include 区别 <>搜索顺序为：系统目录-->环境变量目录-->用户自定义目录。 \"\"则是用户自定义目录-->系统目录-->环境变量目录. 这里一个C语言程序是有两个文件组成，分别是no1.c， no2.c。那么no1.c中最开始有个#include \"no2.c\"他表示把第二个文件的内容给包含过来，那么no1.c中调用add()函数的时候就可以了把数值传到no2.c中的被调用函数add()了。 一个文件必须要有main函数。这句话错了。例如：no2.c就没有。 头文件一定是以.h结束的。这句话错了。例如：no1.c中就是#include”no2.c”以.c结尾的。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1037.html":{"url":"books/1037.html","title":"功能设计","keywords":"","body":"高级功能 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1095.html":{"url":"books/1095.html","title":"预处理器","keywords":"","body":"预处理器 C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。 所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令： 指令 描述 #define 定义宏 #include 包含一个源代码文件 #undef 取消已定义的宏 #ifdef 如果宏已经定义，则返回真 #ifndef 如果宏没有定义，则返回真 #if 如果给定条件为真，则编译下面代码 #else #if 的替代方案 #elif 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 #endif 结束一个 #if……#else 条件编译块 #error 当遇到标准错误时，输出错误消息 #pragma 使用标准化方法，向编译器发布特殊的命令到编译器中 预处理器实例 分析下面的实例来理解不同的指令。 #define MAX_ARRAY_LENGTH 20 这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 替换为 20。使用 #define 定义常量来增强可读性。 #include #include \"myheader.h\" 这些指令告诉 CPP 从系统库中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 myheader.h，并添加内容到当前的源文件中。 #undef FILE_SIZE #define FILE_SIZE 42 这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。 #ifndef MESSAGE #define MESSAGE \"You wish!\" #endif 这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。 #ifdef DEBUG /* Your debugging statements here */ #endif 这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 -DDEBUG 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。 预定义宏 ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。 宏 描述 DATE 当前日期，一个以 \"MMM DD YYYY\" 格式表示的字符常量。 TIME 当前时间，一个以 \"HH:MM:SS\" 格式表示的字符常量。 FILE 这会包含当前文件名，一个字符串常量。 LINE 这会包含当前行号，一个十进制常量。 STDC 当编译器以 ANSI 标准编译时，则定义为 1。 让我们来尝试下面的实例： #include main() { printf(\"File :%s\\n\", __FILE__ ); printf(\"Date :%s\\n\", __DATE__ ); printf(\"Time :%s\\n\", __TIME__ ); printf(\"Line :%d\\n\", __LINE__ ); printf(\"ANSI :%d\\n\", __STDC__ ); } 当上面的代码（在文件 test.c 中）被编译和执行时，它会产生下列结果： File :test.c Date :Jun 2 2012 Time :03:36:24 Line :8 ANSI :1 预处理器运算符 C 预处理器提供了下列的运算符来帮助您创建宏： 宏延续运算符（\\） 一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\\）。例如： #define message_for(a, b) \\ printf(#a \" and \" #b \": We love you!\\n\") 字符串常量化运算符（#） 在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如： #include #define message_for(a, b) \\ printf(#a \" and \" #b \": We love you!\\n\") int main(void) { message_for(Carole, Debra); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Carole and Debra: We love you! 标记粘贴运算符（##） 宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如： #include #define tokenpaster(n) printf (\"token\" #n \" = %d\", token##n) int main(void) { int token34 = 40; tokenpaster(34); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： token34 = 40 这是怎么发生的，因为这个实例会从编译器产生下列的实际输出： printf (\"token34 = %d\", token34); 这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运算符（#）和标记粘贴运算符（##）。 defined() 运算符 预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法： #include #if !defined (MESSAGE) #define MESSAGE \"You wish!\" #endif int main(void) { printf(\"Here is the message: %s\\n\", MESSAGE); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Here is the message: You wish! 参数化的宏 CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方： int square(int x) { return x * x; } 我们可以使用宏重写上面的代码，如下： #define square(x) ((x) * (x)) 在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如： #include #define MAX(x,y) ((x) > (y) ? (x) : (y)) int main(void) { printf(\"Max between 20 and 10 is %d\\n\", MAX(10, 20)); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Max between 20 and 10 is 20 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1028.html":{"url":"books/1028.html","title":"输入输出","keywords":"","body":"输入输出 当我们提到输入时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要填充到程序中。 当我们提到输出时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中。 标准文件 C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。 标准文件 文件指针 设备 标准输入 stdin 键盘 标准输出 stdout 屏幕 标准错误 stderr 屏幕 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1029.html":{"url":"books/1029.html","title":"数据输入输出","keywords":"","body":"数据输入输出 文件指针是访问文件的方式，本节将讲解如何从屏幕读取值以及如何把结果输出到屏幕上。 C 语言中的 I/O (输入/输出) 通常使用 printf() 和 scanf() 两个函数。 scanf() 和 printf() 函数 scanf() 函数用于从标准输入（键盘）读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）。 int scanf(const char *format, ...) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。 int printf(const char *format, ...) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出。 format 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。如需了解完整的细节，可以查看这些函数的参考手册。现在让我们通过下面这个简单的实例来加深理解： #include // 执行 printf() 函数需要该库 int main() { printf(\"Hello World!\"); //显示引号中的内容 return 0; } //Hello World! /* 实例解析： - 所有的 C 语言程序都需要包含 main() 函数。 代码从 main() 函数开始执行。 - printf() 用于格式化输出到屏幕。printf() 函数在 \"stdio.h\" 头文件中声明。 - stdio.h 是一个头文件 (标准输入输出头文件) and #include 是一个预处理命令，用来引入头文件。 当编译器遇到 printf() 函数时，如果没有找到 stdio.h 头文件，会发生编译错误。 - return 0; 语句用于表示退出程序。 */ #include int main( ) { char str[100]; int i; printf( \"Enter a value :\"); scanf(\"%s %d\", str, &i); printf( \"\\nYou entered: %s %d \", str, i); printf(\"\\n\"); return 0; } /* 当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取输入，显示如下： $./a.out Enter a value :runoob 123 You entered: runoob 123 在这里，应当指出的是，scanf() 期待输入的格式与给出的 %s 和 %d 相同，这意味着必须提供有效的输入，比如 \"string integer\"，如果您提供的是 \"string string\" 或 \"integer integer\"，它会被认为是错误的输入。另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 \"this is test\" 对 scanf() 来说是三个字符串。 */ 格式化输入输出 //%d 格式化输出整数 #include int main() { int testInteger = 5; printf(\"Number = %d\", testInteger); return 0; } //Number = 5 //在 printf() 函数的引号中使用 \"%d\" (整型) 来匹配整型变量 testInteger 并输出到屏幕。 //%f 格式化输出浮点型数据 #include int main() { float f; printf(\"Enter a number: \"); // %f 匹配浮点型数据 scanf(\"%f\",&f); printf(\"Value = %f\", f); return 0; } getchar() & putchar() 函数 int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。可以在循环内使用这个方法，以便从屏幕上读取多个字符。 int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。可以在循环内使用这个方法，以便在屏幕上输出多个字符。 #include int main( ) { int c; printf( \"Enter a value :\"); c = getchar( ); printf( \"\\nYou entered: \"); putchar( c ); printf( \"\\n\"); return 0; } /* 当上面的代码被编译和执行时，它会等待输入一些文本，当输入一个文本并按下回车键时，程序会继续并只会读取一个单一的字符，显示如下： $./a.out Enter a value :runoob You entered: r */ gets() & puts() 函数 char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。 int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。 #include int main( ) { char str[100]; printf( \"Enter a value :\"); gets( str ); printf( \"\\nYou entered: \"); puts( str ); return 0; } /* 当上面的代码被编译和执行时，它会等待输入一些文本，当输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下： $./a.out Enter a value :runoob You entered: runoob */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1030.html":{"url":"books/1030.html","title":"文件输入输出","keywords":"","body":"文件输入输出 上一章我们讲解了 C 语言处理的标准输入和输出设备。本章我们将介绍 C 程序员如何创建、打开、关闭文本文件或二进制文件。 一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。本章将讲解文件管理的重要调用。 打开文件 可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型： FILE *fopen( const char * filename, const char * mode ); 在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个： 模式 描述 r 打开一个已有的文本文件，允许读取文件。 w 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。 a 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。 r+ 打开一个文本文件，允许读写文件。 w+ 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。 a+ 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式： \"rb\", \"wb\", \"ab\", \"rb+\", \"r+b\", \"wb+\", \"w+b\", \"ab+\", \"a+b\" 关闭文件 为了关闭文件，请使用 fclose( ) 函数。函数的原型如下： int fclose( FILE *fp ); 如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。 C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。 写入文件 下面是把字符写入到流中的最简单的函数： int fputc( int c, FILE *fp ); 函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中： int fputs( const char *s, FILE *fp ); 函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您也可以使用 int fprintf(FILE *fp,const char *format, ...) 函数来写把一个字符串写入到文件中。尝试下面的实例： 注意：请确保您有可用的 tmp 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。 /tmp 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: C:\\tmp、D:\\tmp等。 #include int main() { FILE *fp = NULL; fp = fopen(\"/tmp/test.txt\", \"w+\"); fprintf(fp, \"This is testing for fprintf...\\n\"); fputs(\"This is testing for fputs...\\n\", fp); fclose(fp); } 当上面的代码被编译和执行时，它会在 /tmp 目录中创建一个新的文件 test.txt，并使用两个不同的函数写入两行。接下来让我们来读取这个文件。 读取文件 下面是从文件读取单个字符的最简单的函数： int fgetc( FILE * fp ); fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。下面的函数允许您从流中读取一个字符串： char *fgets( char *buf, int n, FILE *fp ); 函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。 如果这个函数在读取最后一个字符之前就遇到一个换行符 '\\n' 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 int fscanf(FILE *fp, const char *format, ...) 函数来从文件中读取字符串，但是在遇到第一个空格字符时，它会停止读取。 #include int main() { FILE *fp = NULL; char buff[255]; fp = fopen(\"/tmp/test.txt\", \"r\"); fscanf(fp, \"%s\", buff); printf(\"1: %s\\n\", buff ); fgets(buff, 255, (FILE*)fp); printf(\"2: %s\\n\", buff ); fgets(buff, 255, (FILE*)fp); printf(\"3: %s\\n\", buff ); fclose(fp); } /* 1: This 2: is testing for fprintf... 3: This is testing for fputs... 首先，fscanf() 方法只读取了 This，因为它在后边遇到了一个空格。其次，调用 fgets() 读取剩余的部分，直到行尾。最后，调用 fgets() 完整地读取第二行。 */ 二进制 I/O 函数 下面两个函数用于二进制输入和输出： size_t fread(void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file); size_t fwrite(const void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file); 这两个函数都是用于存储块的读写 - 通常是数组或结构体。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1099.html":{"url":"books/1099.html","title":"错误处理","keywords":"","body":"错误处理 C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。 所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。 errno、perror() 和 strerror() C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。 perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。 strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。 让我们来模拟一种错误情况，尝试打开一个不存在的文件。可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，应该使用 stderr 文件流来输出所有的错误。 #include #include #include extern int errno ; int main () { FILE * pf; int errnum; pf = fopen (\"unexist.txt\", \"rb\"); if (pf == NULL) { errnum = errno; fprintf(stderr, \"错误号: %d\\n\", errno); perror(\"通过 perror 输出错误\"); fprintf(stderr, \"打开文件错误: %s\\n\", strerror( errnum )); } else { fclose (pf); } return 0; } /* 错误号: 2 通过 perror 输出错误: No such file or directory 打开文件错误: No such file or directory */ 被零除的错误 在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误。 为了避免这种情况发生，下面的代码在进行除法运算前会先检查除数是否为零： #include #include main() { int dividend = 20; int divisor = 0; int quotient; if( divisor == 0){ fprintf(stderr, \"除数为 0 退出运行...\\n\"); exit(-1); } quotient = dividend / divisor; fprintf(stderr, \"quotient 变量的值为 : %d\\n\", quotient ); exit(0); } //除数为 0 退出运行... 程序退出状态 通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。 如果程序中存在一种错误情况，当退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。所以，上面的程序可以写成： #include #include main() { int dividend = 20; int divisor = 5; int quotient; if( divisor == 0){ fprintf(stderr, \"除数为 0 退出运行...\\n\"); exit(EXIT_FAILURE); } quotient = dividend / divisor; fprintf(stderr, \"quotient 变量的值为: %d\\n\", quotient ); exit(EXIT_SUCCESS); } //quotient 变量的值为 : 4 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1100.html":{"url":"books/1100.html","title":"内存管理","keywords":"","body":"内存管理 本章将讲解 C 中的动态内存管理。C 语言为内存的分配和管理提供了几个函数。这些函数可以在 头文件中找到。 序号 函数和描述 1 void *calloc(int num, int size); 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。 2 void free(void *address); 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。 3 void *malloc(int num); 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。 4 void *realloc(void *address, int newsize); 该函数重新分配内存，把内存扩展到 newsize。 注意：void 类型表示未确定类型的指针。C、C++ 规定 void 类型可以通过类型转换强制转换为任何其它类型的指针。 动态分配内存 编程时，如果您预先知道数组的大小，那么定义数组时就比较容易。例如，一个存储人名的数组，它最多容纳 100 个字符，所以您可以定义数组，如下所示： char name[100]; 但是，如果预先不知道需要存储的文本长度，例如向存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示： #include #include #include int main() { char name[100]; char *description; strcpy(name, \"Zara Ali\"); /* 动态分配内存 */ description = (char *)malloc( 200 * sizeof(char) ); if( description == NULL ) { fprintf(stderr, \"Error - unable to allocate required memory\\n\"); } else { strcpy( description, \"Zara ali a DPS student in class 10th\"); } printf(\"Name = %s\\n\", name ); printf(\"Description: %s\\n\", description ); } //Name = Zara Ali //Description: Zara ali a DPS student in class 10th 上面的程序也可以使用 calloc() 来编写，只需要把 malloc 替换为 calloc 即可，如下所示： calloc(200, sizeof(char)); 当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。 重新调整内存的大小和释放内存 当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 free() 来释放内存。 或者，可以通过调用函数 realloc() 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例： #include #include #include int main() { char name[100]; char *description; strcpy(name, \"Zara Ali\"); /* 动态分配内存 */ description = (char *)malloc( 30 * sizeof(char) ); if( description == NULL ) { fprintf(stderr, \"Error - unable to allocate required memory\\n\"); } else { strcpy( description, \"Zara ali a DPS student.\"); } /* 假设您想要存储更大的描述信息 */ description = (char *) realloc( description, 100 * sizeof(char) ); if( description == NULL ) { fprintf(stderr, \"Error - unable to allocate required memory\\n\"); } else { strcat( description, \"She is in class 10th\"); } printf(\"Name = %s\\n\", name ); printf(\"Description: %s\\n\", description ); /* 使用 free() 函数释放内存 */ free(description); } //Name = Zara Ali //Description: Zara ali a DPS student.She is in class 10th 可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1097.html":{"url":"books/1097.html","title":"C标准库","keywords":"","body":"C标准库 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/":{"url":"include/","title":"简介","keywords":"","body":"简介 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/assert.h/":{"url":"include/assert.h/","title":"assert.h","keywords":"","body":"assert.h C 标准库 - 简介 C 标准库的 assert.h头文件提供了一个名为 assert 的宏，它可用于验证程序做出的假设，并在假设为假时输出诊断消息。 已定义的宏 assert 指向另一个宏 NDEBUG，宏 NDEBUG 不是 的一部分。如果已在引用 的源文件中定义 NDEBUG 为宏名称，则 assert 宏的定义如下： #define assert(ignore) ((void)0) 库宏 下面列出了头文件 assert.h 中定义的唯一的函数： 序号 函数 & 描述 1 void assert(int expression) 这实际上是一个宏，不是一个函数，可用于在 C 程序中添加诊断。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/assert.h/assert.html":{"url":"include/assert.h/assert.html","title":"void assert(int expression)","keywords":"","body":"void assert(int expression) 描述 C 库宏 void assert(int expression) 允许诊断信息被写入到标准错误文件中。换句话说，它可用于在 C 程序中添加诊断。 声明 下面是 assert() 宏的声明。 void assert(int expression); 参数 expression -- 这可以是一个变量或任何 C 表达式。如果 expression 为 TRUE，assert() 不执行任何动作。如果 expression为 FALSE，assert() 会在标准错误 stderr 上显示错误消息，并中止程序执行。 返回值 这个宏不返回任何值。 实例 下面的实例演示了 assert() 宏的用法。 #include #include int main() { int a; char str[50]; printf(\"请输入一个整数值： \"); scanf(\"%d\", &a); assert(a >= 10); printf(\"输入的整数是： %d\\n\", a); printf(\"请输入字符串： \"); scanf(\"%s\", str); assert(str != NULL); printf(\"输入的字符串是： %s\\n\", str); return(0); } /* 请输入一个整数值： 11 输入的整数是： 11 请输入字符串： runoob 输入的字符串是： runoob */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/ctype.h/":{"url":"include/ctype.h/","title":"ctype.h","keywords":"","body":"ctype.h C 标准库 - 简介 C 标准库的 ctype.h 头文件提供了一些函数，可用于测试和映射字符。 这些函数接受 int 作为参数，它的值必须是 EOF 或表示为一个无符号字符。 如果参数 c 满足描述的条件，则这些函数返回非零（true）。如果参数 c 不满足描述的条件，则这些函数返回零。 库函数 下面列出了头文件 ctype.h 中定义的函数： 序号 函数 & 描述 1 int isalnum(int c) 该函数检查所传的字符是否是字母和数字。 2 int isalpha(int c) 该函数检查所传的字符是否是字母。 3 int iscntrl(int c) 该函数检查所传的字符是否是控制字符。 4 int isdigit(int c) 该函数检查所传的字符是否是十进制数字。 5 int isgraph(int c) 该函数检查所传的字符是否有图形表示法。 6 int islower(int c) 该函数检查所传的字符是否是小写字母。 7 int isprint(int c) 该函数检查所传的字符是否是可打印的。 8 int ispunct(int c) 该函数检查所传的字符是否是标点符号字符。 9 int isspace(int c) 该函数检查所传的字符是否是空白字符。 10 int isupper(int c) 该函数检查所传的字符是否是大写字母。 11 int isxdigit(int c) 该函数检查所传的字符是否是十六进制数字。 标准库还包含了两个转换函数，它们接受并返回一个 \"int\" 序号 函数 & 描述 1 int tolower(int c) 该函数把大写字母转换为小写字母。 2 int toupper(int c) 该函数把小写字母转换为大写字母。 字符类 序号 字符类 & 描述 1 数字 完整的数字集合 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } 2 十六进制数字 集合 { 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f } 3 小写字母 集合 { a b c d e f g h i j k l m n o p q r s t u v w x y z } 4 大写字母 集合 {A B C D E F G H I J K L M N O P Q R S T U V W X Y Z } 5 字母 小写字母和大写字母的集合 6 字母数字字符 数字、小写字母和大写字母的集合 7 标点符号字符 集合 ! \" # $ % & ' ( ) * + , - . / : ; ? @ [ \\ ] ^ _ ` { \\ } ~ 8 图形字符 字母数字字符和标点符号字符的集合 9 空格字符 制表符、换行符、垂直制表符、换页符、回车符、空格符的集合。 10 可打印字符 字母数字字符、标点符号字符和空格字符的集合。 11 控制字符 在 ASCII 编码中，这些字符的八进制代码是从 000 到 037，以及 177（DEL）。 12 空白字符 包括空格符和制表符。 13 字母字符 小写字母和大写字母的集合。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/ctype.h/isalnum.html":{"url":"include/ctype.h/isalnum.html","title":"int isalnum(int c)","keywords":"","body":"int isalnum(int c) 描述 C 库函数 void isalnum(int c) 检查所传的字符是否是字母和数字。 声明 下面是 isalnum() 函数的声明。 int isalnum(int c); 参数 c -- 这是要检查的字符。 返回值 如果 c 是一个数字或一个字母，则该函数返回非零值，否则返回 0。 实例 下面的实例演示了 isalnum() 函数的用法。 #include #include int main() { int var1 = 'd'; int var2 = '2'; int var3 = '\\t'; int var4 = ' '; if( isalnum(var1) ) { printf(\"var1 = |%c| 是字母数字\\n\", var1 ); } else { printf(\"var1 = |%c| 不是字母数字\\n\", var1 ); } if( isalnum(var2) ) { printf(\"var2 = |%c| 是字母数字\\n\", var2 ); } else { printf(\"var2 = |%c| 不是字母数字\\n\", var2 ); } if( isalnum(var3) ) { printf(\"var3 = |%c| 是字母数字\\n\", var3 ); } else { printf(\"var3 = |%c| 不是字母数字\\n\", var3 ); } if( isalnum(var4) ) { printf(\"var4 = |%c| 是字母数字\\n\", var4 ); } else { printf(\"var4 = |%c| 不是字母数字\\n\", var4 ); } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： var1 = |d| 是字母数字 var2 = |2| 是字母数字 var3 = | | 不是字母数字 var4 = | | 不是字母数字 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/ctype.h/isalpha.html":{"url":"include/ctype.h/isalpha.html","title":"int isalpha(int c)","keywords":"","body":"int isalpha(int c) 描述 C 库函数 void isalpha(int c) 检查所传的字符是否是字母。 声明 下面是 isalpha() 函数的声明。 int isalpha(int c); 参数 c -- 这是要检查的字符。 返回值 如果 c 是一个字母，则该函数返回非零值，否则返回 0。 实例 下面的实例演示了 isalpha() 函数的用法。 #include #include int main() { int var1 = 'd'; int var2 = '2'; int var3 = '\\t'; int var4 = ' '; if( isalpha(var1) ) { printf(\"var1 = |%c| 是一个字母\\n\", var1 ); } else { printf(\"var1 = |%c| 不是一个字母\\n\", var1 ); } if( isalpha(var2) ) { printf(\"var2 = |%c| 是一个字母\\n\", var2 ); } else { printf(\"var2 = |%c| 不是一个字母\\n\", var2 ); } if( isalpha(var3) ) { printf(\"var3 = |%c| 是一个字母\\n\", var3 ); } else { printf(\"var3 = |%c| 不是一个字母\\n\", var3 ); } if( isalpha(var4) ) { printf(\"var4 = |%c| 是一个字母\\n\", var4 ); } else { printf(\"var4 = |%c| 不是一个字母\\n\", var4 ); } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： var1 = |d| 是一个字母 var2 = |2| 不是一个字母 var3 = | | 不是一个字母 var4 = | | 不是一个字母 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/ctype.h/iscntrl.html":{"url":"include/ctype.h/iscntrl.html","title":"int iscntrl(int c)","keywords":"","body":"int iscntrl(int c) 描述 C 库函数 void iscntrl(int c) 检查所传的字符是否是控制字符。 根据标准 ASCII 字符集，控制字符的 ASCII 编码介于 0x00 (NUL) 和 0x1f (US) 之间，以及 0x7f (DEL)，某些平台的特定编译器实现还可以在扩展字符集（0x7f 以上）中定义额外的控制字符。 声明 下面是 iscntrl() 函数的声明。 int iscntrl(int c); 参数 c -- 这是要检查的字符。 返回值 如果 c 是一个控制字符，则该函数返回非零值，否则返回 0。 实例 下面的实例演示了 iscntrl() 函数的用法。 #include #include int main () { int i = 0, j = 0; char str1[] = \"all \\a about \\t programming\"; char str2[] = \"Runoob \\n tutorials\"; /* 输出字符串直到控制字符 \\a */ while( !iscntrl(str1[i]) ) { putchar(str1[i]); i++; } /* 输出字符串直到控制字符 \\n */ while( !iscntrl(str2[j]) ) { putchar(str2[j]); j++; } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： all Runoob 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/ctype.h/isdigit.html":{"url":"include/ctype.h/isdigit.html","title":"int isdigit(int c)","keywords":"","body":"int isdigit(int c) 描述 C 库函数 void isdigit(int c) 检查所传的字符是否是十进制数字字符。 十进制数字是：0 1 2 3 4 5 6 7 8 9 声明 下面是 isdigit() 函数的声明。 int isdigit(int c); 参数 c -- 这是要检查的字符。 返回值 如果 c 是一个数字，则该函数返回非零值，否则返回 0。 实例 下面的实例演示了 isdigit() 函数的用法。 #include #include int main() { int var1 = 'h'; int var2 = '2'; if( isdigit(var1) ) { printf(\"var1 = |%c| 是一个数字\\n\", var1 ); } else { printf(\"var1 = |%c| 不是一个数字\\n\", var1 ); } if( isdigit(var2) ) { printf(\"var2 = |%c| 是一个数字\\n\", var2 ); } else { printf(\"var2 = |%c| 不是一个数字\\n\", var2 ); } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： var1 = |h| 不是一个数字 var2 = |2| 是一个数字 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/ctype.h/isgraph.html":{"url":"include/ctype.h/isgraph.html","title":"int isgraph(int c)","keywords":"","body":"int isgraph(int c) 描述 C 库函数 int isgraph(int c) 检查所传的字符是否有图形表示法。 带有图形表示法的字符是除了空白字符（比如 ' '）以外的所有可打印的字符。 声明 下面是 isgraph() 函数的声明。 int isgraph(int c); 参数 c -- 这是要检查的字符。 返回值 如果 c 有图形表示法，则该函数返回非零值，否则返回 0。 实例 下面的实例演示了 isgraph() 函数的用法。 #include #include int main() { int var1 = '3'; int var2 = 'm'; int var3 = ' '; if( isgraph(var1) ) { printf(\"var1 = |%c| 是可打印的\\n\", var1 ); } else { printf(\"var1 = |%c| 是不可打印的\\n\", var1 ); } if( isgraph(var2) ) { printf(\"var2 = |%c| 是可打印的\\n\", var2 ); } else { printf(\"var2 = |%c| 是不可打印的\\n\", var2 ); } if( isgraph(var3) ) { printf(\"var3 = |%c| 是可打印的\\n\", var3 ); } else { printf(\"var3 = |%c| 是不可打印的\\n\", var3 ); } return(0); } /* var1 = |3| 是可打印的 var2 = |m| 是可打印的 var3 = | | 是不可打印的 */ 以下实例打印所有图形字符： #include #include int main() { int i; printf(\"C 语言中所有图形字符: \\n\"); for (i=0;i ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/ctype.h/islower.html":{"url":"include/ctype.h/islower.html","title":"int islower(int c)","keywords":"","body":"int islower(int c) 描述 C 库函数 int islower(int c) 检查所传的字符是否是小写字母。 声明 下面是 islower() 函数的声明。 int islower(int c); 参数 c -- 这是要检查的字符。 返回值 如果 c 是一个小写字母，则该函数返回非零值（true），否则返回 0（false）。 实例 下面的实例演示了 islower() 函数的用法。 #include #include int main() { int var1 = 'Q'; int var2 = 'q'; int var3 = '3'; if( islower(var1) ) { printf(\"var1 = |%c| 是小写字母\\n\", var1 ); } else { printf(\"var1 = |%c| 不是小写字母\\n\", var1 ); } if( islower(var2) ) { printf(\"var2 = |%c| 是小写字母\\n\", var2 ); } else { printf(\"var2 = |%c| 不是小写字母\\n\", var2 ); } if( islower(var3) ) { printf(\"var3 = |%c| 是小写字母\\n\", var3 ); } else { printf(\"var3 = |%c| 不是小写字母\\n\", var3 ); } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： var1 = |Q| 不是小写字母 var2 = |q| 是小写字母 var3 = |3| 不是小写字母 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/ctype.h/isprint.html":{"url":"include/ctype.h/isprint.html","title":"int isprint(int c)","keywords":"","body":"int isprint(int c) 描述 C 库函数 int isprint(int c) 检查所传的字符是否是可打印的。可打印字符是非控制字符的字符。 声明 下面是 isprint() 函数的声明。 int isprint(int c); 参数 c -- 这是要检查的字符。 返回值 如果 c 是一个可打印的字符，则该函数返回非零值（true），否则返回 0（false）。 实例 下面的实例演示了 isprint() 函数的用法。 #include #include int main() { int var1 = 'k'; int var2 = '8'; int var3 = '\\t'; int var4 = ' '; if( isprint(var1) ) { printf(\"var1 = |%c| 是可打印的\\n\", var1 ); } else { printf(\"var1 = |%c| 是不可打印的\\n\", var1 ); } if( isprint(var2) ) { printf(\"var2 = |%c| 是可打印的\\n\", var2 ); } else { printf(\"var2 = |%c| 是不可打印的\\n\", var2 ); } if( isprint(var3) ) { printf(\"var3 = |%c| 是可打印的\\n\", var3 ); } else { printf(\"var3 = |%c| 是不可打印的\\n\", var3 ); } if( isprint(var4) ) { printf(\"var4 = |%c| 是可打印的\\n\", var4 ); } else { printf(\"var4 = |%c| 是不可打印的\\n\", var4 ); } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： var1 = |k| 是可打印的 var2 = |8| 是可打印的 var3 = | | 是不可打印的 var4 = | | 是可打印的 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/ctype.h/ispunct.html":{"url":"include/ctype.h/ispunct.html","title":"int ispunct(int c)","keywords":"","body":"int ispunct(int c) 描述 C 库函数 int ispunct(int c) 检查所传的字符是否是标点符号字符。标点符号字符可以是非字母数字（正如 isalnum 中的一样）的任意图形字符（正如 isgraph 中的一样）。 声明 下面是 ispunct() 函数的声明。 int ispunct(int c); 参数 c -- 这是要检查的字符。 返回值 如果 c 是一个标点符号字符，则该函数返回非零值（true），否则返回 0（false）。 实例 下面的实例演示了 ispunct() 函数的用法。 #include #include int main() { int var1 = 't'; int var2 = '1'; int var3 = '/'; int var4 = ' '; if( ispunct(var1) ) { printf(\"var1 = |%c| 是标点符号字符\\n\", var1 ); } else { printf(\"var1 = |%c| 不是标点符号字符\\n\", var1 ); } if( ispunct(var2) ) { printf(\"var2 = |%c| 是标点符号字符\\n\", var2 ); } else { printf(\"var2 = |%c| 不是标点符号字符\\n\", var2 ); } if( ispunct(var3) ) { printf(\"var3 = |%c| 是标点符号字符\\n\", var3 ); } else { printf(\"var3 = |%c| 不是标点符号字符\\n\", var3 ); } if( ispunct(var4) ) { printf(\"var4 = |%c| 是标点符号字符\\n\", var4 ); } else { printf(\"var4 = |%c| 不是标点符号字符\\n\", var4 ); } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： var1 = |t| 不是标点符号字符 var2 = |1| 不是标点符号字符 var3 = |/| 是标点符号字符 var4 = | | 不是标点符号字符 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/ctype.h/isspace.html":{"url":"include/ctype.h/isspace.html","title":"int isspace(int c)","keywords":"","body":"int isspace(int c) 描述 C 库函数 int isspace(int c) 检查所传的字符是否是空白字符。 标准的空白字符包括： ' ' (0x20) space (SPC) 空格符 '\\t' (0x09) horizontal tab (TAB) 水平制表符 '\\n' (0x0a) newline (LF) 换行符 '\\v' (0x0b) vertical tab (VT) 垂直制表符 '\\f' (0x0c) feed (FF) 换页符 '\\r' (0x0d) carriage return (CR) 回车符 声明 下面是 isspace() 函数的声明。 int isspace(int c); 参数 c -- 这是要检查的字符。 返回值 如果 c 是一个空白字符，则该函数返回非零值（true），否则返回 0（false）。 实例 下面的实例演示了 isspace() 函数的用法。 #include #include int main() { int var1 = 't'; int var2 = '1'; int var3 = ' '; if( isspace(var1) ) { printf(\"var1 = |%c| 是空白字符\\n\", var1 ); } else { printf(\"var1 = |%c| 不是空白字符\\n\", var1 ); } if( isspace(var2) ) { printf(\"var2 = |%c| 是空白字符\\n\", var2 ); } else { printf(\"var2 = |%c| 不是空白字符\\n\", var2 ); } if( isspace(var3) ) { printf(\"var3 = |%c| 是空白字符\\n\", var3 ); } else { printf(\"var3 = |%c| 不是空白字符\\n\", var3 ); } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： var1 = |t| 不是空白字符 var2 = |1| 不是空白字符 var3 = | | 是空白字符 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/ctype.h/isupper.html":{"url":"include/ctype.h/isupper.html","title":"int isupper(int c)","keywords":"","body":"int isupper(int c) 描述 C 库函数 int isupper(int c) 检查所传的字符是否是大写字母。 声明 下面是 isupper() 函数的声明。 int isupper(int c); 参数 c -- 这是要检查的字符。 返回值 如果 c 是一个大写字母，则该函数返回非零值（true），否则返回 0（false）。 实例 下面的实例演示了 isupper() 函数的用法。 #include #include int main() { int var1 = 'M'; int var2 = 'm'; int var3 = '3'; if( isupper(var1) ) { printf(\"var1 = |%c| 是大写字母\\n\", var1 ); } else { printf(\"var1 = |%c| 不是大写字母\\n\", var1 ); } if( isupper(var2) ) { printf(\"var2 = |%c| 是大写字母\\n\", var2 ); } else { printf(\"var2 = |%c| 不是大写字母\\n\", var2 ); } if( isupper(var3) ) { printf(\"var3 = |%c| 是大写字母\\n\", var3 ); } else { printf(\"var3 = |%c| 不是大写字母\\n\", var3 ); } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： var1 = |M| 是大写字母 var2 = |m| 不是大写字母 var3 = |3| 不是大写字母 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/ctype.h/isxdigit.html":{"url":"include/ctype.h/isxdigit.html","title":"int isxdigit(int c)","keywords":"","body":"int isxdigit(int c) 描述 C 库函数 int isxdigit(int c)检查所传的字符是否是十六进制数字。 十六进制一般用数字 0 到 9 和字母 A 到 F（或 a~f）表示，其中 A~F 表示 10~15: 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F。 声明 下面是 isxdigit() 函数的声明。 int isxdigit(int c); 参数 c -- 这是要检查的字符。 返回值 如果 c 是一个十六进制数字，则该函数返回非零值（true），否则返回 0（false）。 实例 下面的实例演示了 isxdigit() 函数的用法。 #include #include int main() { char var1[] = \"tuts\"; char var2[] = \"0xE\"; if( isxdigit(var1[0]) ) { printf(\"var1 = |%s| 是十六进制数字\\n\", var1 ); } else { printf(\"var1 = |%s| 不是十六进制数字\\n\", var1 ); } if( isxdigit(var2[0] )) { printf(\"var2 = |%s| 是十六进制数字\\n\", var2 ); } else { printf(\"var2 = |%s| 不是十六进制数字\\n\", var2 ); } return(0); } /* var1 = |tuts| 不是十六进制数字 var2 = |0xE| 是十六进制数字 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/ctype.h/tolower.html":{"url":"include/ctype.h/tolower.html","title":"int tolower(int c)","keywords":"","body":"int tolower(int c) 描述 C 库函数 int tolower(int c) 把给定的字母转换为小写字母。 声明 下面是 tolower() 函数的声明。 int tolower(int c); 参数 c -- 这是要被转换为小写的字母。 返回值 如果 c 有相对应的小写字母，则该函数返回 c 的小写字母，否则 c 保持不变。返回值是一个可被隐式转换为 char 类型的 int 值。 实例 下面的实例演示了 tolower() 函数的用法。 #include #include int main() { int i = 0; char c; char str[] = \"RUNOOB\"; while( str[i] ) { putchar(tolower(str[i])); i++; } return(0); } /* runoob */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/ctype.h/toupper.html":{"url":"include/ctype.h/toupper.html","title":"int toupper(int c)","keywords":"","body":"int toupper(int c) 描述 C 库函数 int toupper(int c) 把小写字母转换为大写字母。 声明 下面是 toupper() 函数的声明。 int toupper(int c); 参数 c -- 这是要被转换为大写的字母。 返回值 如果 c 有相对应的大写字母，则该函数返回 c 的大写字母，否则 c 保持不变。返回值是一个可被隐式转换为 char 类型的 int 值。 实例 下面的实例演示了 toupper() 函数的用法。 #include #include int main() { int i = 0; char c; char str[] = \"runoob\"; while(str[i]) { putchar (toupper(str[i])); i++; } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： RUNOOB 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/errno.h/":{"url":"include/errno.h/","title":"errno.h","keywords":"","body":"errno.h C 标准库 - 简介 C 标准库的 errno.h 头文件定义了整数变量 errno，它是通过系统调用设置的，在错误事件中的某些库函数表明了什么发生了错误。该宏扩展为类型为 int 的可更改的左值，因此它可以被一个程序读取和修改。 在程序启动时，errno 设置为零，C 标准库中的特定函数修改它的值为一些非零值以表示某些类型的错误。您也可以在适当的时候修改它的值或重置为零。 errno.h 头文件定义了一系列表示不同错误代码的宏，这些宏应扩展为类型为 int 的整数常量表达式。 库宏 下面列出了头文件 errno.h 中定义的宏： 序号 宏 & 描述 1 extern int errno 这是通过系统调用设置的宏，在错误事件中的某些库函数表明了什么发生了错误。 2 EDOM Domain Error 这个宏表示一个域错误，它在输入参数超出数学函数定义的域时发生，errno 被设置为 EDOM。 3 ERANGE Range Error 这个宏表示一个范围错误，它在输入参数超出数学函数定义的范围时发生，errno 被设置为 ERANGE。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/errno.h/extern_int_errno.html":{"url":"include/errno.h/extern_int_errno.html","title":"extern int errno","keywords":"","body":"extern int errno 描述 C 库宏 extern int errno 是通过系统调用设置的，在错误事件中的某些库函数表明了什么发生了错误。 声明 下面是 errno 宏的声明。 extern int errno 参数 NA 返回值 NA 实例 下面的实例演示了 errno 宏的用法。 #include #include #include extern int errno ; int main () { FILE *fp; fp = fopen(\"file.txt\", \"r\"); if( fp == NULL ) { fprintf(stderr, \"Value of errno: %d\\n\", errno); fprintf(stderr, \"Error opening file: %s\\n\", strerror(errno)); } else { fclose(fp); } return(0); } /* 让我们编译并运行上面的程序，当文件 file.txt 不存在时，将产生以下结果： Value of errno: 2 Error opening file: No such file or directory */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/errno.h/EDOM_Domain_Error.html":{"url":"include/errno.h/EDOM_Domain_Error.html","title":"EDOM Domain Error","keywords":"","body":"EDOM Domain Error 描述 C 库宏 EDOM 表示一个域错误，它在输入参数超出数学函数定义的域时发生，errno 被设置为 EDOM。 声明 下面是 EDOM 宏的声明。 #define EDOM some_value 参数 NA 返回值 NA 实例 下面的实例演示了 EDOM 宏的用法。 #include #include #include int main() { double val; errno = 0; val = sqrt(-10); if(errno == EDOM) { printf(\"Invalid value \\n\"); } else { printf(\"Valid value\\n\"); } errno = 0; val = sqrt(10); if(errno == EDOM) { printf(\"Invalid value\\n\"); } else { printf(\"Valid value\\n\"); } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： Invalid value Valid value 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/errno.h/ERANGE_Range_Error.html":{"url":"include/errno.h/ERANGE_Range_Error.html","title":"ERANGE Range Error","keywords":"","body":"ERANGE Range Error 描述 C 库宏 ERANGE 表示一个范围错误，它在输入参数超出数学函数定义的范围时发生，errno 被设置为 ERANGE。 声明 下面是 ERANGE 宏的声明。 #define ERANGE some_value 参数 NA 返回值 NA 实例 下面的实例演示了 ERANGE 宏的用法。 #include #include #include int main() { double x; double value; x = 2.000000; value = log(x); if( errno == ERANGE ) { printf(\"Log(%f) is out of range\\n\", x); } else { printf(\"Log(%f) = %f\\n\", x, value); } x = 1.000000; value = log(x); if( errno == ERANGE ) { printf(\"Log(%f) is out of range\\n\", x); } else { printf(\"Log(%f) = %f\\n\", x, value); } x = 0.000000; value = log(x); if( errno == ERANGE ) { printf(\"Log(%f) is out of range\\n\", x); } else { printf(\"Log(%f) = %f\\n\", x, value); } return 0; } /* Log(2.000000) = 0.693147 Log(1.000000) = 0.000000 Log(0.000000) = -inf */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/float.h/":{"url":"include/float.h/","title":"float.h","keywords":"","body":"float.h C 标准库 - 简介 C 标准库的 float.h 头文件包含了一组与浮点值相关的依赖于平台的常量。这些常量是由 ANSI C 提出的，这让程序更具有可移植性。在讲解这些常量之前，最好先弄清楚浮点数是由下面四个元素组成的： 组件 组件描述 S 符号 ( +/- ) b 指数表示的基数，2 表示二进制，10 表示十进制，16 表示十六进制，等等... e 指数，一个介于最小值 emin 和最大值 emax 之间的整数。 p 精度，基数 b 的有效位数 基于以上 4 个组成部分，一个浮点数的值如下： floating-point = ( S ) p x be 或 floating-point = (+/-) precision x baseexponent 库宏 下面的值是特定实现的，且是通过 #define 指令来定义的，这些值都不得低于下边所给出的值。请注意，所有的实例 FLT 是指类型 float，DBL 是指类型 double，LDBL 是指类型 long double。 宏 描述 FLT_ROUNDS 定义浮点加法的舍入模式，它可以是下列任何一个值：-1 - 无法确定0 - 趋向于零1 - 去最近的值2 - 趋向于正无穷3 - 趋向于负无穷 FLT_RADIX 2 这个宏定义了指数表示的基数。基数 2 表示二进制，基数 10 表示十进制，基数 16 表示十六进制。 FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG 这些宏定义了 FLT_RADIX 基数中的位数。 FLT_DIG 6DBL_DIG 10LDBL_DIG 10 这些宏定义了舍入后不会改变表示的十进制数字的最大值（基数 10）。 FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP 这些宏定义了基数为 FLT_RADIX 时的指数的最小负整数值。 FLT_MIN_10_EXP -37DBL_MIN_10_EXP -37LDBL_MIN_10_EXP -37 这些宏定义了基数为 10 时的指数的最小负整数值。 FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP 这些宏定义了基数为 FLT_RADIX 时的指数的最大整数值。 FLT_MAX_10_EXP +37DBL_MAX_10_EXP +37LDBL_MAX_10_EXP +37 这些宏定义了基数为 10 时的指数的最大整数值。 FLT_MAX 1E+37DBL_MAX 1E+37LDBL_MAX 1E+37 这些宏定义最大的有限浮点值。 FLT_EPSILON 1E-5DBL_EPSILON 1E-9LDBL_EPSILON 1E-9 这些宏定义了可表示的最小有效数字。 FLT_MIN 1E-37DBL_MIN 1E-37LDBL_MIN 1E-37 这些宏定义了最小的浮点值。 实例 下面的实例演示了 float.h 文件中定义的一些常量的使用。 #include #include int main() { printf(\"The maximum value of float = %.10e\\n\", FLT_MAX); printf(\"The minimum value of float = %.10e\\n\", FLT_MIN); printf(\"The number of digits in the number = %.10e\\n\", FLT_MANT_DIG); } 让我们编译和运行上面的程序，这将产生下列结果： The maximum value of float = 3.4028234664e+38 The minimum value of float = 1.1754943508e-38 The number of digits in the number = 7.2996655210e-312 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/limits.h/":{"url":"include/limits.h/","title":"limits.h","keywords":"","body":"limits.h C 标准库 - 简介 limits.h 头文件决定了各种变量类型的各种属性。定义在该头文件中的宏限制了各种变量类型（比如 char、int 和 long）的值。 这些限制指定了变量不能存储任何超出这些限制的值，例如一个无符号可以存储的最大值是 255。 库宏 下面的值是特定实现的，且是通过 #define 指令来定义的，这些值都不得低于下边所给出的值。 宏 值 描述 CHAR_BIT 8 定义一个字节的比特数。 SCHAR_MIN -128 定义一个有符号字符的最小值。 SCHAR_MAX 127 定义一个有符号字符的最大值。 UCHAR_MAX 255 定义一个无符号字符的最大值。 CHAR_MIN 0 定义类型 char 的最小值，如果 char 表示负值，则它的值等于 SCHAR_MIN，否则等于 0。 CHAR_MAX 127 定义类型 char 的最大值，如果 char 表示负值，则它的值等于 SCHAR_MAX，否则等于 UCHAR_MAX。 MB_LEN_MAX 1 定义多字节字符中的最大字节数。 SHRT_MIN -32768 定义一个短整型的最小值。 SHRT_MAX +32767 定义一个短整型的最大值。 USHRT_MAX 65535 定义一个无符号短整型的最大值。 INT_MIN -32768 定义一个整型的最小值。 INT_MAX +32767 定义一个整型的最大值。 UINT_MAX 65535 定义一个无符号整型的最大值。 LONG_MIN -2147483648 定义一个长整型的最小值。 LONG_MAX +2147483647 定义一个长整型的最大值。 ULONG_MAX 4294967295 定义一个无符号长整型的最大值。 实例 下面的实例演示了 limit.h 文件中定义的一些常量的使用。 #include #include int main() { printf(\"The number of bits in a byte %d\\n\", CHAR_BIT); printf(\"The minimum value of SIGNED CHAR = %d\\n\", SCHAR_MIN); printf(\"The maximum value of SIGNED CHAR = %d\\n\", SCHAR_MAX); printf(\"The maximum value of UNSIGNED CHAR = %d\\n\", UCHAR_MAX); printf(\"The minimum value of SHORT INT = %d\\n\", SHRT_MIN); printf(\"The maximum value of SHORT INT = %d\\n\", SHRT_MAX); printf(\"The minimum value of INT = %d\\n\", INT_MIN); printf(\"The maximum value of INT = %d\\n\", INT_MAX); printf(\"The minimum value of CHAR = %d\\n\", CHAR_MIN); printf(\"The maximum value of CHAR = %d\\n\", CHAR_MAX); printf(\"The minimum value of LONG = %ld\\n\", LONG_MIN); printf(\"The maximum value of LONG = %ld\\n\", LONG_MAX); return(0); } 让我们编译和运行上面的程序，这将产生下列结果： The number of bits in a byte 8 The minimum value of SIGNED CHAR = -128 The maximum value of SIGNED CHAR = 127 The maximum value of UNSIGNED CHAR = 255 The minimum value of SHORT INT = -32768 The maximum value of SHORT INT = 32767 The minimum value of INT = -32768 The maximum value of INT = 32767 The minimum value of CHAR = -128 The maximum value of CHAR = 127 The minimum value of LONG = -2147483648 The maximum value of LONG = 2147483647 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/locale.h/":{"url":"include/locale.h/","title":"locale.h","keywords":"","body":"locale.h C 标准库 - 简介 locale.h 头文件定义了特定地域的设置，比如日期格式和货币符号。接下来我们将介绍一些宏，以及一个重要的结构 struct lconv和两个重要的函数。 库宏 下面列出了头文件 locale.h 中定义的宏，这些宏将在下列的两个函数中使用： 序号 宏 & 描述 1 LC_ALL 设置下面的所有选项。 2 LC_COLLATE 影响 strcoll 和 strxfrm 函数。 3 LC_CTYPE 影响所有字符函数。 4 LC_MONETARY 影响 localeconv 函数提供的货币信息。 5 LC_NUMERIC 影响 localeconv 函数提供的小数点格式化和信息。 6 LC_TIME 影响 strftime 函数。 库函数 下面列出了头文件 locale.h 中定义的函数： 序号 函数 & 描述 1 char setlocale(int category, const char locale) 设置或读取地域化信息。 2 struct lconv *localeconv(void) 设置或读取地域化信息。 库结构 typedef struct { char *decimal_point; char *thousands_sep; char *grouping; char *int_curr_symbol; char *currency_symbol; char *mon_decimal_point; char *mon_thousands_sep; char *mon_grouping; char *positive_sign; char *negative_sign; char int_frac_digits; char frac_digits; char p_cs_precedes; char p_sep_by_space; char n_cs_precedes; char n_sep_by_space; char p_sign_posn; char n_sign_posn; } lconv 以下是各字段的描述： 序号 字段 & 描述 1 decimal_point 用于非货币值的小数点字符。 2 thousands_sep 用于非货币值的千位分隔符。 3 grouping 一个表示非货币量中每组数字大小的字符串。每个字符代表一个整数值，每个整数指定当前组的位数。值为 0 意味着前一个值将应用于剩余的分组。 4 int_curr_symbol 国际货币符号使用的字符串。前三个字符是由 ISO 4217:1987 指定的，第四个字符用于分隔货币符号和货币量。 5 currency_symbol 用于货币的本地符号。 6 mon_decimal_point 用于货币值的小数点字符。 7 mon_thousands_sep 用于货币值的千位分隔符。 8 mon_grouping 一个表示货币值中每组数字大小的字符串。每个字符代表一个整数值，每个整数指定当前组的位数。值为 0 意味着前一个值将应用于剩余的分组。 9 positive_sign 用于正货币值的字符。 10 negative_sign 用于负货币值的字符。 11 int_frac_digits 国际货币值中小数点后要显示的位数。 12 frac_digits 货币值中小数点后要显示的位数。 13 p_cs_precedes 如果等于 1，则 currency_symbol 出现在正货币值之前。如果等于 0，则 currency_symbol 出现在正货币值之后。 14 p_sep_by_space 如果等于 1，则 currency_symbol 和正货币值之间使用空格分隔。如果等于 0，则 currency_symbol 和正货币值之间不使用空格分隔。 15 n_cs_precedes 如果等于 1，则 currency_symbol 出现在负货币值之前。如果等于 0，则 currency_symbol 出现在负货币值之后。 16 n_sep_by_space 如果等于 1，则 currency_symbol 和负货币值之间使用空格分隔。如果等于 0，则 currency_symbol 和负货币值之间不使用空格分隔。 17 p_sign_posn 表示正货币值中正号的位置。 18 n_sign_posn 表示负货币值中负号的位置。 下面的值用于 p_sign_posn 和 n_sign_posn: 值 描述 0 封装值和 currency_symbol 的括号。 1 放置在值和 currency_symbol 之前的符号。 2 放置在值和 currency_symbol 之后的符号。 3 紧挨着放置在值和 currency_symbol 之前的符号。 4 紧挨着放置在值和 currency_symbol 之后的符号。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/locale.h/*setlocale.html":{"url":"include/locale.h/*setlocale.html","title":"char *setlocale(int category, const char locale)","keywords":"","body":"char *setlocale(int category, const char locale) 描述 C 库函数 char *setlocale(int category, const char *locale) 设置或读取地域化信息。 声明 下面是 setlocale() 函数的声明。 char *setlocale(int category, const char *locale) 参数 category -- 这是一个已命名的常量，指定了受区域设置影响的函数类别。 LC_ALL 包括下面的所有选项。 LC_COLLATE 字符串比较。参见 strcoll()。 LC_CTYPE 字符分类和转换。例如 strtoupper()。 LC_MONETARY 货币格式，针对 localeconv()。 LC_NUMERIC 小数点分隔符，针对 localeconv()。 LC_TIME 日期和时间格式，针对 strftime()。 LC_MESSAGES 系统响应。 locale -- 如果 locale 是 NULL 或空字符串 \"\"，则区域名称将根据环境变量值来设置，其名称与上述的类别名称相同。 返回值 如果成功调用 setlocale()，则返回一个对应于区域设置的不透明的字符串。如果请求无效，则返回值是 NULL。 实例 下面的实例演示了 setlocale() 函数的用法。 #include #include #include int main () { time_t currtime; struct tm *timer; char buffer[80]; time( &currtime ); timer = localtime( &currtime ); printf(\"Locale is: %s\\n\", setlocale(LC_ALL, \"en_GB.UTF-8\")); strftime(buffer,80,\"%c\", timer ); printf(\"Date is: %s\\n\", buffer); printf(\"Locale is: %s\\n\", setlocale(LC_ALL, \"de_DE.UTF-8\")); strftime(buffer,80,\"%c\", timer ); printf(\"Date is: %s\\n\", buffer); return(0); } /* Locale is: en_GB Date is: Thu 23 Aug 2012 06:39:32 MST Locale is: de_DE Date is: Do 23 Aug 2012 06:39:32 MST */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/locale.h/*localeconv.html":{"url":"include/locale.h/*localeconv.html","title":"struct lconv *localeconv(void)","keywords":"","body":"struct lconv *localeconv(void) 描述 C 库函数 struct lconv *localeconv(void) 设置或读取地域化信息。它会返回一个 lconv 结构类型的对象。 声明 下面是 localeconv() 函数的声明。 struct lconv *localeconv(void) 参数 NA 返回值 该函数返回一个指向当前区域 struct lconv 的指针，它的结构如下： typedef struct { char *decimal_point; char *thousands_sep; char *grouping; char *int_curr_symbol; char *currency_symbol; char *mon_decimal_point; char *mon_thousands_sep; char *mon_grouping; char *positive_sign; char *negative_sign; char int_frac_digits; char frac_digits; char p_cs_precedes; char p_sep_by_space; char n_cs_precedes; char n_sep_by_space; char p_sign_posn; char n_sign_posn; } lconv 实例 下面的实例演示了 localeconv() 函数的用法。 #include #include int main () { struct lconv * lc; setlocale(LC_MONETARY, \"it_IT\"); lc = localeconv(); printf(\"Local Currency Symbol: %s\\n\",lc->currency_symbol); printf(\"International Currency Symbol: %s\\n\",lc->int_curr_symbol); setlocale(LC_MONETARY, \"en_US\"); lc = localeconv(); printf(\"Local Currency Symbol: %s\\n\",lc->currency_symbol); printf(\"International Currency Symbol: %s\\n\",lc->int_curr_symbol); setlocale(LC_MONETARY, \"en_GB\"); lc = localeconv(); printf (\"Local Currency Symbol: %s\\n\",lc->currency_symbol); printf (\"International Currency Symbol: %s\\n\",lc->int_curr_symbol); printf(\"Decimal Point = %s\\n\", lc->decimal_point); return 0; } 让我们编译并运行上面的程序，这将产生以下结果： Local Currency Symbol: EUR International Currency Symbol: EUR Local Currency Symbol: $ International Currency Symbol: USD Local Currency Symbol: £ International Currency Symbol: GBP Decimal Point = . 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/":{"url":"include/math.h/","title":"math.h","keywords":"","body":"math.h C 标准库 - 简介 math.h 头文件定义了各种数学函数和一个宏。在这个库中所有可用的功能都带有一个 double 类型的参数，且都返回 double 类型的结果。 库宏 下面是这个库中定义的唯一的一个宏： 序号 宏 & 描述 1 HUGE_VAL 当函数的结果不可以表示为浮点数时。如果是因为结果的幅度太大以致于无法表示，则函数会设置 errno 为 ERANGE 来表示范围错误，并返回一个由宏 HUGE_VAL 或者它的否定（- HUGE_VAL）命名的一个特定的很大的值。如果结果的幅度太小，则会返回零值。在这种情况下，error 可能会被设置为 ERANGE，也有可能不会被设置为 ERANGE。 库函数 下面列出了头文件 math.h 中定义的函数： 序号 函数 & 描述 1 double acos(double x) 返回以弧度表示的 x 的反余弦。 2 double asin(double x) 返回以弧度表示的 x 的反正弦。 3 double atan(double x) 返回以弧度表示的 x 的反正切。 4 double atan2(double y, double x) 返回以弧度表示的 y/x 的反正切。y 和 x 的值的符号决定了正确的象限。 5 double cos(double x) 返回弧度角 x 的余弦。 6 double cosh(double x) 返回 x 的双曲余弦。 7 double sin(double x) 返回弧度角 x 的正弦。 8 double sinh(double x) 返回 x 的双曲正弦。 9 double tanh(double x) 返回 x 的双曲正切。 10 double exp(double x) 返回 e 的 x 次幂的值。 11 double frexp(double x, int *exponent) 把浮点数 x 分解成尾数和指数。返回值是尾数，并将指数存入 exponent 中。所得的值是 x = mantissa * 2 ^ exponent。 12 double ldexp(double x, int exponent) 返回 x 乘以 2 的 exponent 次幂。 13 double log(double x) 返回 x 的自然对数（基数为 e 的对数）。 14 double log10(double x) 返回 x 的常用对数（基数为 10 的对数）。 15 double modf(double x, double *integer) 返回值为小数部分（小数点后的部分），并设置 integer 为整数部分。 16 double pow(double x, double y) 返回 x 的 y 次幂。 17 double sqrt(double x) 返回 x 的平方根。 18 double ceil(double x) 返回大于或等于 x 的最小的整数值。 19 double fabs(double x) 返回 x 的绝对值。 20 double floor(double x) 返回小于或等于 x 的最大的整数值。 21 double fmod(double x, double y) 返回 x 除以 y 的余数。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/acos.html":{"url":"include/math.h/acos.html","title":"double acos(double x)","keywords":"","body":"double acos(double x) 描述 C 库函数 double acos(double x) 返回以弧度表示的 x 的反余弦。 声明 下面是 acos() 函数的声明。 double acos(double x) 参数 x -- 介于 [-1,+1] 区间的浮点值。 返回值 该函数返回以弧度表示的 x 的反余弦，弧度区间为 [0, pi]。 实例 下面的实例演示了 acos() 函数的用法。 #include #include #define PI 3.14159265 int main () { double x, ret, val; x = 0.9; val = 180.0 / PI; ret = acos(x) * val; printf(\"%lf 的反余弦是 %lf 度\", x, ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 0.900000 的反余弦是 25.855040 度 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/asin.html":{"url":"include/math.h/asin.html","title":"double asin(double x)","keywords":"","body":"double asin(double x) 描述 C 库函数 double asin(double x) 返回以弧度表示的 x 的反正弦。 声明 下面是 asin() 函数的声明。 double asin(double x) 参数 x -- 介于 [-1,+1] 区间的浮点值。 返回值 该函数返回以弧度表示的 x 的反正弦，弧度区间为 [-pi/2,+pi/2]。 实例 下面的实例演示了 asin() 函数的用法。 #include #include #define PI 3.14159265 int main () { double x, ret, val; x = 0.9; val = 180.0 / PI; ret = asin(x) * val; printf(\"%lf 的反正弦是 %lf 度\", x, ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 0.900000 的反正弦是 64.190609 度 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/atan.html":{"url":"include/math.h/atan.html","title":"double atan(double x)","keywords":"","body":"double atan(double x) 描述 C 库函数 double atan(double x) 返回以弧度表示的 x 的反正切。 声明 下面是 atan() 函数的声明。 double atan(double x) 参数 x -- 浮点值。 返回值 该函数返回以弧度表示的 x 的反正切，弧度区间为 [-pi/2,+pi/2]。 实例 下面的实例演示了 atan() 函数的用法。 #include #include #define PI 3.14159265 int main () { double x, ret, val; x = 1.0; val = 180.0 / PI; ret = atan (x) * val; printf(\"%lf 的反正切是 %lf 度\", x, ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 1.000000 的反正切是 45.000000 度 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/atan2.html":{"url":"include/math.h/atan2.html","title":"double atan2(double y, double x)","keywords":"","body":"double atan2(double y, double x) 描述 C 库函数 double atan2(double y, double x) 返回以弧度表示的 y/x 的反正切。y 和 x 的值的符号决定了正确的象限。 声明 下面是 atan2() 函数的声明。 double atan2(double y, double x) 参数 x -- 代表 x 轴坐标的浮点值。 y -- 代表 y 轴坐标的浮点值。 返回值 该函数返回以弧度表示的 y/x 的反正切，弧度区间为 [-pi,+pi]。 实例 下面的实例演示了 atan2() 函数的用法。 #include #include #define PI 3.14159265 int main () { double x, y, ret, val; x = -7.0; y = 7.0; val = 180.0 / PI; ret = atan2 (y,x) * val; printf(\"x = %lf, y = %lf 的反正切\", x, y); printf(\"是 %lf 度\\n\", ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： x = -7.000000, y = 7.000000 的反正切是 135.000000 度 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/cos.html":{"url":"include/math.h/cos.html","title":"double cos(double x)","keywords":"","body":"double cos(double x) 描述 C 库函数 double cos(double x) 返回弧度角 x 的余弦。 声明 下面是 cos() 函数的声明。 double cos(double x) 参数 x -- 浮点值，代表了一个以弧度表示的角度。 返回值 该函数返回 x 的余弦。 实例 下面的实例演示了 cos() 函数的用法。 #include #include #define PI 3.14159265 int main () { double x, ret, val; x = 60.0; val = PI / 180.0; ret = cos( x*val ); printf(\"%lf 的余弦是 %lf 度\\n\", x, ret); x = 90.0; val = PI / 180.0; ret = cos( x*val ); printf(\"%lf 的余弦是 %lf 度\\n\", x, ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 60.000000 的余弦是 0.500000 度 90.000000 的余弦是 0.000000 度 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/cosh.html":{"url":"include/math.h/cosh.html","title":"double cosh(double x)","keywords":"","body":"double cosh(double x) 描述 C 库函数 double cosh(double x) 返回 x 的双曲余弦。 声明 下面是 cosh() 函数的声明。 double cosh(double x) 参数 x -- 浮点值。 返回值 该函数返回 x 的双曲余弦。 实例 下面的实例演示了 cosh() 函数的用法。 #include #include int main () { double x; x = 0.5; printf(\"%lf 的双曲余弦是 %lf\\n\", x, cosh(x)); x = 1.0; printf(\"%lf 的双曲余弦是 %lf\\n\", x, cosh(x)); x = 1.5; printf(\"%lf 的双曲余弦是 %lf\\n\", x, cosh(x)); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 0.500000 的双曲余弦是 1.127626 1.000000 的双曲余弦是 1.543081 1.500000 的双曲余弦是 2.352410 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/sin.html":{"url":"include/math.h/sin.html","title":"double sin(double x)","keywords":"","body":"double sin(double x) 描述 C 库函数 double sin(double x) 返回弧度角 x 的正弦。 声明 下面是 sin() 函数的声明。 double sin(double x) 参数 x -- 浮点值，代表了一个以弧度表示的角度。 返回值 该函数返回 x 的正弦。 实例 下面的实例演示了 sin() 函数的用法。 #include #include #define PI 3.14159265 int main () { double x, ret, val; x = 45.0; val = PI / 180; ret = sin(x*val); printf(\"%lf 的正弦是 %lf 度\", x, ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 45.000000 的正弦是 0.707107 度 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/sinh.html":{"url":"include/math.h/sinh.html","title":"double sinh(double x)","keywords":"","body":"double sinh(double x) 描述 C 库函数 double sinh(double x) 返回 x 的双曲正弦。 声明 下面是 sinh() 函数的声明。 double sinh(double x) 参数 x -- 浮点值。 返回值 该函数返回 x 的双曲正弦。 实例 下面的实例演示了 sinh() 函数的用法。 #include #include int main () { double x, ret; x = 0.5; ret = sinh(x); printf(\"%lf 的双曲正弦是 %lf 度\", x, ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 0.500000 的双曲正弦是 0.521095 度 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/tanh.html":{"url":"include/math.h/tanh.html","title":"double tanh(double x)","keywords":"","body":"double tanh(double x) 描述 C 库函数 double tanh(double x) 返回 x 的双曲正切。 声明 下面是 tanh() 函数的声明。 double tanh(double x) 参数 x -- 浮点值。 返回值 该函数返回 x 的双曲正切。 实例 下面的实例演示了 tanh() 函数的用法。 #include #include int main () { double x, ret; x = 0.5; ret = tanh(x); printf(\"%lf 的双曲正切是 %lf 度\", x, ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 0.500000 的双曲正切是 0.462117 度 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/exp.html":{"url":"include/math.h/exp.html","title":"double exp(double x)","keywords":"","body":"double exp(double x) 描述 C 库函数 double exp(double x) 返回 e 的 x 次幂的值。 声明 下面是 exp() 函数的声明。 double exp(double x) 参数 x -- 浮点值。 返回值 该函数返回 e 的 x 次幂。 实例 下面的实例演示了 exp() 函数的用法。 #include #include int main () { double x = 0; printf(\"e 的 %lf 次幂是 %lf\\n\", x, exp(x)); printf(\"e 的 %lf 次幂是 %lf\\n\", x+1, exp(x+1)); printf(\"e 的 %lf 次幂是 %lf\\n\", x+2, exp(x+2)); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： e 的 0.000000 次幂是 1.000000 e 的 1.000000 次幂是 2.718282 e 的 2.000000 次幂是 7.389056 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/frexp.html":{"url":"include/math.h/frexp.html","title":"double frexp(double x, int *exponent)","keywords":"","body":"double frexp(double x, int *exponent) 描述 C 库函数 double frexp(double x, int *exponent) 把浮点数 x 分解成尾数和指数。返回值是尾数，并将指数存入 exponent 中。所得的值是 x = mantissa * 2 ^ exponent。 声明 下面是 frexp() 函数的声明。 double frexp(double x, int *exponent) 参数 x -- 要被计算的浮点值。 exponent -- 指向一个对象的指针，该对象存储了指数的值。 返回值 该函数返回规格化小数。如果参数 x 不为零，则规格化小数是 x 的二次方，且它的绝对值范围从 1/2（包含）到 1（不包含）。如果 x 为零，则规格化小数是零，且零存储在 exp 中。 实例 下面的实例演示了 frexp() 函数的用法。 #include #include int main () { double x = 1024, fraction; int e; fraction = frexp(x, &e); printf(\"x = %.2lf = %.2lf * 2^%d\\n\", x, fraction, e); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： x = 1024.00 = 0.50 * 2^11 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/ldexp.html":{"url":"include/math.h/ldexp.html","title":"double ldexp(double x, int exponent)","keywords":"","body":"double ldexp(double x, int exponent) 描述 C 库函数 double ldexp(double x, int exponent) 返回 x 乘以 2 的 exponent 次幂。 声明 下面是 ldexp() 函数的声明。 double ldexp(double x, int exponent) 参数 x -- 代表有效位数的浮点值。 exponent -- 指数的值。 返回值 该函数返回 x * 2 exp。 实例 下面的实例演示了 ldexp() 函数的用法。 #include #include int main () { double x, ret; int n; x = 0.65; n = 3; ret = ldexp(x ,n); printf(\"%f * 2^%d = %f\\n\", x, n, ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 0.650000 * 2^3 = 5.200000 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/log.html":{"url":"include/math.h/log.html","title":"double log(double x)","keywords":"","body":"double log(double x) 描述 C 库函数 double log(double x) 返回 x 的自然对数（基数为 e 的对数）。 声明 下面是 log() 函数的声明。 double log(double x) 参数 x -- 浮点值。 返回值 该函数返回 x 的自然对数。 实例 下面的实例演示了 log() 函数的用法。 #include #include int main () { double x, ret; x = 2.7; /* 计算 log(2.7) */ ret = log(x); printf(\"log(%lf) = %lf\", x, ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： log(2.700000) = 0.993252 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/log10.html":{"url":"include/math.h/log10.html","title":"double log10(double x)","keywords":"","body":"double log10(double x) 描述 C 库函数 double log10(double x) 返回 x 的常用对数（基数为 10 的对数）。 声明 下面是 log10() 函数的声明。 double log10(double x) 参数 x -- 浮点值。 返回值 该函数返回 x 的常用对数，x 的值大于 0。 实例 下面的实例演示了 log10() 函数的用法。 #include #include int main () { double x, ret; x = 10000; /* 计算 log10(10000) */ ret = log10(x); printf(\"log10(%lf) = %lf\\n\", x, ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： log10(10000.000000) = 4.000000 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/modf.html":{"url":"include/math.h/modf.html","title":"double modf(double x, double *integer)","keywords":"","body":"double modf(double x, double *integer) 描述 C 库函数 double modf(double x, double *integer) 返回值为小数部分（小数点后的部分），并设置 integer 为整数部分。 声明 下面是 modf() 函数的声明。 double modf(double x, double *integer) 参数 x -- 浮点值。 integer -- 指向一个对象的指针，该对象存储了整数部分。 返回值 该函数返回 x 的小数部分，符号与 x 相同。 实例 下面的实例演示了 modf() 函数的用法。 #include #include int main () { double x, fractpart, intpart; x = 8.123456; fractpart = modf(x, &intpart); printf(\"整数部分 = %lf\\n\", intpart); printf(\"小数部分 = %lf \\n\", fractpart); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 整数部分 = 8.000000 小数部分 = 0.123456 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/pow.html":{"url":"include/math.h/pow.html","title":"double pow(double x, double y)","keywords":"","body":"double pow(double x, double y) 描述 C 库函数 double pow(double x, double y) 返回 x 的 y 次幂，即 xy。 声明 下面是 pow() 函数的声明。 double pow(double x, double y) 参数 x -- 代表基数的浮点值。 y -- 代表指数的浮点值。 返回值 该函数返回 x 的 y 次幂的结果。 实例 下面的实例演示了 pow() 函数的用法。 #include #include int main () { printf(\"值 8.0 ^ 3 = %lf\\n\", pow(8.0, 3)); printf(\"值 3.05 ^ 1.98 = %lf\", pow(3.05, 1.98)); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 值 8.0 ^ 3 = 512.000000 值 3.05 ^ 1.98 = 9.097324 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/sqrt.html":{"url":"include/math.h/sqrt.html","title":"double sqrt(double x)","keywords":"","body":"double sqrt(double x) 描述 C 库函数 double sqrt(double x) 返回 x 的平方根。 声明 下面是 sqrt() 函数的声明。 double sqrt(double x) 参数 x -- 浮点值。 返回值 该函数返回 x 的平方根。 实例 下面的实例演示了 sqrt() 函数的用法。 #include #include int main () { printf(\"%lf 的平方根是 %lf\\n\", 4.0, sqrt(4.0) ); printf(\"%lf 的平方根是 %lf\\n\", 5.0, sqrt(5.0) ); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 4.000000 的平方根是 2.000000 5.000000 的平方根是 2.236068 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/ceil.html":{"url":"include/math.h/ceil.html","title":"double ceil(double x)","keywords":"","body":"double ceil(double x) 描述 C 库函数 double ceil(double x) 返回大于或等于 x 的最小的整数值。 声明 下面是 ceil() 函数的声明。 double ceil(double x) 参数 x -- 浮点值。 返回值 该函数返回不小于 x 的最小整数值。 实例 下面的实例演示了 ceil() 函数的用法。 #include #include int main () { float val1, val2, val3, val4; val1 = 1.6; val2 = 1.2; val3 = 2.8; val4 = 2.3; printf (\"value1 = %.1lf\\n\", ceil(val1)); printf (\"value2 = %.1lf\\n\", ceil(val2)); printf (\"value3 = %.1lf\\n\", ceil(val3)); printf (\"value4 = %.1lf\\n\", ceil(val4)); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： value1 = 2.0 value2 = 2.0 value3 = 3.0 value4 = 3.0 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/fabs.html":{"url":"include/math.h/fabs.html","title":"double fabs(double x)","keywords":"","body":"double fabs(double x) 描述 C 库函数 double fabs(double x) 返回 x 的绝对值。 声明 下面是 fabs() 函数的声明。 double fabs(double x) 参数 x -- 浮点值。 返回值 该函数返回 x 的绝对值。 实例 下面的实例演示了 fabs() 函数的用法。 #include #include int main () { int a, b; a = 1234; b = -344; printf(\"%d 的绝对值是 %lf\\n\", a, fabs(a)); printf(\"%d 的绝对值是 %lf\\n\", b, fabs(b)); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 1234 的绝对值是 1234.000000 -344 的绝对值是 344.000000 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/floor.html":{"url":"include/math.h/floor.html","title":"double floor(double x)","keywords":"","body":"double floor(double x) 描述 C 库函数 double floor(double x) 返回小于或等于 x 的最大的整数值。 声明 下面是 floor() 函数的声明。 double floor(double x) 参数 x -- 浮点值。 返回值 该函数返回不大于 x 的最大整数值。 实例 下面的实例演示了 floor() 函数的用法。 #include #include int main () { float val1, val2, val3, val4; val1 = 1.6; val2 = 1.2; val3 = 2.8; val4 = 2.3; printf(\"Value1 = %.1lf\\n\", floor(val1)); printf(\"Value2 = %.1lf\\n\", floor(val2)); printf(\"Value3 = %.1lf\\n\", floor(val3)); printf(\"Value4 = %.1lf\\n\", floor(val4)); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： Value1 = 1.0 Value2 = 1.0 Value3 = 2.0 Value4 = 2.0 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/math.h/fmod.html":{"url":"include/math.h/fmod.html","title":"double fmod(double x, double y)","keywords":"","body":"double fmod(double x, double y) 描述 C 库函数 double fmod(double x, double y) 返回 x 除以 y 的余数。 声明 下面是 fmod() 函数的声明。 double fmod(double x, double y) 参数 x -- 代表分子的浮点值。 y -- 代表分母的浮点值。 返回值 该函数返回 x/y 的余数。 实例 下面的实例演示了 fmod() 函数的用法。 #include #include int main () { float a, b; int c; a = 9.2; b = 3.7; c = 2; printf(\"%f / %d 的余数是 %lf\\n\", a, c, fmod(a,c)); printf(\"%f / %f 的余数是 %lf\\n\", a, b, fmod(a,b)); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 9.200000 / 2 的余数是 1.200000 9.200000 / 3.700000 的余数是 1.800000 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/setjmp.h/":{"url":"include/setjmp.h/","title":"setjmp.h","keywords":"","body":"setjmp.h C 标准库 - 简介 setjmp.h 头文件定义了宏 setjmp()、函数 longjmp() 和变量类型 jmp_buf，该变量类型会绕过正常的函数调用和返回规则。 库变量 下面列出了头文件 setjmp.h 中定义的变量： 序号 变量 & 描述 1 jmp_buf 这是一个用于存储宏 setjmp() 和函数 longjmp() 相关信息的数组类型。 库宏 下面是这个库中定义的唯一的一个宏： 序号 宏 & 描述 1 int setjmp(jmp_buf environment) 这个宏把当前环境保存在变量 environment 中，以便函数 longjmp() 后续使用。如果这个宏直接从宏调用中返回，则它会返回零，但是如果它从 longjmp() 函数调用中返回，则它会返回一个非零值。 库函数 下面是头文件 setjmp.h 中定义的唯一的一个函数： 序号 函数 & 描述 1 void longjmp(jmp_buf environment, int value) 该函数恢复最近一次调用 setjmp() 宏时保存的环境，jmp_buf 参数的设置是由之前调用 setjmp() 生成的。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/setjmp.h/setjmp.html":{"url":"include/setjmp.h/setjmp.html","title":"int setjmp(jmp_buf environment)","keywords":"","body":"int setjmp(jmp_buf environment) 描述 C 库宏 int setjmp(jmp_buf environment) ：创建本地的jmp_buf缓冲区并且初始化，用于将来跳转回此处。这个子程序保存程序的调用环境于env参数所指的缓冲区，env将被longjmp使用。如果是从setjmp直接调用返回，setjmp返回值为0。如果是从longjmp恢复的程序调用环境返回，setjmp返回非零值。 声明 下面是 setjmp() 宏的声明。 int setjmp(jmp_buf environment) 参数 environment -- 这是一个类型为 jmp_buf 的用于存储环境信息的对象。 返回值 这个宏可能不只返回一次。第一次，在直接调用它时，它总是返回零。当调用 longjmp 时带有设置的环境信息，这个宏会再次返回，此时它返回的值会传给 longjmp 作为第二个参数。 实例 下面的实例演示了 setjmp() 宏的用法。 #include #include static jmp_buf buf; void second(void) { printf(\"second\\n\"); // 打印 longjmp(buf,1); // 跳回setjmp的调用处 - 使得setjmp返回值为1 } void first(void) { second(); printf(\"first\\n\"); // 不可能执行到此行 } int main() { if ( ! setjmp(buf) ) { first(); // 进入此行前，setjmp返回0 } else { // 当longjmp跳转回，setjmp返回1，因此进入此行 printf(\"main\\n\"); // 打印 } return 0; } //second //main 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/setjmp.h/longjmp.html":{"url":"include/setjmp.h/longjmp.html","title":"void longjmp(jmp_buf environment, int value)","keywords":"","body":"void longjmp(jmp_buf environment, int value) 描述 C 库函数 void longjmp(jmp_buf environment, int value) 恢复最近一次调用 setjmp() 宏时保存的环境，jmp_buf 参数的设置是由之前调用 setjmp() 生成的。 声明 下面是 longjmp() 函数的声明。 void longjmp(jmp_buf environment, int value) 参数 environment -- 这是一个类型为 jmp_buf 的对象，包含了调用 setjmp 时存储的环境信息。 value -- 这是 setjmp 表达式要判断的值。 返回值 该函数不返回任何值。 实例 下面的实例演示了 longjmp() 函数的用法。 #include #include static jmp_buf buf; void second(void) { printf(\"second\\n\"); // 打印 longjmp(buf,1); // 跳回setjmp的调用处 - 使得setjmp返回值为1 } void first(void) { second(); printf(\"first\\n\"); // 不可能执行到此行 } int main() { if ( ! setjmp(buf) ) { first(); // 进入此行前，setjmp返回0 } else { // 当longjmp跳转回，setjmp返回1，因此进入此行 printf(\"main\\n\"); // 打印 } return 0; } 让我们编译并运行上面的程序，这将产生以下结果： second main 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/signal.h/":{"url":"include/signal.h/","title":"signal.h","keywords":"","body":"signal.h C 标准库 - 简介 signal.h 头文件定义了一个变量类型 sig_atomic_t、两个函数调用和一些宏来处理程序执行期间报告的不同信号。 库变量 下面是头文件 signal.h 中定义的变量类型： 序号 变量 & 描述 1 sig_atomic_t 这是 int 类型，在信号处理程序中作为变量使用。它是一个对象的整数类型，该对象可以作为一个原子实体访问，即使存在异步信号时，该对象可以作为一个原子实体访问。 库宏 下面是头文件 signal.h 中定义的宏，这些宏将在下列两个函数中使用。SIG_ 宏与 signal 函数一起使用来定义信号的功能。 序号 宏 & 描述 1 SIG_DFL 默认的信号处理程序。 2 SIG_ERR 表示一个信号错误。 3 SIG_IGN 忽视信号。 SIG 宏用于表示以下各种条件的信号码： 序号 宏 & 描述 1 SIGABRT 程序异常终止。 2 SIGFPE 算术运算出错，如除数为 0 或溢出。 3 SIGILL 非法函数映象，如非法指令。 4 SIGINT 中断信号，如 ctrl-C。 5 SIGSEGV 非法访问存储器，如访问不存在的内存单元。 6 SIGTERM 发送给本程序的终止请求信号。 库函数 下面是头文件 signal.h 中定义的函数： 序号 函数 & 描述 1 void (signal(int sig, void (func)(int)))(int) 该函数设置一个函数来处理信号，即信号处理程序。 2 int raise(int sig) 该函数会促使生成信号 sig。sig 参数与 SIG 宏兼容。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/signal.h/signal.html":{"url":"include/signal.h/signal.html","title":"void (signal(int sig, void (func)(int)))(int)","keywords":"","body":"void (signal(int sig, void (func)(int)))(int) 描述 C 库函数 void (*signal(int sig, void (*func)(int)))(int) 设置一个函数来处理信号，即带有 sig 参数的信号处理程序。 声明 下面是 signal() 函数的声明。 void (*signal(int sig, void (*func)(int)))(int) 参数 sig -- 在信号处理程序中作为变量使用的信号码。下面是一些重要的标准信号常量： 宏 信号 SIGABRT (Signal Abort) 程序异常终止。 SIGFPE (Signal Floating-Point Exception) 算术运算出错，如除数为 0 或溢出（不一定是浮点运算）。 SIGILL (Signal Illegal Instruction) 非法函数映象，如非法指令，通常是由于代码中的某个变体或者尝试执行数据导致的。 SIGINT (Signal Interrupt) 中断信号，如 ctrl-C，通常由用户生成。 SIGSEGV (Signal Segmentation Violation) 非法访问存储器，如访问不存在的内存单元。 SIGTERM (Signal Terminate) 发送给本程序的终止请求信号。 func -- 一个指向函数的指针。它可以是一个由程序定义的函数，也可以是下面预定义函数之一： SIG_DFL 默认的信号处理程序。 SIG_IGN 忽视信号。 返回值 该函数返回信号处理程序之前的值，当发生错误时返回 SIG_ERR。 实例 下面的实例演示了 signal() 函数的用法。 #include #include #include #include void sighandler(int); int main() { signal(SIGINT, sighandler); while(1) { printf(\"开始休眠一秒钟...\\n\"); sleep(1); } return(0); } void sighandler(int signum) { printf(\"捕获信号 %d，跳出...\\n\", signum); exit(1); } 让我们编译并运行上面的程序，这将产生以下结果，且程序会进入无限循环，需使用 CTRL + C 键跳出程序。 开始休眠一秒钟... 开始休眠一秒钟... 开始休眠一秒钟... 开始休眠一秒钟... 开始休眠一秒钟... 捕获信号 2，跳出... 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/signal.h/raise.html":{"url":"include/signal.h/raise.html","title":"int raise(int sig)","keywords":"","body":"int raise(int sig) 描述 C 库函数 int raise(int sig) 会促使生成信号 sig。sig 参数与 SIG 宏兼容。 声明 下面是 raise() 函数的声明。 int raise(int sig) 参数 sig -- 要发送的信号码。下面是一些重要的标准信号常量： 宏 信号 SIGABRT (Signal Abort) 程序异常终止。 SIGFPE (Signal Floating-Point Exception) 算术运算出错，如除数为 0 或溢出（不一定是浮点运算）。 SIGILL (Signal Illegal Instruction) 非法函数映象，如非法指令，通常是由于代码中的某个变体或者尝试执行数据导致的。 SIGINT (Signal Interrupt) 中断信号，如 ctrl-C，通常由用户生成。 SIGSEGV (Signal Segmentation Violation) 非法访问存储器，如访问不存在的内存单元。 SIGTERM (Signal Terminate) 发送给本程序的终止请求信号。 返回值 如果成功该函数返回零，否则返回非零。 实例 下面的实例演示了 raise() 函数的用法。 #include #include void signal_catchfunc(int); int main() { int ret; ret = signal(SIGINT, signal_catchfunc); if( ret == SIG_ERR) { printf(\"错误：不能设置信号处理程序。\\n\"); exit(0); } printf(\"开始生成一个信号\\n\"); ret = raise(SIGINT); if( ret !=0 ) { printf(\"错误：不能生成 SIGINT 信号。\\n\"); exit(0); } printf(\"退出...\\n\"); return(0); } void signal_catchfunc(int signal) { printf(\"!! 信号捕获 !!\\n\"); } 让我们编译并运行上面的程序，这将产生以下结果： 开始生成一个信号 !! 信号捕获 !! 退出... 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdarg.h/":{"url":"include/stdarg.h/","title":"stdarg.h","keywords":"","body":"stdarg.h C 标准库 - 简介 stdarg.h 头文件定义了一个变量类型 va_list 和三个宏，这三个宏可用于在参数个数未知（即参数个数可变）时获取函数中的参数。 可变参数的函数通在参数列表的末尾是使用省略号(,...)定义的。 库变量 下面是头文件 stdarg.h 中定义的变量类型： 序号 变量 & 描述 1 va_list 这是一个适用于 va_start()、va_arg() 和 va_end() 这三个宏存储信息的类型。 库宏 下面是头文件 stdarg.h 中定义的宏： 序号 宏 & 描述 1 void va_start(va_list ap, last_arg) 这个宏初始化 ap 变量，它与 va_arg 和 va_end 宏是一起使用的。last_arg 是最后一个传递给函数的已知的固定参数，即省略号之前的参数。 2 type va_arg(va_list ap, type) 这个宏检索函数参数列表中类型为 type 的下一个参数。 3 void va_end(va_list ap) 这个宏允许使用了 va_start 宏的带有可变参数的函数返回。如果在从函数返回之前没有调用 va_end，则结果为未定义。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdarg.h/va_start.html":{"url":"include/stdarg.h/va_start.html","title":"void va_start(va_list ap, last_arg)","keywords":"","body":"void va_start(va_list ap, last_arg) 描述 C 库宏 void va_start(va_list ap, last_arg) 初始化 ap 变量，它与 va_arg 和 va_end 宏是一起使用的。last_arg 是最后一个传递给函数的已知的固定参数，即省略号之前的参数。 这个宏必须在使用 va_arg 和 va_end 之前被调用。 声明 下面是 va_start() 宏的声明。 void va_start(va_list ap, last_arg); 参数 ap -- 这是一个 va_list 类型的对象，它用来存储通过 va_arg 获取额外参数时所必需的信息。 last_arg -- 最后一个传递给函数的已知的固定参数。 返回值 NA 实例 下面的实例演示了 va_start() 宏的用法。 #include #include int sum(int, ...); int main(void) { printf(\"10、20 和 30 的和 = %d\\n\", sum(3, 10, 20, 30) ); printf(\"4、20、25 和 30 的和 = %d\\n\", sum(4, 4, 20, 25, 30) ); return 0; } int sum(int num_args, ...) { int val = 0; va_list ap; int i; va_start(ap, num_args); for(i = 0; i 让我们编译并运行上面的程序，这将产生以下结果： 10、20 和 30 的和 = 60 4、20、25 和 30 的和 = 79 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdarg.h/va_arg.html":{"url":"include/stdarg.h/va_arg.html","title":"type va_arg(va_list ap, type)","keywords":"","body":"type va_arg(va_list ap, type) 描述 C 库宏 type va_arg(va_list ap, type) 检索函数参数列表中类型为 type 的下一个参数。它无法判断检索到的参数是否是传给函数的最后一个参数。 声明 下面是 va_arg() 宏的声明。 type va_arg(va_list ap, type) 参数 ap -- 这是一个 va_list 类型的对象，存储了有关额外参数和检索状态的信息。该对象应在第一次调用 va_arg 之前通过调用 va_start 进行初始化。 type -- 这是一个类型名称。该类型名称是作为扩展自该宏的表达式的类型来使用的。 返回值 该宏返回下一个额外的参数，是一个类型为 type 的表达式。 实例 下面的实例演示了 va_arg() 宏的用法。 #include #include int sum(int, ...); int main() { printf(\"15 和 56 的和 = %d\\n\", sum(2, 15, 56) ); return 0; } int sum(int num_args, ...) { int val = 0; va_list ap; int i; va_start(ap, num_args); for(i = 0; i 让我们编译并运行上面的程序，这将产生以下结果： 15 和 56 的和 = 71 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdarg.h/va_end.html":{"url":"include/stdarg.h/va_end.html","title":"void va_end(va_list ap)","keywords":"","body":"void va_end(va_list ap) 描述 C 库宏 void va_end(va_list ap) 允许使用了 va_start 宏的带有可变参数的函数返回。如果在从函数返回之前没有调用 va_end，则结果为未定义。 声明 下面是 va_end() 宏的声明。 void va_end(va_list ap) 参数 ap -- 这是之前由同一函数中的 va_start 初始化的 va_list 对象。 返回值 该宏不返回任何值。 实例 下面的实例演示了 va_end() 宏的用法。 #include #include int mul(int, ...); int main() { printf(\"15 * 12 = %d\\n\", mul(2, 15, 12) ); return 0; } int mul(int num_args, ...) { int val = 1; va_list ap; int i; va_start(ap, num_args); for(i = 0; i 让我们编译并运行上面的程序，这将产生以下结果： 15 * 12 = 180 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stddef.h/":{"url":"include/stddef.h/","title":"stddef.h","keywords":"","body":"stddef.h C 标准库 - 简介 stddef .h 头文件定义了各种变量类型和宏。这些定义中的大部分也出现在其它头文件中。 库变量 下面是头文件 stddef.h 中定义的变量类型： 序号 变量 & 描述 1 ptrdiff_t 这是有符号整数类型，它是两个指针相减的结果。 2 size_t 这是无符号整数类型，它是 sizeof 关键字的结果。 3 wchar_t 这是一个宽字符常量大小的整数类型。 库宏 下面是头文件 stddef.h 中定义的宏： 序号 宏 & 描述 1 NULL 这个宏是一个空指针常量的值。 2 offsetof(type, member-designator) 这会生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 member-designator给定的，结构的名称是在 type 中给定的。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stddef.h/NULL.html":{"url":"include/stddef.h/NULL.html","title":"NULL","keywords":"","body":"NULL 描述 C 库宏 NULL 是一个空指针常量的值。它可以被定义为 ((void*)0), 0 或 0L，这取决于编译器供应商。 声明 下面是取决于编译器的 NULL 宏的声明。 #define NULL ((char *)0) 或 #define NULL 0L 或 #define NULL 0 参数 NA 返回值 NA 实例 下面的实例演示了 NULL 宏的用法。 #include #include int main () { FILE *fp; fp = fopen(\"file.txt\", \"r\"); if( fp != NULL ) { printf(\"成功打开文件 file.txt\\n\"); fclose(fp); } fp = fopen(\"nofile.txt\", \"r\"); if( fp == NULL ) { printf(\"不能打开文件 nofile.txt\\n\"); } return(0); } 假设文件 file.txt 已存在，但是 nofile.txt 不存在。让我们编译并运行上面的程序，这将产生以下结果： 成功打开文件 file.txt 不能打开文件 nofile.txt 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stddef.h/offsetof.html":{"url":"include/stddef.h/offsetof.html","title":"offsetof(type, member-designator)","keywords":"","body":"offsetof(type, member-designator) 描述 C 库宏 offsetof(type, member-designator) 会生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 member-designator 给定的，结构的名称是在 type 中给定的。 声明 下面是 offsetof() 宏的声明。 offsetof(type, member-designator) 参数 type -- 这是一个 class 类型，其中，member-designator 是一个有效的成员指示器。 member-designator -- 这是一个 class 类型的成员指示器。 返回值 该宏返回类型为 size_t 的值，表示 type 中成员的偏移量。 实例 下面的实例演示了 offsetof() 宏的用法。 #include #include struct address { char name[50]; char street[50]; int phone; }; int main() { printf(\"address 结构中的 name 偏移 = %d 字节。\\n\", offsetof(struct address, name)); printf(\"address 结构中的 street 偏移 = %d 字节。\\n\", offsetof(struct address, street)); printf(\"address 结构中的 phone 偏移 = %d 字节。\\n\", offsetof(struct address, phone)); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： address 结构中的 name 偏移 = 0 字节。 address 结构中的 street 偏移 = 50 字节。 address 结构中的 phone 偏移 = 100 字节。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/":{"url":"include/stdio.h/","title":"stdio.h","keywords":"","body":"stdio.h C 标准库 - 简介 stdio .h 头文件定义了三个变量类型、一些宏和各种函数来执行输入和输出。 库变量 下面是头文件 stdio.h 中定义的变量类型： 序号 变量 & 描述 1 size_t 这是无符号整数类型，它是 sizeof 关键字的结果。 2 FILE 这是一个适合存储文件流信息的对象类型。 3 fpos_t 这是一个适合存储文件中任何位置的对象类型。 库宏 下面是头文件 stdio.h 中定义的宏： 序号 宏 & 描述 1 NULL 这个宏是一个空指针常量的值。 2 _IOFBF、_IOLBF 和 _IONBF 这些宏扩展了带有特定值的整型常量表达式，并适用于 setvbuf 函数的第三个参数。 3 BUFSIZ 这个宏是一个整数，该整数代表了 setbuf 函数使用的缓冲区大小。 4 EOF 这个宏是一个表示已经到达文件结束的负整数。 5 FOPEN_MAX 这个宏是一个整数，该整数代表了系统可以同时打开的文件数量。 6 FILENAME_MAX 这个宏是一个整数，该整数代表了字符数组可以存储的文件名的最大长度。如果实现没有任何限制，则该值应为推荐的最大值。 7 L_tmpnam 这个宏是一个整数，该整数代表了字符数组可以存储的由 tmpnam 函数创建的临时文件名的最大长度。 8 SEEK_CUR、SEEK_END 和 SEEK_SET 这些宏是在 fseek 函数中使用，用于在一个文件中定位不同的位置。 9 TMP_MAX 这个宏是 tmpnam 函数可生成的独特文件名的最大数量。 10 stderr、stdin 和 stdout 这些宏是指向 FILE 类型的指针，分别对应于标准错误、标准输入和标准输出流。 库函数 下面是头文件 stdio.h 中定义的函数： 为了更好地理解函数，请按照下面的序列学习这些函数，因为第一个函数中创建的文件会在后续的函数中使用到。 序号 函数 & 描述 1 int fclose(FILE *stream) 关闭流 stream。刷新所有的缓冲区。 2 void clearerr(FILE *stream) 清除给定流 stream 的文件结束和错误标识符。 3 int feof(FILE *stream) 测试给定流 stream 的文件结束标识符。 4 int ferror(FILE *stream) 测试给定流 stream 的错误标识符。 5 int fflush(FILE *stream) 刷新流 stream 的输出缓冲区。 6 int fgetpos(FILE stream, fpos_t pos) 获取流 stream 的当前文件位置，并把它写入到 pos。 7 FILE fopen(const char filename, const char *mode) 使用给定的模式 mode 打开 filename 所指向的文件。 8 size_t fread(void ptr, size_t size, size_t nmemb, FILE stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。 9 FILE freopen(const char filename, const char mode, FILE stream) 把一个新的文件名 filename 与给定的打开的流 stream 关联，同时关闭流中的旧文件。 10 int fseek(FILE *stream, long int offset, int whence) 设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数。 11 int fsetpos(FILE stream, const fpos_t pos) 设置给定流 stream 的文件位置为给定的位置。参数 pos 是由函数 fgetpos 给定的位置。 12 long int ftell(FILE *stream) 返回给定流 stream 的当前文件位置。 13 size_t fwrite(const void ptr, size_t size, size_t nmemb, FILE stream) 把 ptr 所指向的数组中的数据写入到给定流 stream 中。 14 int remove(const char *filename) 删除给定的文件名 filename，以便它不再被访问。 15 int rename(const char old_filename, const char new_filename) 把 old_filename 所指向的文件名改为 new_filename。 16 void rewind(FILE *stream) 设置文件位置为给定流 stream 的文件的开头。 17 void setbuf(FILE stream, char buffer) 定义流 stream 应如何缓冲。 18 int setvbuf(FILE stream, char buffer, int mode, size_t size) 另一个定义流 stream 应如何缓冲的函数。 19 FILE *tmpfile(void) 以二进制更新模式(wb+)创建临时文件。 20 char tmpnam(char str) 生成并返回一个有效的临时文件名，该文件名之前是不存在的。 21 int fprintf(FILE stream, const char format, ...) 发送格式化输出到流 stream 中。 22 int printf(const char *format, ...) 发送格式化输出到标准输出 stdout。 23 int sprintf(char str, const char format, ...) 发送格式化输出到字符串。 24 int vfprintf(FILE stream, const char format, va_list arg) 使用参数列表发送格式化输出到流 stream 中。 25 int vprintf(const char *format, va_list arg) 使用参数列表发送格式化输出到标准输出 stdout。 26 int vsprintf(char str, const char format, va_list arg) 使用参数列表发送格式化输出到字符串。 27 int fscanf(FILE stream, const char format, ...) 从流 stream 读取格式化输入。 28 int scanf(const char *format, ...) 从标准输入 stdin 读取格式化输入。 29 int sscanf(const char str, const char format, ...) 从字符串读取格式化输入。 30 int fgetc(FILE *stream) 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。 31 char fgets(char str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。 32 int fputc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。 33 int fputs(const char str, FILE stream) 把字符串写入到指定的流 stream 中，但不包括空字符。 34 int getc(FILE *stream) 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。 35 int getchar(void) 从标准输入 stdin 获取一个字符（一个无符号字符）。 36 char gets(char str) 从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。 37 int putc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。 38 int putchar(int char) 把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中。 39 int puts(const char *str) 把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。 40 int ungetc(int char, FILE *stream) 把字符 char（一个无符号字符）推入到指定的流 stream 中，以便它是下一个被读取到的字符。 41 void perror(const char *str) 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/fclose.html":{"url":"include/stdio.h/fclose.html","title":"int fclose(FILE *stream)","keywords":"","body":"int fclose(FILE *stream) 描述 C 库函数 int fclose(FILE *stream) 关闭流 stream。刷新所有的缓冲区。 声明 下面是 fclose() 函数的声明。 int fclose(FILE *stream) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象指定了要被关闭的流。 返回值 如果流成功关闭，则该方法返回零。如果失败，则返回 EOF。 实例 下面的实例演示了 fclose() 函数的用法。 #include int main() { FILE *fp; fp = fopen(\"file.txt\", \"w\"); fprintf(fp, \"%s\", \"这里是 runoob.com\"); fclose(fp); return(0); } 让我们编译并运行上面的程序，这将创建一个文件 file.txt，然后写入下面的文本行，最后使用 fclose() 函数关闭文件。 这里是 runoob.com 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/clearerr.html":{"url":"include/stdio.h/clearerr.html","title":"void clearerr(FILE *stream)","keywords":"","body":"void clearerr(FILE *stream) 描述 C 库函数 void clearerr(FILE *stream) 清除给定流 stream 的文件结束和错误标识符。 声明 下面是 clearerr() 函数的声明。 void clearerr(FILE *stream) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 返回值 这不会失败，且不会设置外部变量 errno，但是如果它检测到它的参数不是一个有效的流，则返回 -1，并设置 errno 为 EBADF。 实例 下面的实例演示了 clearerr() 函数的用法。 #include int main() { FILE *fp; char c; fp = fopen(\"file.txt\", \"w\"); c = fgetc(fp); if( ferror(fp) ) { printf(\"读取文件：file.txt 时发生错误\\n\"); } clearerr(fp); if( ferror(fp) ) { printf(\"读取文件：file.txt 时发生错误\\n\"); } fclose(fp); return(0); } 假设我们有一个文本文件 file.txt，它是一个空文件。让我们编译并运行上面的程序，因为我们试图读取一个以只写模式打开的文件，这将产生以下结果。 读取文件：file.txt 时发生错误 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/feof.html":{"url":"include/stdio.h/feof.html","title":"int feof(FILE *stream)","keywords":"","body":"int feof(FILE *stream) 描述 C 库函数 int feof(FILE *stream) 测试给定流 stream 的文件结束标识符。 声明 下面是 feof() 函数的声明。 int feof(FILE *stream) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 返回值 当设置了与流关联的文件结束标识符时，该函数返回一个非零值，否则返回零。 实例 下面的实例演示了 feof() 函数的用法。 #include int main () { FILE *fp; int c; fp = fopen(\"file.txt\",\"r\"); if(fp == NULL) { perror(\"打开文件时发生错误\"); return(-1); } while(1) { c = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", c); } fclose(fp); return(0); } 假设我们有一个文本文件 file.txt，它的内容如下所示。该文件将作为我们实例程序中的一个输入使用： 这里是 runoob.com 让我们编译并运行上面的程序，这将产生以下结果： 这里是 runoob.com 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/ferror.html":{"url":"include/stdio.h/ferror.html","title":"int ferror(FILE *stream)","keywords":"","body":"int ferror(FILE *stream) 描述 C 库函数 int ferror(FILE *stream) 测试给定流 stream 的错误标识符。 声明 下面是 ferror() 函数的声明。 int ferror(FILE *stream) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 返回值 如果设置了与流关联的错误标识符，该函数返回一个非零值，否则返回一个零值。 实例 下面的实例演示了 ferror() 函数的用法。 #include int main() { FILE *fp; char c; fp = fopen(\"file.txt\", \"w\"); c = fgetc(fp); if( ferror(fp) ) { printf(\"读取文件：file.txt 时发生错误\\n\"); } clearerr(fp); if( ferror(fp) ) { printf(\"读取文件：file.txt 时发生错误\\n\"); } fclose(fp); return(0); } 假设我们有一个文本文件 file.txt，它是一个空文件。让我们编译并运行上面的程序，因为我们试图读取一个以只写模式打开的文件，这将产生以下结果。 读取文件：file.txt 时发生错误 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/fflush.html":{"url":"include/stdio.h/fflush.html","title":"int fflush(FILE *stream)","keywords":"","body":"int fflush(FILE *stream) 描述 C 库函数 int fflush(FILE *stream) 刷新流 stream 的输出缓冲区。 声明 下面是 fflush() 函数的声明。 int fflush(FILE *stream) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象指定了一个缓冲流。 返回值 如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）。 实例 下面的实例演示了 fflush() 函数的用法。 #include #include int main() { char buff[1024]; memset( buff, '\\0', sizeof( buff )); fprintf(stdout, \"启用全缓冲\\n\"); setvbuf(stdout, buff, _IOFBF, 1024); fprintf(stdout, \"这里是 runoob.com\\n\"); fprintf(stdout, \"该输出将保存到 buff\\n\"); fflush( stdout ); fprintf(stdout, \"这将在编程时出现\\n\"); fprintf(stdout, \"最后休眠五秒钟\\n\"); sleep(5); return(0); } /* 让我们编译并运行上面的程序，这将产生以下结果。在这里，程序把缓冲输出保存到 buff，直到首次调用 fflush() 为止，然后开始缓冲输出，最后休眠 5 秒钟。它会在程序结束之前，发送剩余的输出到 STDOUT。 启用全缓冲 这里是 runoob.com 该输出将保存到 buff 这将在编程时出现 最后休眠五秒钟 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/fgetpos.html":{"url":"include/stdio.h/fgetpos.html","title":"int fgetpos(FILE stream, fpos_t pos)","keywords":"","body":"int fgetpos(FILE stream, fpos_t pos) 描述 C 库函数 int fgetpos(FILE *stream, fpos_t *pos) 获取流 stream 的当前文件位置，并把它写入到 pos。 声明 下面是 fgetpos() 函数的声明。 int fgetpos(FILE *stream, fpos_t *pos) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 pos -- 这是指向 fpos_t 对象的指针。 返回值 如果成功，该函数返回零。如果发生错误，则返回非零值。 实例 下面的实例演示了 fgetpos() 函数的用法。 #include int main () { FILE *fp; fpos_t position; fp = fopen(\"file.txt\",\"w+\"); fgetpos(fp, &position); fputs(\"Hello, World!\", fp); fsetpos(fp, &position); fputs(\"这将覆盖之前的内容\", fp); fclose(fp); return(0); } 让我们编译并运行上面的程序，这将创建一个文件 file.txt，它的内容如下。首先我们使用 fgetpos() 函数获取文件的初始位置，接着我们向文件写入 Hello, World!，然后我们使用 fsetpos() 函数来重置写指针到文件的开头，重写文件为下列内容： 这将覆盖之前的内容 现在让我们使用下面的程序查看上面文件的内容： #include int main () { FILE *fp; int c; int n = 0; fp = fopen(\"file.txt\",\"r\"); while(1) { c = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", c); } fclose(fp); return(0); } 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/*fopen.html":{"url":"include/stdio.h/*fopen.html","title":"FILE fopen(const char filename, const char *mode)","keywords":"","body":"FILE fopen(const char filename, const char mode) 描述 C 库函数 FILE *fopen(const char filename, const char mode) 使用给定的模式 mode 打开 filename 所指向的文件。 声明 下面是 fopen() 函数的声明。 FILE *fopen(const char *filename, const char *mode) 参数 filename -- 这是 C 字符串，包含了要打开的文件名称。 mode -- 这是 C 字符串，包含了文件访问模式，模式如下： 模式 描述 \"r\" 打开一个用于读取的文件。该文件必须存在。 \"w\" 创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。 \"a\" 追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。 \"r+\" 打开一个用于更新的文件，可读取也可写入。该文件必须存在。 \"w+\" 创建一个用于读写的空文件。 \"a+\" 打开一个用于读取和追加的文件。 返回值 该函数返回一个 FILE 指针。否则返回 NULL，且设置全局变量 errno 来标识错误。 实例 下面的实例演示了 fopen() 函数的用法。 #include #include int main() { FILE * fp; fp = fopen (\"file.txt\", \"w+\"); fprintf(fp, \"%s %s %s %d\", \"We\", \"are\", \"in\", 2014); fclose(fp); return(0); } 让我们编译并运行上面的程序，这将创建一个带有一下内容的文件 file.txt： We are in 2014 现在让我们使用下面的程序查看上面文件的内容： #include int main () { FILE *fp; int c; fp = fopen(\"file.txt\",\"r\"); while(1) { c = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", c); } fclose(fp); return(0); } 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/fread.html":{"url":"include/stdio.h/fread.html","title":"size_t fread(void ptr, size_t size, size_t nmemb, FILE stream)","keywords":"","body":"size_t fread(void ptr, size_t size, size_t nmemb, FILE stream) 描述 C 库函数 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。 声明 下面是 fread() 函数的声明。 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 参数 ptr -- 这是指向带有最小尺寸 size\\nmemb* 字节的内存块的指针。 size -- 这是要读取的每个元素的大小，以字节为单位。 nmemb -- 这是元素的个数，每个元素的大小为 size 字节。 stream -- 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。 返回值 成功读取的元素总数会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾。 实例 下面的实例演示了 fread() 函数的用法。 #include #include int main() { FILE *fp; char c[] = \"This is runoob\"; char buffer[20]; /* 打开文件用于读写 */ fp = fopen(\"file.txt\", \"w+\"); /* 写入数据到文件 */ fwrite(c, strlen(c) + 1, 1, fp); /* 查找文件的开头 */ fseek(fp, 0, SEEK_SET); /* 读取并显示数据 */ fread(buffer, strlen(c)+1, 1, fp); printf(\"%s\\n\", buffer); fclose(fp); return(0); } 让我们编译并运行上面的程序，这将创建一个文件 file.txt，然后写入内容 This is runoob。接下来我们使用 fseek() 函数来重置写指针到文件的开头，文件内容如下所示： This is runoob 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/*freopen.html":{"url":"include/stdio.h/*freopen.html","title":"FILE freopen(const char filename, const char mode, FILE stream)","keywords":"","body":"FILE *freopen(const char filename, const char mode, FILE stream) 描述 C 库函数 FILE *freopen(const char filename, const char mode, FILE *stream) 把一个新的文件名 filename 与给定的打开的流 stream 关联，同时关闭流中的旧文件。 声明 下面是 freopen() 函数的声明。 FILE *freopen(const char *filename, const char *mode, FILE *stream) 参数 filename -- 这是 C 字符串，包含了要打开的文件名称。 mode -- 这是 C 字符串，包含了文件访问模式，模式如下： 模式 描述 \"r\" 打开一个用于读取的文件。该文件必须存在。 \"w\" 创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。 \"a\" 追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。 \"r+\" 打开一个用于更新的文件，可读取也可写入。该文件必须存在。 \"w+\" 创建一个用于读写的空文件。 \"a+\" 打开一个用于读取和追加的文件。 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了要被重新打开的流。 返回值 如果文件成功打开，则函数返回一个指针，指向用于标识流的对象。否则，返回空指针。 实例 下面的实例演示了 freopen() 函数的用法。 #include int main () { FILE *fp; printf(\"该文本重定向到 stdout\\n\"); fp = freopen(\"file.txt\", \"w+\", stdout); printf(\"该文本重定向到 file.txt\\n\"); fclose(fp); return(0); } 让我们编译并运行上面的程序，这将发送下列行到标准输出 STDOUT，因为起初我们并没有打开标准输出： 该文本重定向到 stdout 在调用 freopen() 之后，它会关联标准输出 STDOUT 到文件 file.txt，无论我们在标准输出 STDOUT 中写了什么都会被写入 file.txt，所以文件 file.txt 将有以下内容。 该文本重定向到 file.txt 现在让我们使用下面的程序查看上面文件的内容： #include int main () { FILE *fp; int c; fp = fopen(\"file.txt\",\"r\"); while(1) { c = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", c); } fclose(fp); return(0); } 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/fseek.html":{"url":"include/stdio.h/fseek.html","title":"int fseek(FILE *stream, long int offset, int whence)","keywords":"","body":"int fseek(FILE *stream, long int offset, int whence) 描述 C 库函数 int fseek(FILE *stream, long int offset, int whence) 设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数。 声明 下面是 fseek() 函数的声明。 int fseek(FILE *stream, long int offset, int whence) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 offset -- 这是相对 whence 的偏移量，以字节为单位。 whence -- 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一： 常量 描述 SEEK_SET 文件的开头 SEEK_CUR 文件指针的当前位置 SEEK_END 文件的末尾 返回值 如果成功，则该函数返回零，否则返回非零值。 实例 下面的实例演示了 fseek() 函数的用法。 #include int main () { FILE *fp; fp = fopen(\"file.txt\",\"w+\"); fputs(\"This is runoob.com\", fp); fseek( fp, 7, SEEK_SET ); fputs(\" C Programming Langauge\", fp); fclose(fp); return(0); } 让我们编译并运行上面的程序，这将创建文件 file.txt，它的内容如下。最初程序创建文件和写入 This is runoob.com，但是之后我们在第七个位置重置了写指针，并使用 puts() 语句来重写文件，内容如下： This is C Programming Langauge 现在让我们使用下面的程序查看上面文件的内容： #include int main () { FILE *fp; int c; fp = fopen(\"file.txt\",\"r\"); while(1) { c = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", c); } fclose(fp); return(0); } 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/fsetpos.html":{"url":"include/stdio.h/fsetpos.html","title":"int fsetpos(FILE stream, const fpos_t pos)","keywords":"","body":"int fsetpos(FILE stream, const fpos_t pos) 描述 C 库函数 int fsetpos(FILE *stream, const fpos_t *pos) 设置给定流 stream 的文件位置为给定的位置。参数 pos 是由函数 fgetpos 给定的位置。 声明 下面是 fsetpos() 函数的声明。 int fsetpos(FILE *stream, const fpos_t *pos) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 pos -- 这是指向 fpos_t 对象的指针，该对象包含了之前通过 fgetpos 获得的位置。 返回值 如果成功，该函数返回零值，否则返回非零值，并设置全局变量 errno 为一个正值，该值可通过 perror 来解释。 实例 下面的实例演示了 fsetpos() 函数的用法。 #include int main () { FILE *fp; fpos_t position; fp = fopen(\"file.txt\",\"w+\"); fgetpos(fp, &position); fputs(\"Hello, World!\", fp); fsetpos(fp, &position); fputs(\"这将覆盖之前的内容\", fp); fclose(fp); return(0); } 让我们编译并运行上面的程序，这将创建一个文件 file.txt，它的内容如下。首先我们使用 fgetpos() 函数获取文件的初始位置，接着我们向文件写入 Hello, World!，然后我们使用 fsetpos() 函数来重置写指针到文件的开头，重写文件为下列内容： 这将覆盖之前的内容 现在让我们使用下面的程序查看上面文件的内容： #include int main () { FILE *fp; int c; fp = fopen(\"file.txt\",\"r\"); while(1) { c = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", c); } fclose(fp); return(0); } 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/ftell.html":{"url":"include/stdio.h/ftell.html","title":"long int ftell(FILE *stream)","keywords":"","body":"long int ftell(FILE *stream) 描述 C 库函数 long int ftell(FILE *stream) 返回给定流 stream 的当前文件位置。 声明 下面是 ftell() 函数的声明。 long int ftell(FILE *stream) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 返回值 该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值。 实例 下面的实例演示了 ftell() 函数的用法。 #include int main () { FILE *fp; int len; fp = fopen(\"file.txt\", \"r\"); if( fp == NULL ) { perror (\"打开文件错误\"); return(-1); } fseek(fp, 0, SEEK_END); len = ftell(fp); fclose(fp); printf(\"file.txt 的总大小 = %d 字节\\n\", len); return(0); } 假设我们有一个文本文件 file.txt，它的内容如下： This is runoob.com 让我们编译并运行上面的程序，如果文件内容如上所示，这将产生以下结果，否则会根据文件内容给出不同的结果： file.txt 的总大小 = 19 字节 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/fwrite.html":{"url":"include/stdio.h/fwrite.html","title":"size_t fwrite(const void ptr, size_t size, size_t nmemb, FILE stream)","keywords":"","body":"size_t fwrite(const void ptr, size_t size, size_t nmemb, FILE stream) 描述 C 库函数 size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 把 ptr 所指向的数组中的数据写入到给定流 stream 中。 声明 下面是 fwrite() 函数的声明。 size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 参数 ptr -- 这是指向要被写入的元素数组的指针。 size -- 这是要被写入的每个元素的大小，以字节为单位。 nmemb -- 这是元素的个数，每个元素的大小为 size 字节。 stream -- 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。 返回值 如果成功，该函数返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误。 实例 下面的实例演示了 fwrite() 函数的用法。 #include int main () { FILE *fp; char str[] = \"This is runoob.com\"; fp = fopen( \"file.txt\" , \"w\" ); fwrite(str, sizeof(str) , 1, fp ); fclose(fp); return(0); } 让我们编译并运行上面的程序，这将创建一个文件 file.txt，它的内容如下： This is runoob.com 现在让我们使用下面的程序查看上面文件的内容： #include int main () { FILE *fp; int c; fp = fopen(\"file.txt\",\"r\"); while(1) { c = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", c); } fclose(fp); return(0); } 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/remove.html":{"url":"include/stdio.h/remove.html","title":"int remove(const char *filename)","keywords":"","body":"int remove(const char *filename) 描述 C 库函数 int remove(const char *filename) 删除给定的文件名 filename，以便它不再被访问。 声明 下面是 remove() 函数的声明。 int remove(const char *filename) 参数 filename -- 这是 C 字符串，包含了要被删除的文件名称。 返回值 如果成功，则返回零。如果错误，则返回 -1，并设置 errno。 实例 下面的实例演示了 remove() 函数的用法。 #include #include int main () { int ret; FILE *fp; char filename[] = \"file.txt\"; fp = fopen(filename, \"w\"); fprintf(fp, \"%s\", \"这里是 runoob.com\"); fclose(fp); ret = remove(filename); if(ret == 0) { printf(\"文件删除成功\"); } else { printf(\"错误：不能删除该文件\"); } return(0); } 假设我们有一个文本文件 file.txt，它的内容如下。我们将使用上面的程序来删除该文件。让我们编译并运行上面的程序，这将生成下面的消息，且文件被永久删除。 文件删除成功 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/rename.html":{"url":"include/stdio.h/rename.html","title":"int rename(const char old_filename, const char new_filename)","keywords":"","body":"int rename(const char old_filename, const char new_filename) 描述 C 库函数 int rename(const char *old_filename, const char *new_filename) 把 old_filename 所指向的文件名改为 new_filename。 声明 下面是 rename() 函数的声明。 int rename(const char *old_filename, const char *new_filename) 参数 old_filename -- 这是 C 字符串，包含了要被重命名/移动的文件名称。 new_filename -- 这是 C 字符串，包含了文件的新名称。 返回值 如果成功，则返回零。如果错误，则返回 -1，并设置 errno。 实例 下面的实例演示了 rename() 函数的用法。 #include int main () { int ret; char oldname[] = \"file.txt\"; char newname[] = \"newfile.txt\"; ret = rename(oldname, newname); if(ret == 0) { printf(\"文件重命名成功\"); } else { printf(\"错误：不能重命名该文件\"); } return(0); } 假设我们有一个文本文件 file.txt，它的内容如下。我们将使用上面的程序来重命名该文件。让我们编译并运行上面的程序，这将生成下面的消息，且文件被重命名为 newfile.txt 文件。 文件重命名成功 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/rewind.html":{"url":"include/stdio.h/rewind.html","title":"void rewind(FILE *stream)","keywords":"","body":"void rewind(FILE *stream) 描述 C 库函数 void rewind(FILE *stream) 设置文件位置为给定流 stream 的文件的开头。 声明 下面是 rewind() 函数的声明。 void rewind(FILE *stream) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 返回值 该函数不返回任何值。 实例 下面的实例演示了 rewind() 函数的用法。 #include int main() { char str[] = \"This is runoob.com\"; FILE *fp; int ch; /* 首先让我们在文件中写入一些内容 */ fp = fopen( \"file.txt\" , \"w\" ); fwrite(str , 1 , sizeof(str) , fp ); fclose(fp); fp = fopen( \"file.txt\" , \"r\" ); while(1) { ch = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", ch); } rewind(fp); printf(\"\\n\"); while(1) { ch = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", ch); } fclose(fp); return(0); } 假设我们有一个文本文件 file.txt，它的内容如下： This is runoob.com 让我们编译并运行上面的程序，这将产生以下结果： This is runoob.com This is runoob.com 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/setbuf.html":{"url":"include/stdio.h/setbuf.html","title":"void setbuf(FILE stream, char buffer)","keywords":"","body":"void setbuf(FILE stream, char buffer) 描述 C 库函数 void setbuf(FILE *stream, char *buffer) 定义流 stream 应如何缓冲。该函数应在与流 stream 相关的文件被打开时，且还未发生任何输入或输出操作之前被调用一次。 声明 下面是 setbuf() 函数的声明。 void setbuf(FILE *stream, char *buffer) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。 buffer -- 这是分配给用户的缓冲，它的长度至少为 BUFSIZ 字节，BUFSIZ 是一个宏常量，表示数组的长度。 返回值 该函数不返回任何值。 实例 下面的实例演示了 setbuf() 函数的用法。 #include int main() { char buf[BUFSIZ]; setbuf(stdout, buf); puts(\"This is runoob\"); fflush(stdout); return(0); } 让我们编译并运行上面的程序，这将产生以下结果。在这里，程序在即将输出的时候，发送输出到 STDOUT，否则它将缓冲输出。您也可以使用 fflush() 函数来 to 刷新输出。 This is runoob 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/setvbuf.html":{"url":"include/stdio.h/setvbuf.html","title":"int setvbuf(FILE stream, char buffer, int mode, size_t size)","keywords":"","body":"int setvbuf(FILE stream, char buffer, int mode, size_t size) 描述 C 库函数 int setvbuf(FILE *stream, char *buffer, int mode, size_t size) 定义流 stream 应如何缓冲。 声明 下面是 setvbuf() 函数的声明。 int setvbuf(FILE *stream, char *buffer, int mode, size_t size) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。 buffer -- 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。 mode -- 这指定了文件缓冲的模式： 模式 描述 _IOFBF 全缓冲：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。 _IOLBF 行缓冲：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。 _IONBF 无缓冲：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。 size --这是缓冲的大小，以字节为单位。 返回值 如果成功，则该函数返回 0，否则返回非零值。 实例 下面的实例演示了 setvbuf() 函数的用法。 #include int main() { char buff[1024]; memset( buff, '\\0', sizeof( buff )); fprintf(stdout, \"启用全缓冲\\n\"); setvbuf(stdout, buff, _IOFBF, 1024); fprintf(stdout, \"这里是 runoob.com\\n\"); fprintf(stdout, \"该输出将保存到 buff\\n\"); fflush( stdout ); fprintf(stdout, \"这将在编程时出现\\n\"); fprintf(stdout, \"最后休眠五秒钟\\n\"); sleep(5); return(0); } 让我们编译并运行上面的程序，这将产生以下结果。在这里，程序把缓冲输出保存到 buff，直到首次调用 fflush() 为止，然后开始缓冲输出，最后休眠 5 秒钟。它会在程序结束之前，发送剩余的输出到 STDOUT。 启用全缓冲 这里是 runoob.com 该输出将保存到 buff 这将在编程时出现 最后休眠五秒钟 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/*tmpfile.html":{"url":"include/stdio.h/*tmpfile.html","title":"FILE *tmpfile(void)","keywords":"","body":"FILE *tmpfile(void) 描述 C 库函数 FILE *tmpfile(void) 以二进制更新模式(wb+)创建临时文件。被创建的临时文件会在流关闭的时候或者在程序终止的时候自动删除。 声明 下面是 tmpfile() 函数的声明。 FILE *tmpfile(void) 参数 NA 返回值 如果成功，该函数返回一个指向被创建的临时文件的流指针。如果文件未被创建，则返回 NULL。 实例 下面的实例演示了 tmpfile() 函数的用法。 #include int main () { FILE *fp; fp = tmpfile(); printf(\"临时文件被创建\\n\"); /* 您可以在这里使用临时文件 */ fclose(fp); return(0); } 让我们编译并运行上面的程序，它将在 /tmp 文件夹中创建一个临时文件，但是一旦程序退出，临时文件会被自动删除，且程序会产生以下结果： 临时文件被创建 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/*tmpnam.html":{"url":"include/stdio.h/*tmpnam.html","title":"char tmpnam(char str)","keywords":"","body":"char *tmpnam(char str) 描述 C 库函数 char *tmpnam(char *str) 生成并返回一个有效的临时文件名，该文件名之前是不存在的。如果 str 为空，则只会返回临时文件名。 声明 下面是 tmpnam() 函数的声明。 char *tmpnam(char *str) 参数 str -- 这是一个指向字符数组的指针，其中，临时文件名将被存储为 C 字符串。 返回值 一个指向 C 字符串的指针，该字符串存储了临时文件名。如果 str 是一个空指针，则该指针指向一个内部缓冲区，缓冲区在下一次调用函数时被覆盖。 如果 str 不是一个空指针，则返回 str。如果函数未能成功创建可用的文件名，则返回一个空指针。 实例 下面的实例演示了 tmpnam() 函数的用法。 #include int main() { char buffer[L_tmpnam]; char *ptr; tmpnam(buffer); printf(\"临时名称 1: %s\\n\", buffer); ptr = tmpnam(NULL); printf(\"临时名称 2: %s\\n\", ptr); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 临时名称 1: /tmp/filebaalTb 临时名称 2: /tmp/filedCIbb0 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/fprintf.html":{"url":"include/stdio.h/fprintf.html","title":"int fprintf(FILE stream, const char format, ...)","keywords":"","body":"int fprintf(FILE stream, const char format, ...) 描述 C 库函数 int fprintf(FILE *stream, const char *format, ...) 发送格式化输出到流 stream 中。 声明 下面是 fprintf() 函数的声明。 int fprintf(FILE *stream, const char *format, ...) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 format -- 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 %[flags][width][.precision][length]specifier，具体讲解如下： specifier（说明符） 输出 c 字符 d 或 i 有符号十进制整数 e 使用 e 字符的科学科学记数法（尾数和指数） E 使用 E 字符的科学科学记数法（尾数和指数） f 十进制浮点数 g 自动选择 %e 或 %f 中合适的表示法 G 自动选择 %E 或 %f 中合适的表示法 o 有符号八进制 s 字符的字符串 u 无符号十进制整数 x 无符号十六进制整数 X 无符号十六进制整数（大写字母） p 指针地址 n 无输出 % 字符 flags（标识） 描述 - 在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。 + 强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。 (space) 如果没有写入任何符号，则在该值前面插入一个空格。 # 与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。 0 在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。 width（宽度） 描述 (number) 要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。 * 宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 .precision（精度） 描述 .number 对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。 .* 精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 length（长度） 描述 h 参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。 l 参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。 L 参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。 附加参数 -- 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。 返回值 如果成功，则返回写入的字符总数，否则返回一个负数。 实例 下面的实例演示了 fprintf() 函数的用法。 #include #include int main() { FILE * fp; fp = fopen (\"file.txt\", \"w+\"); fprintf(fp, \"%s %s %s %d\", \"We\", \"are\", \"in\", 2014); fclose(fp); return(0); } 让我们编译并运行上面的程序，这将创建文件 file.txt，它的内容如下： We are in 2014 现在让我们使用下面的程序查看上面文件的内容： #include int main () { FILE *fp; int c; fp = fopen(\"file.txt\",\"r\"); while(1) { c = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", c); } fclose(fp); return(0); } 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/printf.html":{"url":"include/stdio.h/printf.html","title":"int printf(const char *format, ...)","keywords":"","body":"int printf(const char *format, ...) 描述 C 库函数 int printf(const char *format, ...) 发送格式化输出到标准输出 stdout。 printf()函数的调用格式为: printf(\"\", ); 声明 下面是 printf() 函数的声明。 int printf(const char *format, ...) 参数 format -- 这是字符串，包含了要被写入到标准输出 stdout 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 %[flags][width][.precision][length]specifier，具体讲解如下： 格式字符 意义 d 以十进制形式输出带符号整数(正数不输出符号) o 以八进制形式输出无符号整数(不输出前缀0) x,X 以十六进制形式输出无符号整数(不输出前缀Ox) u 以十进制形式输出无符号整数 f 以小数形式输出单、双精度实数 e,E 以指数形式输出单、双精度实数 g,G 以%f或%e中较短的输出宽度输出单、双精度实数 c 输出单个字符 s 输出字符串 p 输出指针地址 lu 32位无符号整数 llu 64位无符号整数 flags（标识） 描述 - 在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。 + 强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。 空格 如果没有写入任何符号，则在该值前面插入一个空格。 # 与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。 0 在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。 width（宽度） 描述 (number) 要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。 * 宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 .precision（精度） 描述 .number 对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。 .* 精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 length（长度） 描述 h 参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。 l 参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。 L 参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。 附加参数 -- 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。 返回值 如果成功，则返回写入的字符总数，否则返回一个负数。 实例 下面的实例演示了 printf() 函数的用法。 #include int main () { int ch; for( ch = 75 ; ch 让我们编译并运行上面的程序，这将产生以下结果： ASCII 值 = 75, 字符 = K ASCII 值 = 76, 字符 = L ASCII 值 = 77, 字符 = M ASCII 值 = 78, 字符 = N ASCII 值 = 79, 字符 = O ASCII 值 = 80, 字符 = P ASCII 值 = 81, 字符 = Q ASCII 值 = 82, 字符 = R ASCII 值 = 83, 字符 = S ASCII 值 = 84, 字符 = T ASCII 值 = 85, 字符 = U ASCII 值 = 86, 字符 = V ASCII 值 = 87, 字符 = W ASCII 值 = 88, 字符 = X ASCII 值 = 89, 字符 = Y ASCII 值 = 90, 字符 = Z ASCII 值 = 91, 字符 = [ ASCII 值 = 92, 字符 = \\ ASCII 值 = 93, 字符 = ] ASCII 值 = 94, 字符 = ^ ASCII 值 = 95, 字符 = _ ASCII 值 = 96, 字符 = ` ASCII 值 = 97, 字符 = a ASCII 值 = 98, 字符 = b ASCII 值 = 99, 字符 = c ASCII 值 = 100, 字符 = d 以下实例输出各种格式化数据： #include int main() { char ch = 'A'; char str[20] = \"www.runoob.com\"; float flt = 10.234; int no = 150; double dbl = 20.123456; printf(\"字符为 %c \\n\", ch); printf(\"字符串为 %s \\n\" , str); printf(\"浮点数为 %f \\n\", flt); printf(\"整数为 %d\\n\" , no); printf(\"双精度值为 %lf \\n\", dbl); printf(\"八进制值为 %o \\n\", no); printf(\"十六进制值为 %x \\n\", no); return 0; } 执行输出结果为： 字符为 A 字符串为 www.runoob.com 浮点数为 10.234000 整数为 150 双精度值为 20.123456 八进制值为 226 十六进制值为 96 规定符 %d 十进制有符号整数 %u 十进制无符号整数 %f 浮点数 %s 字符串 %c 单个字符 %p 指针的值 %e 指数形式的浮点数 %x, %X 无符号以十六进制表示的整数 %o 无符号以八进制表示的整数 %g 把输出的值按照 %e 或者 %f 类型中输出长度较小的方式输出 %p 输出地址符 %lu 32位无符号整数 %llu 64位无符号整数 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/sprintf.html":{"url":"include/stdio.h/sprintf.html","title":"int sprintf(char str, const char format, ...)","keywords":"","body":"int sprintf(char str, const char format, ...) 描述 C 库函数 int sprintf(char *str, const char *format, ...) 发送格式化输出到 str 所指向的字符串。 声明 下面是 sprintf() 函数的声明。 int sprintf(char *str, const char *format, ...) 参数 str -- 这是指向一个字符数组的指针，该数组存储了 C 字符串。 format -- 这是字符串，包含了要被写入到字符串 str 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 %[flags][width][.precision][length]specifier，具体讲解如下： specifier（说明符） 输出 c 字符 d 或 i 有符号十进制整数 e 使用 e 字符的科学科学记数法（尾数和指数） E 使用 E 字符的科学科学记数法（尾数和指数） f 十进制浮点数 g 自动选择 %e 或 %f 中合适的表示法 G 自动选择 %E 或 %f 中合适的表示法 o 有符号八进制 s 字符的字符串 u 无符号十进制整数 x 无符号十六进制整数 X 无符号十六进制整数（大写字母） p 指针地址 n 无输出 % 字符 flags（标识） 描述 - 在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。 + 强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。 (space) 如果没有写入任何符号，则在该值前面插入一个空格。 # 与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。 0 在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。 width（宽度） 描述 (number) 要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。 * 宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 .precision（精度） 描述 .number 对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。 .* 精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 length（长度） 描述 h 参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。 l 参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。 L 参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。 附加参数 -- 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。 返回值 如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。 实例 下面的实例演示了 sprintf() 函数的用法。 #include #include int main() { char str[80]; sprintf(str, \"Pi 的值 = %f\", M_PI); puts(str); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： Pi 的值 = 3.141593 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/vfprintf.html":{"url":"include/stdio.h/vfprintf.html","title":"int vfprintf(FILE stream, const char format, va_list arg)","keywords":"","body":"int vfprintf(FILE stream, const char format, va_list arg) 描述 C 库函数 int vfprintf(FILE *stream, const char *format, va_list arg) 使用参数列表发送格式化输出到流 stream 中。 声明 下面是 vfprintf() 函数的声明。 int vfprintf(FILE *stream, const char *format, va_list arg) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 format -- 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 %[flags][width][.precision][length]specifier，具体讲解如下： specifier（说明符） 输出 c 字符 d 或 i 有符号十进制整数 e 使用 e 字符的科学科学记数法（尾数和指数） E 使用 E 字符的科学科学记数法（尾数和指数） f 十进制浮点数 g 自动选择 %e 或 %f 中合适的表示法 G 自动选择 %E 或 %f 中合适的表示法 o 有符号八进制 s 字符的字符串 u 无符号十进制整数 x 无符号十六进制整数 X 无符号十六进制整数（大写字母） p 指针地址 n 无输出 % 字符 flags（标识） 描述 - 在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。 + 强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。 (space) 如果没有写入任何符号，则在该值前面插入一个空格。 # 与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。 0 在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。 width（宽度） 描述 (number) 要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。 * 宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 .precision（精度） 描述 .number 对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。 .* 精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 length（长度） 描述 h 参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。 l 参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。 L 参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。 arg -- 一个表示可变参数列表的对象。这应被 中定义的 va_start 宏初始化。 返回值 如果成功，则返回写入的字符总数，否则返回一个负数。 实例 下面的实例演示了 vfprintf() 函数的用法。 #include #include void WriteFrmtd(FILE *stream, char *format, ...) { va_list args; va_start(args, format); vfprintf(stream, format, args); va_end(args); } int main () { FILE *fp; fp = fopen(\"file.txt\",\"w\"); WriteFrmtd(fp, \"This is just one argument %d \\n\", 10); fclose(fp); return(0); } 让我们编译并运行上面的程序，这将打开当前目录中的文件 file.txt，并写入以下内容： This is just one argument 10 现在让我们使用下面的程序查看上面文件的内容： #include int main () { FILE *fp; int c; fp = fopen(\"file.txt\",\"r\"); while(1) { c = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", c); } fclose(fp); return(0); } 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/vprintf.html":{"url":"include/stdio.h/vprintf.html","title":"int vprintf(const char *format, va_list arg)","keywords":"","body":"int vprintf(const char *format, va_list arg) 描述 C 库函数 int vprintf(const char *format, va_list arg) 使用参数列表发送格式化输出到标准输出 stdout。 声明 下面是 vprintf() 函数的声明。 int vprintf(const char *format, va_list arg) 参数 format -- 这是字符串，包含了要被写入到标准输出 stdout 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 %[flags][width][.precision][length]specifier，具体讲解如下： specifier（说明符） 输出 c 字符 d 或 i 有符号十进制整数 e 使用 e 字符的科学科学记数法（尾数和指数） E 使用 E 字符的科学科学记数法（尾数和指数） f 十进制浮点数 g 自动选择 %e 或 %f 中合适的表示法 G 自动选择 %E 或 %f 中合适的表示法 o 有符号八进制 s 字符的字符串 u 无符号十进制整数 x 无符号十六进制整数 X 无符号十六进制整数（大写字母） p 指针地址 n 无输出 % 字符 flags（标识） 描述 - 在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。 + 强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。 (space) 如果没有写入任何符号，则在该值前面插入一个空格。 # 与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。 0 在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。 width（宽度） 描述 (number) 要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。 * 宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 .precision（精度） 描述 .number 对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。 .* 精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 length（长度） 描述 h 参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。 l 参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。 L 参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。 arg -- 一个表示可变参数列表的对象。这应被 中定义的 va_start 宏初始化。 返回值 如果成功，则返回写入的字符总数，否则返回一个负数。 实例 下面的实例演示了 vprintf() 函数的用法。 #include #include void WriteFrmtd(char *format, ...) { va_list args; va_start(args, format); vprintf(format, args); va_end(args); } int main () { WriteFrmtd(\"%d variable argument\\n\", 1); WriteFrmtd(\"%d variable %s\\n\", 2, \"arguments\"); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 1 variable argument 2 variable arguments 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/vsprintf.html":{"url":"include/stdio.h/vsprintf.html","title":"int vsprintf(char str, const char format, va_list arg)","keywords":"","body":"int vsprintf(char str, const char format, va_list arg) 描述 C 库函数 int vsprintf(char *str, const char *format, va_list arg) 使用参数列表发送格式化输出到字符串。 声明 下面是 vsprintf() 函数的声明。 int vsprintf(char *str, const char *format, va_list arg) 参数 str -- 这是指向一个字符数组的指针，该数组存储了 C 字符串。 format -- 这是字符串，包含了要被写入到字符串 str 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 %[flags][width][.precision][length]specifier，具体讲解如下： specifier（说明符） 输出 c 字符 d 或 i 有符号十进制整数 e 使用 e 字符的科学科学记数法（尾数和指数） E 使用 E 字符的科学科学记数法（尾数和指数） f 十进制浮点数 g 自动选择 %e 或 %f 中合适的表示法 G 自动选择 %E 或 %f 中合适的表示法 o 有符号八进制 s 字符的字符串 u 无符号十进制整数 x 无符号十六进制整数 X 无符号十六进制整数（大写字母） p 指针地址 n 无输出 % 字符 flags（标识） 描述 - 在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。 + 强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。 (space) 如果没有写入任何符号，则在该值前面插入一个空格。 # 与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。 0 在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。 width（宽度） 描述 (number) 要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。 * 宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 .precision（精度） 描述 .number 对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。 .* 精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 length（长度） 描述 h 参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。 l 参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。 L 参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。 arg -- 一个表示可变参数列表的对象。这应被 中定义的 va_start 宏初始化。 返回值 如果成功，则返回写入的字符总数，否则返回一个负数。 实例 下面的实例演示了 vsprintf() 函数的用法。 #include #include char buffer[80]; int vspfunc(char *format, ...) { va_list aptr; int ret; va_start(aptr, format); ret = vsprintf(buffer, format, aptr); va_end(aptr); return(ret); } int main() { int i = 5; float f = 27.0; char str[50] = \"runoob.com\"; vspfunc(\"%d %f %s\", i, f, str); printf(\"%s\\n\", buffer); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 5 27.000000 runoob.com 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/fscanf.html":{"url":"include/stdio.h/fscanf.html","title":"int fscanf(FILE stream, const char format, ...)","keywords":"","body":"int fscanf(FILE stream, const char format, ...) 描述 C 库函数 int fscanf(FILE *stream, const char *format, ...) 从流 stream 读取格式化输入。 声明 下面是 fscanf() 函数的声明。 int fscanf(FILE *stream, const char *format, ...) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 format -- 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。 format 说明符形式为 [=%[*][width][modifiers]type=]，具体讲解如下： 参数 描述 * 这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。 width 这指定了在当前读取操作中读取的最大字符数。 modifiers 为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g） type 一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格。 fscanf 类型说明符： 类型 合格的输入 参数的类型 c 单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。 char * d 十进制整数：数字前面的 + 或 - 号是可选的。 int * e,E,f,g,G 浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4 float * o 八进制整数。 int * s 字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。 char * u 无符号的十进制整数。 unsigned int * x,X 十六进制整数。 int * 附加参数 -- 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。 返回值 如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。 实例 下面的实例演示了 fscanf() 函数的用法。 #include #include int main() { char str1[10], str2[10], str3[10]; int year; FILE * fp; fp = fopen (\"file.txt\", \"w+\"); fputs(\"We are in 2014\", fp); rewind(fp); fscanf(fp, \"%s %s %s %d\", str1, str2, str3, &year); printf(\"Read String1 |%s|\\n\", str1 ); printf(\"Read String2 |%s|\\n\", str2 ); printf(\"Read String3 |%s|\\n\", str3 ); printf(\"Read Integer |%d|\\n\", year ); fclose(fp); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： Read String1 |We| Read String2 |are| Read String3 |in| Read Integer |2014| 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/scanf.html":{"url":"include/stdio.h/scanf.html","title":"int scanf(const char *format, ...)","keywords":"","body":"int scanf(const char *format, ...) 描述 C 库函数 int scanf(const char *format, ...) 从标准输入 stdin 读取格式化输入。 声明 下面是 scanf() 函数的声明。 int scanf(const char *format, ...) 参数 format -- 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。 format 说明符形式为: [=%[*][width][modifiers]type=] 具体讲解如下： 参数 描述 * 这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。 width 这指定了在当前读取操作中读取的最大字符数。 modifiers 为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g） type 一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格。 scanf 类型说明符： 类型 合格的输入 参数的类型 %a、%A 读入一个浮点值(仅 C99 有效)。 float * %c 单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。 char * %d 十进制整数：数字前面的 + 或 - 号是可选的。 int * %e、%E、%f、%F、%g、%G 浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4 float * %i 读入十进制，八进制，十六进制整数 。 int * %o 八进制整数。 int * %s 字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。 char * %u 无符号的十进制整数。 unsigned int * %x、%X 十六进制整数。 int * %p 读入一个指针 。 %[] 扫描字符集合 。 %% 读 % 符号。 附加参数 -- 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。 返回值 如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。 实例 下面的实例演示了 scanf() 函数的用法。 #include int main(void) { int a,b,c; printf(\"请输入三个数字：\"); scanf(\"%d%d%d\",&a,&b,&c); printf(\"%d,%d,%d\\n\",a,b,c); return 0; } 让我们编译并运行上面的程序，这将在交互模式下产生以下结果： 请输入三个数字：1 2 3 1,2,3 解析说明： 1、&a、&b、&c 中的 & 是地址运算符，分别获得这三个变量的内存地址。 2、%d%d%d 是按十进值格式输入三个数值。输入时，在两个数据之间可以用一个或多个空格、tab 键、回车键分隔。 如果使用 , 来分隔输入的 %d, 相应的输入时也需要添加 ,: #include int main(void) { int a,b,c; printf(\"请输入三个数字：\"); scanf(\"%d, %d, %d\",&a,&b,&c); printf(\"%d, %d, %d\\n\",a,b,c); return 0; } 让我们编译并运行上面的程序，这将在交互模式下产生以下结果： 请输入三个数字：1, 2, 3 1, 2, 3 注意：输入时 , 前一定要紧跟在数字后面，数字与 , 之间不能有空格。 在用 %c 输入时，空格和\"转义字符\"均作为有效字符。 #include int main(void) { char a,b,c; printf(\"请输入三个字符：\"); scanf(\"%c%c%c\",&a,&b,&c); printf(\"%c,%c,%c\\n\", a,b,c); return 0; } 让我们编译并运行上面的程序，这将在交互模式下产生以下结果： $ ./a.out 请输入三个字符：run r,u,n $ ./a.out 请输入三个字符：r u n r, ,u 以下实例演示的是接收字符串： #include int main() { char str1[20], str2[30]; printf(\"请输入用户名：\"); scanf(\"%s\", str1); printf(\"请输入您的网站：\"); scanf(\"%s\", str2); printf(\"输入的用户名：%s\\n\", str1); printf(\"输入的网站：%s\", str2); return(0); } 让我们编译并运行上面的程序，这将在交互模式下产生以下结果： 请输入用户名：admin 请输入您的网站：www.runoob.com 输入的用户名：admin 输入的网站：www.runoob.com 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/sscanf.html":{"url":"include/stdio.h/sscanf.html","title":"int sscanf(const char str, const char format, ...)","keywords":"","body":"int sscanf(const char str, const char format, ...) 描述 C 库函数 int sscanf(const char *str, const char *format, ...) 从字符串读取格式化输入。 声明 下面是 sscanf() 函数的声明。 int sscanf(const char *str, const char *format, ...) 参数 str -- 这是 C 字符串，是函数检索数据的源。 format -- 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。 format 说明符形式为 [=%[*][width][modifiers]type=]，具体讲解如下： 参数 描述 * 这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。 width 这指定了在当前读取操作中读取的最大字符数。 modifiers 为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g） type 一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格。 sscanf 类型说明符： 类型 合格的输入 参数的类型 c 单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。 char * d 十进制整数：数字前面的 + 或 - 号是可选的。 int * e,E,f,g,G 浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4 float * o 八进制整数。 int * s 字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。 char * u 无符号的十进制整数。 unsigned int * x,X 十六进制整数。 int * 附加参数 -- 这个函数接受一系列的指针作为附加参数，每一个指针都指向一个对象，对象类型由 format 字符串中相应的 % 标签指定，参数与 % 标签的顺序相同。 针对检索数据的 format 字符串中的每个 format 说明符，应指定一个附加参数。如果您想要把 sscanf 操作的结果存储在一个普通的变量中，您应该在标识符前放置引用运算符（&），例如： int n; sscanf (str,\"%d\",&amp;n); 返回值 如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。 实例 下面的实例演示了 sscanf() 函数的用法。 #include #include #include int main() { int day, year; char weekday[20], month[20], dtm[100]; strcpy( dtm, \"Saturday March 25 1989\" ); sscanf( dtm, \"%s %s %d %d\", weekday, month, &day, &year ); printf(\"%s %d, %d = %s\\n\", month, day, year, weekday ); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： March 25, 1989 = Saturday 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/fgetc.html":{"url":"include/stdio.h/fgetc.html","title":"int fgetc(FILE *stream)","keywords":"","body":"int fgetc(FILE *stream) 描述 C 库函数 int fgetc(FILE *stream) 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。 声明 下面是 fgetc() 函数的声明。 int fgetc(FILE *stream) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了要在上面执行操作的流。 返回值 该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF。 实例 下面的实例演示了 fgetc() 函数的用法。 #include int main () { FILE *fp; int c; int n = 0; fp = fopen(\"file.txt\",\"r\"); if(fp == NULL) { perror(\"打开文件时发生错误\"); return(-1); } do { c = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", c); }while(1); fclose(fp); return(0); } 假设我们有一个文本文件 file.txt，它的内容如下。文件将作为实例中的输入： We are in 2014 让我们编译并运行上面的程序，这将产生以下结果： We are in 2014 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/*fgets.html":{"url":"include/stdio.h/*fgets.html","title":"char fgets(char str, int n, FILE *stream)","keywords":"","body":"char fgets(char str, int n, FILE stream) 描述 C 库函数 char *fgets(char str, int n, FILE stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。 声明 下面是 fgets() 函数的声明。 char *fgets(char *str, int n, FILE *stream) 参数 str -- 这是指向一个字符数组的指针，该数组存储了要读取的字符串。 n -- 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。 返回值 如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。 如果发生错误，返回一个空指针。 实例 下面的实例演示了 fgets() 函数的用法。 #include int main() { FILE *fp; char str[60]; /* 打开用于读取的文件 */ fp = fopen(\"file.txt\" , \"r\"); if(fp == NULL) { perror(\"打开文件时发生错误\"); return(-1); } if( fgets (str, 60, fp)!=NULL ) { /* 向标准输出 stdout 写入内容 */ puts(str); } fclose(fp); return(0); } 假设我们有一个文本文件 file.txt，它的内容如下。文件将作为实例中的输入： We are in 2014 让我们编译并运行上面的程序，这将产生以下结果： We are in 2014 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/fputc.html":{"url":"include/stdio.h/fputc.html","title":"int fputc(int char, FILE *stream)","keywords":"","body":"int fputc(int char, FILE *stream) 描述 C 库函数 int fputc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。 声明 下面是 fputc() 函数的声明。 int fputc(int char, FILE *stream) 参数 char -- 这是要被写入的字符。该字符以其对应的 int 值进行传递。 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符的流。 返回值 如果没有发生错误，则返回被写入的字符。如果发生错误，则返回 EOF，并设置错误标识符。 实例 下面的实例演示了 fputc() 函数的用法。 #include int main () { FILE *fp; int ch; fp = fopen(\"file.txt\", \"w+\"); for( ch = 33 ; ch ?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcd */ 现在让我们使用下面的程序查看上面文件的内容： #include int main () { FILE *fp; int c; fp = fopen(\"file.txt\",\"r\"); while(1) { c = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", c); } fclose(fp); return(0); } 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/fputs.html":{"url":"include/stdio.h/fputs.html","title":"int fputs(const char str, FILE stream)","keywords":"","body":"int fputs(const char str, FILE stream) 描述 C 库函数 int fputs(const char *str, FILE *stream) 把字符串写入到指定的流 stream 中，但不包括空字符。 声明 下面是 fputs() 函数的声明。 int fputs(const char *str, FILE *stream) 参数 str -- 这是一个数组，包含了要写入的以空字符终止的字符序列。 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流。 返回值 该函数返回一个非负值，如果发生错误则返回 EOF。 实例 下面的实例演示了 fputs() 函数的用法。 #include int main () { FILE *fp; fp = fopen(\"file.txt\", \"w+\"); fputs(\"这是 C 语言。\", fp); fputs(\"这是一种系统程序设计语言。\", fp); fclose(fp); return(0); } 让我们编译并运行上面的程序，这将创建文件 file.txt，它的内容如下： 这是 C 语言。这是一种系统程序设计语言。 现在让我们使用下面的程序查看上面文件的内容： #include int main () { FILE *fp; int c; fp = fopen(\"file.txt\",\"r\"); while(1) { c = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", c); } fclose(fp); return(0); } 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/getc.html":{"url":"include/stdio.h/getc.html","title":"int getc(FILE *stream)","keywords":"","body":"int getc(FILE *stream) 描述 C 库函数 int getc(FILE *stream) 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。 声明 下面是 getc() 函数的声明。 int getc(FILE *stream) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了要在上面执行操作的流。 返回值 该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF。 实例 下面的实例演示了 getc() 函数的用法。 #include int main() { char c; printf(\"请输入字符：\"); c = getc(stdin); printf(\"输入的字符：\"); putc(c, stdout); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 请输入字符：a 输入的字符：a 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/getchar.html":{"url":"include/stdio.h/getchar.html","title":"int getchar(void)","keywords":"","body":"int getchar(void) 描述 C 库函数 int getchar(void) 从标准输入 stdin 获取一个字符（一个无符号字符）。这等同于 getc 带有 stdin 作为参数。 声明 下面是 getchar() 函数的声明。 int getchar(void) 参数 NA 返回值 该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF。 实例 下面的实例演示了 getchar() 函数的用法。 #include int main () { char c; printf(\"请输入字符：\"); c = getchar(); printf(\"输入的字符：\"); putchar(c); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 请输入字符：a 输入的字符：a 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/*gets.html":{"url":"include/stdio.h/*gets.html","title":"char gets(char str)","keywords":"","body":"char *gets(char str) 描述 C 库函数 char *gets(char *str) 从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。 声明 下面是 gets() 函数的声明。 char *gets(char *str) 参数 str -- 这是指向一个字符数组的指针，该数组存储了 C 字符串。 返回值 如果成功，该函数返回 str。如果发生错误或者到达文件末尾时还未读取任何字符，则返回 NULL。 实例 下面的实例演示了 gets() 函数的用法。 #include int main() { char str[50]; printf(\"请输入一个字符串：\"); gets(str); printf(\"您输入的字符串是：%s\", str); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 请输入一个字符串：runoob 您输入的字符串是：runoob 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/putc.html":{"url":"include/stdio.h/putc.html","title":"int putc(int char, FILE *stream)","keywords":"","body":"int putc(int char, FILE *stream) 描述 C 库函数 int putc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。 声明 下面是 putc() 函数的声明。 int putc(int char, FILE *stream) 参数 char -- 这是要被写入的字符。该字符以其对应的 int 值进行传递。 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符的流。 返回值 该函数以无符号 char 强制转换为 int 的形式返回写入的字符，如果发生错误则返回 EOF。 实例 下面的实例演示了 putc() 函数的用法。 #include int main () { FILE *fp; int ch; fp = fopen(\"file.txt\", \"w\"); for( ch = 33 ; ch 让我们编译并运行上面的程序，这将在当前目录中创建文件 file.txt，它的内容如下： !\"#$%&'()*+,-./0123456789:;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcd 现在让我们使用下面的程序查看上面文件的内容： #include int main () { FILE *fp; int c; fp = fopen(\"file.txt\",\"r\"); while(1) { c = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", c); } fclose(fp); return(0); } 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/putchar.html":{"url":"include/stdio.h/putchar.html","title":"int putchar(int char)","keywords":"","body":"int putchar(int char) 描述 C 库函数 int putchar(int char) 把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中。 声明 下面是 putchar() 函数的声明。 int putchar(int char) 参数 char -- 这是要被写入的字符。该字符以其对应的 int 值进行传递。 返回值 该函数以无符号 char 强制转换为 int 的形式返回写入的字符，如果发生错误则返回 EOF。 实例 下面的实例演示了 putchar() 函数的用法。 #include int main () { char ch; for(ch = 'A' ; ch 让我们编译并运行上面的程序，这将产生以下结果： ABCDEFGHIJKLMNOPQRSTUVWXYZ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/puts.html":{"url":"include/stdio.h/puts.html","title":"int puts(const char *str)","keywords":"","body":"int puts(const char *str) 描述 C 库函数 int puts(const char *str) 把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。 声明 下面是 puts() 函数的声明。 int puts(const char *str) 参数 str -- 这是要被写入的 C 字符串。 返回值 如果成功，该函数返回一个非负值，如果发生错误则返回 EOF。 实例 下面的实例演示了 puts() 函数的用法。 #include #include int main() { char str1[15]; char str2[15]; strcpy(str1, \"RUNOOB1\"); strcpy(str2, \"RUNOOB2\"); puts(str1); puts(str2); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： RUNOOB1 RUNOOB2 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/ungetc.html":{"url":"include/stdio.h/ungetc.html","title":"int ungetc(int char, FILE *stream)","keywords":"","body":"int ungetc(int char, FILE *stream) 描述 C 库函数 int ungetc(int char, FILE *stream) 把字符 char（一个无符号字符）推入到指定的流 stream 中，以便它是下一个被读取到的字符。 声明 下面是 ungetc() 函数的声明。 int ungetc(int char, FILE *stream) 参数 char -- 这是要被推入的字符。该字符以其对应的 int 值进行传递。 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了输入流。 返回值 如果成功，则返回被推入的字符，否则返回 EOF，且流 stream 保持不变。 实例 下面的实例演示了 ungetc() 函数的用法。 #include int main () { FILE *fp; int c; char buffer [256]; fp = fopen(\"file.txt\", \"r\"); if( fp == NULL ) { perror(\"打开文件时发生错误\"); return(-1); } while(!feof(fp)) { c = getc (fp); /* 把 ! 替换为 + */ if( c == '!' ) { ungetc ('+', fp); } else { ungetc(c, fp); } fgets(buffer, 255, fp); fputs(buffer, stdout); } return(0); } 假设我们有一个文本文件 file.txt，它的内容如下。文件将作为实例中的输入： this is runoob !c standard library !library functions and macros 让我们编译并运行上面的程序，这将产生以下结果： this is runoob +c standard library +library functions and macros +library functions and macros 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdio.h/perror.html":{"url":"include/stdio.h/perror.html","title":"void perror(const char *str)","keywords":"","body":"void perror(const char *str) 描述 C 库函数 void perror(const char *str) 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格。 声明 下面是 perror() 函数的声明。 void perror(const char *str) 参数 str -- 这是 C 字符串，包含了一个自定义消息，将显示在原本的错误消息之前。 返回值 该函数不返回任何值。 实例 下面的实例演示了 perror() 函数的用法。 #include int main () { FILE *fp; /* 首先重命名文件 */ rename(\"file.txt\", \"newfile.txt\"); /* 现在让我们尝试打开相同的文件 */ fp = fopen(\"file.txt\", \"r\"); if( fp == NULL ) { perror(\"Error: \"); return(-1); } fclose(fp); return(0); } 让我们编译并运行上面的程序，这将产生以下结果，因为我们尝试打开一个不存在的文件： Error: : No such file or directory 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/":{"url":"include/stdlib.h/","title":"stdlib.h","keywords":"","body":"stdlib.h C 标准库 - 简介 stdlib .h 头文件定义了四个变量类型、一些宏和各种通用工具函数。 库变量 下面是头文件 stdlib.h 中定义的变量类型： 序号 变量 & 描述 1 size_t 这是无符号整数类型，它是 sizeof 关键字的结果。 2 wchar_t 这是一个宽字符常量大小的整数类型。 3 div_t 这是 div 函数返回的结构。 4 ldiv_t 这是 ldiv 函数返回的结构。 库宏 下面是头文件 stdlib.h 中定义的宏： 序号 宏 & 描述 1 NULL 这个宏是一个空指针常量的值。 2 EXIT_FAILURE 这是 exit 函数失败时要返回的值。 3 EXIT_SUCCESS 这是 exit 函数成功时要返回的值。 4 RAND_MAX 这个宏是 rand 函数返回的最大值。 5 MB_CUR_MAX 这个宏表示在多字节字符集中的最大字符数，不能大于 MB_LEN_MAX。 库函数 下面是头文件 stdlib.h 中定义的函数： 序号 函数 & 描述 1 double atof(const char *str) 把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。 2 int atoi(const char *str) 把参数 str 所指向的字符串转换为一个整数（类型为 int 型）。 3 long int atol(const char *str) 把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）。 4 double strtod(const char str, char *endptr) 把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。 5 long int strtol(const char str, char *endptr, int base) 把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）。 6 unsigned long int strtoul(const char str, char *endptr, int base) 把参数 str 所指向的字符串转换为一个无符号长整数（类型为 unsigned long int 型）。 7 void *calloc(size_t nitems, size_t size) 分配所需的内存空间，并返回一个指向它的指针。 8 void free(void *ptr) 释放之前调用 calloc、malloc 或 realloc 所分配的内存空间。 9 void *malloc(size_t size) 分配所需的内存空间，并返回一个指向它的指针。 10 void realloc(void ptr, size_t size) 尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小。 11 void abort(void) 使一个异常程序终止。 12 int atexit(void (*func)(void)) 当程序正常终止时，调用指定的函数 func。 13 void exit(int status) 使程序正常终止。 14 char getenv(const char name) 搜索 name 所指向的环境字符串，并返回相关的值给字符串。 15 int system(const char *string) 由 string 指定的命令传给要被命令处理器执行的主机环境。 16 void bsearch(const void key, const void base, size_t nitems, size_t size, int (compar)(const void , const void )) 执行二分查找。 17 void qsort(void base, size_t nitems, size_t size, int (compar)(const void , const void)) 数组排序。 18 int abs(int x) 返回 x 的绝对值。 19 div_t div(int numer, int denom) 分子除以分母。 20 long int labs(long int x) 返回 x 的绝对值。 21 ldiv_t ldiv(long int numer, long int denom) 分子除以分母。 22 int rand(void) 返回一个范围在 0 到 RAND_MAX 之间的伪随机数。 23 void srand(unsigned int seed) 该函数播种由函数 rand 使用的随机数发生器。 24 int mblen(const char *str, size_t n) 返回参数 str 所指向的多字节字符的长度。 25 size_t mbstowcs(schar_t pwcs, const char str, size_t n) 把参数 str 所指向的多字节字符的字符串转换为参数 pwcs 所指向的数组。 26 int mbtowc(whcar_t pwc, const char str, size_t n) 检查参数 str 所指向的多字节字符。 27 size_t wcstombs(char str, const wchar_t pwcs, size_t n) 把数组 pwcs 中存储的编码转换为多字节字符，并把它们存储在字符串 str 中。 28 int wctomb(char *str, wchar_t wchar) 检查对应于参数 wchar 所给出的多字节字符的编码。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/atof.html":{"url":"include/stdlib.h/atof.html","title":"double atof(const char *str)","keywords":"","body":"double atof(const char *str) 描述 C 库函数 double atof(const char *str) 把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。 声明 下面是 atof() 函数的声明。 double atof(const char *str) 参数 str -- 要转换为浮点数的字符串。 返回值 函数返回转换后的双精度浮点数，如果没有执行有效的转换，则返回零（0.0）。 实例 下面的实例演示了 atof() 函数的用法。 #include #include #include int main() { float val; char str[20]; strcpy(str, \"98993489\"); val = atof(str); printf(\"字符串值 = %s, 浮点值 = %f\\n\", str, val); strcpy(str, \"runoob\"); val = atof(str); printf(\"字符串值 = %s, 浮点值 = %f\\n\", str, val); return(0); } //字符串值 = 98993489, 浮点值 = 98993488.000000 //字符串值 = runoob, 浮点值 = 0.000000 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/atoi.html":{"url":"include/stdlib.h/atoi.html","title":"int atoi(const char *str)","keywords":"","body":"int atoi(const char *str) 描述 C 库函数 int atoi(const char *str) 把参数 str 所指向的字符串转换为一个整数（类型为 int 型）。 声明 下面是 atoi() 函数的声明。 int atoi(const char *str) 参数 str -- 要转换为整数的字符串。 返回值 该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。 实例 下面的实例演示了 atoi() 函数的用法。 #include #include #include int main() { int val; char str[20]; strcpy(str, \"98993489\"); val = atoi(str); printf(\"字符串值 = %s, 整型值 = %d\\n\", str, val); strcpy(str, \"runoob.com\"); val = atoi(str); printf(\"字符串值 = %s, 整型值 = %d\\n\", str, val); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 字符串值 = 98993489, 整型值 = 98993489 字符串值 = runoob.com, 整型值 = 0 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/atol.html":{"url":"include/stdlib.h/atol.html","title":"long int atol(const char *str)","keywords":"","body":"long int atol(const char *str) 描述 C 库函数 long int atol(const char *str) 把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）。 声明 下面是 atol() 函数的声明。 long int atol(const char *str) 参数 str -- 要转换为长整数的字符串。 返回值 该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。 实例 下面的实例演示了 atol() 函数的用法。 #include #include #include int main() { long val; char str[20]; strcpy(str, \"98993489\"); val = atol(str); printf(\"字符串值 = %s, 长整型值 = %ld\\n\", str, val); strcpy(str, \"runoob.com\"); val = atol(str); printf(\"字符串值 = %s, 长整型值 = %ld\\n\", str, val); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 字符串值 = 98993489, 长整型值 = 98993489 字符串值 = runoob.com, 长整型值 = 0 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/strtod.html":{"url":"include/stdlib.h/strtod.html","title":"double strtod(const char str, char *endptr)","keywords":"","body":"double strtod(const char str, char *endptr) 描述 C 库函数 double strtod(const char *str, char endptr) 把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。如果 endptr** 不为空，则指向转换中最后一个字符后的字符的指针会存储在 endptr 引用的位置。 声明 下面是 strtod() 函数的声明。 double strtod(const char *str, char **endptr) 参数 str -- 要转换为双精度浮点数的字符串。 endptr -- 对类型为 char 的对象的引用，其值由函数设置为 *str 中数值后的下一个字符。 返回值 该函数返回转换后的双精度浮点数，如果没有执行有效的转换，则返回零（0.0）。 实例 下面的实例演示了 strtod() 函数的用法。 #include #include int main() { char str[30] = \"20.30300 This is test\"; char *ptr; double ret; ret = strtod(str, &ptr); printf(\"数字（double）是 %lf\\n\", ret); printf(\"字符串部分是 |%s|\", ptr); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 数字（double）是 20.303000 字符串部分是 | This is test| 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/strtol.html":{"url":"include/stdlib.h/strtol.html","title":"long int strtol(const char str, char *endptr, int base)","keywords":"","body":"long int strtol(const char str, char *endptr, int base) 描述 C 库函数 long int strtol(const char *str, char endptr, int base) 把参数 str 所指向的字符串根据给定的 base** 转换为一个长整数（类型为 long int 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0。 声明 下面是 strtol() 函数的声明。 long int strtol(const char *str, char **endptr, int base) 参数 str -- 要转换为长整数的字符串。 endptr -- 对类型为 char 的对象的引用，其值由函数设置为 *str 中数值后的下一个字符。 base -- 基数，必须介于 2 和 36（包含）之间，或者是特殊值 0。 返回值 该函数返回转换后的长整数，如果没有执行有效的转换，则返回一个零值。 实例 下面的实例演示了 strtol() 函数的用法。 #include #include int main() { char str[30] = \"2030300 This is test\"; char *ptr; long ret; ret = strtol(str, &ptr, 10); printf(\"数字（无符号长整数）是 %ld\\n\", ret); printf(\"字符串部分是 |%s|\", ptr); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 数字（无符号长整数）是 2030300 字符串部分是 | This is test| 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/strtoul.html":{"url":"include/stdlib.h/strtoul.html","title":"unsigned long int strtoul(const char str, char *endptr, int base)","keywords":"","body":"unsigned long int strtoul(const char str, char *endptr, int base) 描述 C 库函数 unsigned long int strtoul(const char *str, char endptr, int base) 把参数 str 所指向的字符串根据给定的 base** 转换为一个无符号长整数（类型为 unsigned long int 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0。 声明 下面是 strtoul() 函数的声明。 unsigned long int strtoul(const char *str, char **endptr, int base) 参数 str -- 要转换为无符号长整数的字符串。 endptr -- 对类型为 char* 的对象的引用，其值由函数设置为 str 中数值后的下一个字符。 base -- 基数，必须介于 2 和 36（包含）之间，或者是特殊值 0。 返回值 该函数返回转换后的长整数，如果没有执行有效的转换，则返回一个零值。 实例 下面的实例演示了 strtoul() 函数的用法。 #include #include int main() { char str[30] = \"2030300 This is test\"; char *ptr; long ret; ret = strtoul(str, &ptr, 10); printf(\"数字（无符号长整数）是 %lu\\n\", ret); printf(\"字符串部分是 |%s|\", ptr); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 数字（无符号长整数）是 2030300 字符串部分是 | This is test| 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/*calloc.html":{"url":"include/stdlib.h/*calloc.html","title":"void *calloc(size_t nitems, size_t size)","keywords":"","body":"void *calloc(size_t nitems, size_t size) 描述 C 库函数 void *calloc(size_t nitems, size_t size) 分配所需的内存空间，并返回一个指向它的指针。malloc 和 calloc 之间的不同点是，malloc 不会设置内存为零，而 calloc 会设置分配的内存为零。 声明 下面是 calloc() 函数的声明。 void *calloc(size_t nitems, size_t size) 参数 nitems -- 要被分配的元素个数。 size -- 元素的大小。 返回值 该函数返回一个指针，指向已分配的内存。如果请求失败，则返回 NULL。 实例 下面的实例演示了 calloc() 函数的用法。 #include #include int main() { int i, n; int *a; printf(\"要输入的元素个数：\"); scanf(\"%d\",&n); a = (int*)calloc(n, sizeof(int)); printf(\"输入 %d 个数字：\\n\",n); for( i=0 ; i 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/free.html":{"url":"include/stdlib.h/free.html","title":"void free(void *ptr)","keywords":"","body":"void free(void *ptr) 描述 C 库函数 void free(void *ptr) 释放之前调用 calloc、malloc 或 realloc 所分配的内存空间。 声明 下面是 free() 函数的声明。 void free(void *ptr) 参数 ptr -- 指针指向一个要释放内存的内存块，该内存块之前是通过调用 malloc、calloc 或 realloc 进行分配内存的。如果传递的参数是一个空指针，则不会执行任何动作。 返回值 该函数不返回任何值。 实例 下面的实例演示了 free() 函数的用法。 #include #include #include int main() { char *str; /* 最初的内存分配 */ str = (char *) malloc(15); strcpy(str, \"runoob\"); printf(\"String = %s, Address = %p\\n\", str, str); /* 重新分配内存 */ str = (char *) realloc(str, 25); strcat(str, \".com\"); printf(\"String = %s, Address = %p\\n\", str, str); /* 释放已分配的内存 */ free(str); return(0); } //String = runoob, Address = 0x7fe4e4c02b10 //String = runoob.com, Address = 0x7fe4e4c02b10 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/*malloc.html":{"url":"include/stdlib.h/*malloc.html","title":"void *malloc(size_t size)","keywords":"","body":"void *malloc(size_t size) 描述 C 库函数 void *malloc(size_t size) 分配所需的内存空间，并返回一个指向它的指针。 声明 下面是 malloc() 函数的声明。 void *malloc(size_t size) 参数 size -- 内存块的大小，以字节为单位。 返回值 该函数返回一个指针 ，指向已分配大小的内存。如果请求失败，则返回 NULL。 实例 下面的实例演示了 malloc() 函数的用法。 #include #include #include int main() { char *str; /* 最初的内存分配 */ str = (char *) malloc(15); strcpy(str, \"runoob\"); printf(\"String = %s, Address = %u\\n\", str, str); /* 重新分配内存 */ str = (char *) realloc(str, 25); strcat(str, \".com\"); printf(\"String = %s, Address = %u\\n\", str, str); free(str); return(0); } /* String = runoob, Address = 3662685808 String = runoob.com, Address = 3662685808 */ 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/*realloc.html":{"url":"include/stdlib.h/*realloc.html","title":"void realloc(void ptr, size_t size)","keywords":"","body":"void *realloc(void ptr, size_t size) 描述 C 库函数 void *realloc(void *ptr, size_t size) 尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小。 声明 下面是 realloc() 函数的声明。 void *realloc(void *ptr, size_t size) 参数 ptr -- 指针指向一个要重新分配内存的内存块，该内存块之前是通过调用 malloc、calloc 或 realloc 进行分配内存的。如果为空指针，则会分配一个新的内存块，且函数返回一个指向它的指针。 size -- 内存块的新的大小，以字节为单位。如果大小为 0，且 ptr 指向一个已存在的内存块，则 ptr 所指向的内存块会被释放，并返回一个空指针。 返回值 该函数返回一个指针 ，指向重新分配大小的内存。如果请求失败，则返回 NULL。 实例 下面的实例演示了 realloc() 函数的用法。 #include #include #include int main() { char *str; /* 最初的内存分配 */ str = (char *) malloc(15); strcpy(str, \"runoob\"); printf(\"String = %s, Address = %p\\n\", str, str); /* 重新分配内存 */ str = (char *) realloc(str, 25); strcat(str, \".com\"); printf(\"String = %s, Address = %p\\n\", str, str); free(str); return(0); } //String = runoob, Address = 0x7fa2f8c02b10 //String = runoob.com, Address = 0x7fa2f8c02b10 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/abort.html":{"url":"include/stdlib.h/abort.html","title":"void abort(void)","keywords":"","body":"void abort(void) 描述 C 库函数 void abort(void) 中止程序执行，直接从调用的地方跳出。 声明 下面是 abort() 函数的声明。 void abort(void) 参数 NA 返回值 该函数不返回任何值。 实例 下面的实例演示了 abort() 函数的用法。 #include #include int main () { FILE *fp; printf(\"准备打开 nofile.txt\\n\"); fp = fopen( \"nofile.txt\",\"r\" ); if(fp == NULL) { printf(\"准备终止程序\\n\"); abort(); } printf(\"准备关闭 nofile.txt\\n\"); fclose(fp); return(0); } 让我们编译并运行上面的程序，这将产生以下结果，因为我们尝试打开的文件 nofile.txt 是不存在的： 准备打开 nofile.txt 准备终止程序 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/atexit.html":{"url":"include/stdlib.h/atexit.html","title":"int atexit(void (*func)(void))","keywords":"","body":"int atexit(void (*func)(void)) 描述 C 库函数 int atexit(void (*func)(void)) 当程序正常终止时，调用指定的函数 func。您可以在任何地方注册你的终止函数，但它会在程序终止的时候被调用。 声明 下面是 atexit() 函数的声明。 int atexit(void (*func)(void)) 参数 func -- 在程序终止时被调用的函数。 返回值 如果函数成功注册，则该函数返回零，否则返回一个非零值。 实例 下面的实例演示了 atexit() 函数的用法。 #include #include void functionA () { printf(\"这是函数A\\n\"); } int main () { /* 注册终止函数 */ atexit(functionA ); printf(\"启动主程序...\\n\"); printf(\"退出主程序...\\n\"); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 启动主程序... 退出主程序... 这是函数A 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/exit.html":{"url":"include/stdlib.h/exit.html","title":"void exit(int status)","keywords":"","body":"void exit(int status) 描述 C 库函数 void exit(int status) 立即终止调用进程。任何属于该进程的打开的文件描述符都会被关闭，该进程的子进程由进程 1 继承，初始化，且会向父进程发送一个 SIGCHLD 信号。 声明 下面是 exit() 函数的声明。 void exit(int status) 参数 status -- 返回给父进程的状态值。 返回值 该函数不返回值。 实例 下面的实例演示了 exit() 函数的用法。 #include #include int main () { printf(\"程序的开头....\\n\"); printf(\"退出程序....\\n\"); exit(0); printf(\"程序的结尾....\\n\"); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 程序的开头.... 退出程序.... 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/*getenv.html":{"url":"include/stdlib.h/*getenv.html","title":"char getenv(const char name)","keywords":"","body":"char *getenv(const char name) 描述 C 库函数 char *getenv(const char *name) 搜索 name 所指向的环境字符串，并返回相关的值给字符串。 声明 下面是 getenv() 函数的声明。 char *getenv(const char *name) 参数 name -- 包含被请求变量名称的 C 字符串。 返回值 该函数返回一个以 null 结尾的字符串，该字符串为被请求环境变量的值。如果该环境变量不存在，则返回 NULL。 实例 下面的实例演示了 getenv() 函数的用法。 #include #include int main () { printf(\"PATH : %s\\n\", getenv(\"PATH\")); printf(\"HOME : %s\\n\", getenv(\"HOME\")); printf(\"ROOT : %s\\n\", getenv(\"ROOT\")); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： PATH : /sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin HOME : / ROOT : (null) 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/system.html":{"url":"include/stdlib.h/system.html","title":"int system(const char *string)","keywords":"","body":"int system(const char *string) 描述 C 库函数 int system(const char *command) 把 command 指定的命令名称或程序名称传给要被命令处理器执行的主机环境，并在命令完成后返回。 声明 下面是 system() 函数的声明。 int system(const char *command) 参数 command -- 包含被请求变量名称的 C 字符串。 返回值 如果发生错误，则返回值为 -1，否则返回命令的状态。 实例 下面的实例演示了 system() 函数的用法，列出了 unix 机上当前目录下所有的文件和目录。 #include #include #include int main () { char command[50]; strcpy( command, \"ls -l\" ); system(command); return(0); } 让我们编译并运行上面的程序，在 unix 机上将产生以下结果： drwxr-xr-x 2 apache apache 4096 Aug 22 07:25 hsperfdata_apache drwxr-xr-x 2 railo railo 4096 Aug 21 18:48 hsperfdata_railo rw------ 1 apache apache 8 Aug 21 18:48 mod_mono_dashboard_XXGLOBAL_1 rw------ 1 apache apache 8 Aug 21 18:48 mod_mono_dashboard_asp_2 srwx---- 1 apache apache 0 Aug 22 05:28 mod_mono_server_asp rw------ 1 apache apache 0 Aug 22 05:28 mod_mono_server_asp_1280495620 srwx---- 1 apache apache 0 Aug 21 18:48 mod_mono_server_global 下面的实例演示了 system() 函数的用法，列出了 windows 机上当前目录下所有的文件和目录。 #include #include int main () { char command[50]; strcpy( command, \"dir\" ); system(command); return(0); } 让我们编译并运行上面的程序，在 windows 机上将产生以下结果： a.txt amit.doc sachin saurav file.c 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/*bsearch.html":{"url":"include/stdlib.h/*bsearch.html","title":"void bsearch(const void key, const void base, size_t nitems, size_t size, int (compar)(const void , const void ))","keywords":"","body":"void *bsearch(const void key, const void base, size_t nitems, size_t size, int (compar)(const void , const void )) 描述 C 库函数 void *bsearch(const void key, const void base, size_t nitems, size_t size, int (compar)(const void , const void *)) 对 nitems 对象的数组执行二分查找，base 指向进行查找的数组，key 指向要查找的元素，size 指定数组中每个元素的大小。 数组的内容应根据 compar 所对应的比较函数升序排序。 声明 下面是 bsearch() 函数的声明。 void *bsearch(const void *key, const void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *)) 参数 key -- 指向要查找的元素的指针，类型转换为 void*。 base -- 指向进行查找的数组的第一个对象的指针，类型转换为 void*。 nitems -- base 所指向的数组中元素的个数。 size -- 数组中每个元素的大小，以字节为单位。 compar -- 用来比较两个元素的函数。 返回值 如果查找成功，该函数返回一个指向数组中匹配元素的指针，否则返回空指针。. 实例 下面的实例演示了 bsearch() 函数的用法。 #include #include int cmpfunc(const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } int values[] = { 5, 20, 29, 32, 63 }; int main () { int *item; int key = 32; /* 使用 bsearch() 在数组中查找值 32 */ item = (int*) bsearch (&key, values, 5, sizeof (int), cmpfunc); if( item != NULL ) { printf(\"Found item = %d\\n\", *item); } else { printf(\"Item = %d could not be found\\n\", *item); } return(0); } //Found item = 32 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/qsort.html":{"url":"include/stdlib.h/qsort.html","title":"void qsort(void base, size_t nitems, size_t size, int (compar)(const void , const void))","keywords":"","body":"void qsort(void base, size_t nitems, size_t size, int (compar)(const void , const void)) 描述 C 库函数 void qsort(void *base, size_t nitems, size_t size, int (compar)(const void , const void*)) 对数组进行排序。 声明 下面是 qsort() 函数的声明。 void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*)) 参数 base -- 指向要排序的数组的第一个元素的指针。 nitems -- 由 base 指向的数组中元素的个数。 size -- 数组中每个元素的大小，以字节为单位。 compar -- 用来比较两个元素的函数。 返回值 该函数不返回任何值。 实例 下面的实例演示了 qsort() 函数的用法。 #include #include int values[] = { 88, 56, 100, 2, 25 }; int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } int main() { int n; printf(\"排序之前的列表：\\n\"); for( n = 0 ; n 让我们编译并运行上面的程序，这将产生以下结果： 排序之前的列表： 88 56 100 2 25 排序之后的列表： 2 25 56 88 100 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/abs.html":{"url":"include/stdlib.h/abs.html","title":"int abs(int x)","keywords":"","body":"int abs(int x) 描述 C 库函数 int abs(int x) 返回 x 的绝对值。 声明 下面是 abs() 函数的声明。 int abs(int x) 参数 x -- 完整的值。 返回值 该函数返回 x 的绝对值。 实例 下面的实例演示了 abs() 函数的用法。 #include #include int main () { int a, b; a = abs(5); printf(\"a 的值 = %d\\n\", a); b = abs(-10); printf(\"b 的值 = %d\\n\", b); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： a 的值 = 5 b 的值 = 10 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/div.html":{"url":"include/stdlib.h/div.html","title":"div_t div(int numer, int denom)","keywords":"","body":"div_t div(int numer, int denom) 描述 C 库函数 div_t div(int numer, int denom) 把 numer（分子）除以 denom（分母）。 声明 下面是 div() 函数的声明。 div_t div(int numer, int denom) 参数 numer -- 分子。 denom -- 分母。 返回值 该函数返回定义在 中的结构中的值，该结构有两个成员，如 div_t:int quot; int rem;。 实例 下面的实例演示了 div() 函数的用法。 #include #include int main() { div_t output; output = div(27, 4); printf(\"(27/ 4) 的商 = %d\\n\", output.quot); printf(\"(27/4) 的余数 = %d\\n\", output.rem); output = div(27, 3); printf(\"(27/ 3) 的商 = %d\\n\", output.quot); printf(\"(27/3) 的余数 = %d\\n\", output.rem); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： (27/ 4) 的商 = 6 (27/4) 的余数 = 3 (27/ 3) 的商 = 9 (27/3) 的余数 = 0 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/labs.html":{"url":"include/stdlib.h/labs.html","title":"long int labs(long int x)","keywords":"","body":"long int labs(long int x) 描述 C 库函数 long int labs(long int x) 返回 x 的绝对值。 声明 下面是 labs() 函数的声明。 long int labs(long int x) 参数 x -- 完整的值。 返回值 该函数返回 x 的绝对值。 实例 下面的实例演示了 labs() 函数的用法。 #include #include int main () { long int a,b; a = labs(65987L); printf(\"a 的值 = %ld\\n\", a); b = labs(-1005090L); printf(\"b 的值 = %ld\\n\", b); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： a 的值 = 65987 b 的值 = 1005090 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/ldiv.html":{"url":"include/stdlib.h/ldiv.html","title":"ldiv_t ldiv(long int numer, long int denom)","keywords":"","body":"ldiv_t ldiv(long int numer, long int denom) 描述 C 库函数 div_t div(long int numer, long int denom) 把 numer（分子）除以 denom（分母）。 声明 下面是 ldiv() 函数的声明。 div_t div(long int numer, long int denom) 参数 numer -- 分子。 denom -- 分母。 返回值 该函数返回定义在 中的结构中的值，该结构有两个成员，如 ldiv_t:long quot; long rem;。 实例 下面的实例演示了 ldiv() 函数的用法。 #include #include int main () { ldiv_t output; output = ldiv(100000L, 30000L); printf(\"商 = %ld\\n\", output.quot); printf(\"余数 = %ld\\n\", output.rem); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 商 = 3 余数 = 10000 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/rand.html":{"url":"include/stdlib.h/rand.html","title":"int rand(void)","keywords":"","body":"int rand(void) 描述 C 库函数 int rand(void) 返回一个范围在 0 到 RAND_MAX 之间的伪随机数。 RAND_MAX 是一个常量，它的默认值在不同的实现中会有所不同，但是值至少是 32767。 声明 下面是 rand() 函数的声明。 int rand(void) 参数 NA 返回值 该函数返回一个范围在 0 到 RAND_MAX 之间的整数值。 实例 下面的实例演示了 rand() 函数的用法。 #include #include #include int main() { int i, n; time_t t; n = 5; /* 初始化随机数发生器 */ srand((unsigned) time(&t)); /* 输出 0 到 49 之间的 5 个随机数 */ for( i = 0 ; i 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/srand.html":{"url":"include/stdlib.h/srand.html","title":"void srand(unsigned int seed)","keywords":"","body":"void srand(unsigned int seed) 描述 C 库函数 void srand(unsigned int seed) 播种由函数 rand 使用的随机数发生器。 声明 下面是 srand() 函数的声明。 void srand(unsigned int seed) 参数 seed -- 这是一个整型值，用于伪随机数生成算法播种。 返回值 该函数不返回任何值。 实例 下面的实例演示了 srand() 函数的用法。 #include #include #include int main() { int i, n; time_t t; n = 5; /* 初始化随机数发生器 */ srand((unsigned) time(&t)); /* 输出 0 到 50 之间的 5 个随机数 */ for( i = 0 ; i 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/mblen.html":{"url":"include/stdlib.h/mblen.html","title":"int mblen(const char *str, size_t n)","keywords":"","body":"int mblen(const char *str, size_t n) 描述 C 库函数 int mblen(const char *str, size_t n) 返回参数 str 所指向的多字节字符的长度。 声明 下面是 mblen() 函数的声明。 int mblen(const char *str, size_t n) 参数 str -- 指向多字节字符的第一个字节的指针。 n -- 要检查的字符长度的最大字节数。 返回值 如果识别了一个非空宽字符，mblen() 函数返回 str 开始的多字节序列解析的字节数。如果识别了一个空宽字符，则返回 0。如果识别了一个无效的多字节序列，或者不能解析一个完整的多字节字符，则返回 -1。 实例 下面的实例演示了 mblen() 函数的用法。 #include #include #include int main() { int len; char *pmbnull = NULL; char *pmb = (char *)malloc( MB_CUR_MAX ); wchar_t *pwc = L\"Hi\"; wchar_t *pwcs = (wchar_t *)malloc( sizeof( wchar_t )); printf(\"转换为多字节字符串\\n\"); len = wcstombs( pmb, pwc, MB_CUR_MAX); printf(\"被转换的字符 %d\\n\", len); printf(\"第一个多字节字符的十六进制值：%#.4x\\n\", pmb); len = mblen( pmb, MB_CUR_MAX ); printf( \"多字节字符 %x 的字节长度：%u\\n\", pmb, len ); pmb = NULL; len = mblen( pmb, MB_CUR_MAX ); printf( \"多字节字符 %x 的字节长度：%u\\n\", pmb, len ); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 转换为多字节字符串 被转换的字符 1 第一个多字节字符的十六进制值：0x168c6010 多字节字符 168c6010 的字节长度：1 多字节字符 0 的字节长度：0 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/mbstowcs.html":{"url":"include/stdlib.h/mbstowcs.html","title":"size_t mbstowcs(schar_t pwcs, const char str, size_t n)","keywords":"","body":"size_t mbstowcs(schar_t pwcs, const char str, size_t n) 描述 C 库函数 size_t mbstowcs(schar_t *pwcs, const char *str, size_t n) 把参数 str 所指向的多字节字符的字符串转换为参数 pwcs 所指向的数组。 声明 下面是 mbstowcs() 函数的声明。 size_t mbstowcs(schar_t *pwcs, const char *str, size_t n) 参数 pwcs -- 指向一个 wchar_t 元素的数组，数组长度足以存储一个最大字符长度的宽字符串。 str -- 要被转换的多字节字符字符串。 n -- 要被转换的最大字符数。 返回值 该函数返回转换的字符数，不包括结尾的空字符。如果遇到一个无效的多字节字符，则返回 -1 值。 实例 下面的实例演示了 mbstowcs() 函数的用法。 #include #include #include int main() { int len; char *pmbnull = NULL; char *pmb = (char *)malloc( MB_CUR_MAX ); wchar_t *pwc = L\"Hi\"; wchar_t *pwcs = (wchar_t *)malloc( sizeof( wchar_t )); printf(\"转换为多字节字符串\\n\"); len = wcstombs( pmb, pwc, MB_CUR_MAX); printf(\"被转换的字符 %d\\n\", len); printf(\"第一个多字节字符的十六进制值：%#.4x\\n\", pmb); printf(\"转换回宽字符字符串\\n\"); len = mbstowcs( pwcs, pmb, MB_CUR_MAX); printf(\"被转换的字符 %d\\n\", len); printf(\"第一个宽字符的十六进制值：%#.4x\\n\\n\", pwcs); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 转换为多字节字符串 被转换的字符 1 第一个多字节字符的十六进制值：0x19a60010 转换回宽字符字符串 被转换的字符 1 第一个宽字符的十六进制值：0x19a60030 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/mbtowc.html":{"url":"include/stdlib.h/mbtowc.html","title":"int mbtowc(whcar_t pwc, const char str, size_t n)","keywords":"","body":"int mbtowc(whcar_t pwc, const char str, size_t n) 描述 C 库函数 int mbtowc(whcar_t *pwc, const char *str, size_t n) 把一个多字节序列转换为一个宽字符。 声明 下面是 mbtowc() 函数的声明。 int mbtowc(whcar_t *pwc, const char *str, size_t n) 参数 pwc -- 指向类型为 wchar_t 对象的指针。 str -- 指向多字节字符的第一个字节的指针。 n -- 要被检查的最大字节数。 返回值 如果 str 不为 NULL，mbtowc() 函数返回 str 开始消耗的字节数，如果指向一个空字节，则返回 0，如果操作失败，则返回 -1。 如果 str 为 NULL，如果编码具有移位状态，则 mbtowc() 函数返回非零，如果编码是无状态的，则返回零。 实例 下面的实例演示了 mbtowc() 函数的用法。 #include #include #include int main() { char *str = \"这里是 runoob.com\"; wchar_t mb[100]; int len; len = mblen(NULL, MB_CUR_MAX); mbtowc(mb, str, len*strlen(str) ); wprintf(L\"%ls \\n\", mb ); return(0); } 让我们编译并运行上面的程序，这将产生以下结果，因为它要以多字节形式输出结果，这是一种二进制输出。 ??? 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/wcstombs.html":{"url":"include/stdlib.h/wcstombs.html","title":"size_t wcstombs(char str, const wchar_t pwcs, size_t n)","keywords":"","body":"size_t wcstombs(char str, const wchar_t pwcs, size_t n) 描述 C 库函数 size_t wcstombs(char *str, const wchar_t *pwcs, size_t n) 把宽字符字符串 pwcs 转换为一个 str 开始的多字节字符串。最多会有 n 个字节被写入 str 中。 声明 下面是 wcstombs() 函数的声明。 size_t wcstombs(char *str, const wchar_t *pwcs, size_t n) 参数 str -- 指向一个 char 元素的数组，至少有 n 字节长。 pwcs -- 要被转换的宽字符字符串。 n -- 要被写入到 str 中的最大字节数。 返回值 该函数返回转换和写入到 str 中的字节数，不包括结尾的空字符。如果遇到一个无效的多字节字符，则返回 -1 值。 实例 下面的实例演示了 wcstombs() 函数的用法。 #include #include #define BUFFER_SIZE 50 int main() { size_t ret; char *MB = (char *)malloc( BUFFER_SIZE ); wchar_t *WC = L\"http://www.w3cschool.cc\"; /* 转换宽字符字符串 */ ret = wcstombs(MB, WC, BUFFER_SIZE); printf(\"要转换的字符数 = %u\\n\", ret); printf(\"多字节字符 = %s\\n\\n\", MB); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 要转换的字符数 = 23 多字节字符 = http://www.w3cschool.cc 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/stdlib.h/wctomb.html":{"url":"include/stdlib.h/wctomb.html","title":"int wctomb(char *str, wchar_t wchar)","keywords":"","body":"int wctomb(char *str, wchar_t wchar) 描述 C 库函数 int wctomb(char *str, wchar_t wchar) 把宽字符 wchar 转换为它的多字节表示形式，并把它存储在 str 指向的字符数组的开头。 声明 下面是 wctomb() 函数的声明。 int wctomb(char *str, wchar_t wchar) 参数 str -- 一个指针，指向一个足以存储多字节字符的数组。 wchar -- 类型为 wchar_t 的宽字符。 返回值 如果 str 不为 NULL，wctomb() 函数返回写入字节数组中的字节数。如果 wchar 不能被表示为一个多字节序列，则会返回 -1。 如果 str 为 NULL，如果编码具有移位状态，则 wctomb() 函数返回非零，如果编码是无状态的，则返回零。 实例 下面的实例演示了 wctomb() 函数的用法。 #include #include int main() { int i; wchar_t wc = L'a'; char *pmbnull = NULL; char *pmb = (char *)malloc(sizeof( char )); printf(\"要转换的宽字符：\\n\"); i = wctomb( pmb, wc ); printf(\"被转换的字符：%u\\n\", i); printf(\"多字节字符：%.1s\\n\", pmb); printf(\"当要转换的字符为 NULL 时尝试转换：\\n\"); i = wctomb( pmbnull, wc ); printf(\"被转换的字符：%u\\n\", i); /* 不会输出任何值 */ printf(\"多字节字符：%.1s\\n\", pmbnull); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 要转换的宽字符： 被转换的字符：1 多字节字符：a 当要转换的字符为 NULL 时尝试转换： 被转换的字符：0 多字节字符： 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/":{"url":"include/string.h/","title":"string.h","keywords":"","body":"string.h C 标准库 - 简介 string .h 头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。 库变量 下面是头文件 string.h 中定义的变量类型： 序号 变量 & 描述 1 size_t 这是无符号整数类型，它是 sizeof 关键字的结果。 库宏 下面是头文件 string.h 中定义的宏： 序号 宏 & 描述 1 NULL 这个宏是一个空指针常量的值。 库函数 下面是头文件 string.h 中定义的函数： 序号 函数 & 描述 1 void memchr(const void str, int c, size_t n) 在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。 2 int memcmp(const void str1, const void str2, size_t n) 把 str1 和 str2 的前 n 个字节进行比较。 3 void memcpy(void dest, const void *src, size_t n) 从 src 复制 n 个字符到 dest。 4 void memmove(void dest, const void *src, size_t n) 另一个用于从 src 复制 n 个字符到 dest 的函数。 5 void memset(void str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。 6 char strcat(char dest, const char *src) 把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。 7 char strncat(char dest, const char *src, size_t n) 把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。 8 char strchr(const char str, int c) 在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。 9 int strcmp(const char str1, const char str2) 把 str1 所指向的字符串和 str2 所指向的字符串进行比较。 10 int strncmp(const char str1, const char str2, size_t n) 把 str1 和 str2 进行比较，最多比较前 n 个字节。 11 int strcoll(const char str1, const char str2) 把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。 12 char strcpy(char dest, const char *src) 把 src 所指向的字符串复制到 dest。 13 char strncpy(char dest, const char *src, size_t n) 把 src 所指向的字符串复制到 dest，最多复制 n 个字符。 14 size_t strcspn(const char str1, const char str2) 检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。 15 char *strerror(int errnum) 从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。 16 size_t strlen(const char *str) 计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。 17 char strpbrk(const char str1, const char *str2) 检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。 18 char strrchr(const char str, int c) 在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。 19 size_t strspn(const char str1, const char str2) 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。 20 char strstr(const char haystack, const char *needle) 在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。 21 char strtok(char str, const char *delim) 分解字符串 str 为一组字符串，delim 为分隔符。 22 size_t strxfrm(char dest, const char src, size_t n) 根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/*memchr.html":{"url":"include/string.h/*memchr.html","title":"void *memchr(const void str, int c, size_t n)","keywords":"","body":"void memchr(const void str, int c, size_t n) 描述 C 库函数 void *memchr(const void *str, int c, size_t n) 在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。 声明 下面是 memchr() 函数的声明。 void *memchr(const void *str, int c, size_t n) 参数 str -- 指向要执行搜索的内存块。 c -- 以 int 形式传递的值，但是函数在每次字节搜索时是使用该值的无符号字符形式。 n -- 要被分析的字节数。 返回值 该函数返回一个指向匹配字节的指针，如果在给定的内存区域未出现字符，则返回 NULL。 实例 下面的实例演示了 memchr() 函数的用法。 #include #include int main () { const char str[] = \"http://www.runoob.com\"; const char ch = '.'; char *ret; ret = (char*)memchr(str, ch, strlen(str)); printf(\"|%c| 之后的字符串是 - |%s|\\n\", ch, ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： |.| 之后的字符串是 - |.runoob.com| 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/memcmp.html":{"url":"include/string.h/memcmp.html","title":"int memcmp(const void str1, const void str2, size_t n)","keywords":"","body":"int memcmp(const void str1, const void str2, size_t n) 描述 C 库函数 int memcmp(const void *str1, const void *str2, size_t n)) 把存储区 str1 和存储区 str2 的前 n 个字节进行比较。 声明 下面是 memcmp() 函数的声明。 int memcmp(const void *str1, const void *str2, size_t n) 参数 str1 -- 指向内存块的指针。 str2 -- 指向内存块的指针。 n -- 要被比较的字节数。 返回值 如果返回值 如果返回值 > 0，则表示 str2 小于 str1。 如果返回值 = 0，则表示 str1 等于 str2。 实例 下面的实例演示了 memcmp() 函数的用法。 #include #include int main () { char str1[15]; char str2[15]; int ret; memcpy(str1, \"abcdef\", 6); memcpy(str2, \"ABCDEF\", 6); ret = memcmp(str1, str2, 5); if(ret > 0) { printf(\"str2 小于 str1\"); } else if(ret 让我们编译并运行上面的程序，这将产生以下结果： str2 小于 str1 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/*memcpy.html":{"url":"include/string.h/*memcpy.html","title":"void memcpy(void dest, const void src, size_t n)","keywords":"","body":"void memcpy(void dest, const void *src, size_t n) 描述 C 库函数 void *memcpy(void str1, const void str2, size_t n) 从存储区 str2 复制 n 个字符到存储区 str1。 声明 下面是 memcpy() 函数的声明。 void *memcpy(void *str1, const void *str2, size_t n) 参数 str1 -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。 str2 -- 指向要复制的数据源，类型强制转换为 void* 指针。 n -- 要被复制的字节数。 返回值 该函数返回一个指向目标存储区 str1 的指针。 实例 下面的实例演示了 memcpy() 函数的用法。 // 将字符串复制到数组 dest 中 #include #include int main () { const char src[50] = \"http://www.runoob.com\"; char dest[50]; memcpy(dest, src, strlen(src)+1); printf(\"dest = %s\\n\", dest); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： dest = http://www.runoob.com 将 s 中第 11 个字符开始的 6个连续字符复制到 d 中: #include #include int main() { char *s=\"http://www.runoob.com\"; char d[20]; memcpy(d, s+11, 6);// 从第 11 个字符(r)开始复制，连续复制 6 个字符(runoob) // 或者 memcpy(d, s+11*sizeof(char), 6*sizeof(char)); d[6]='\\0'; printf(\"%s\", d); return 0; } 让我们编译并运行上面的程序，这将产生以下结果： runoob 覆盖原有部分数据: #include #include int main(void) { char src[] = \"***\"; char dest[] = \"abcdefg\"; printf(\"使用 memcpy 前: %s\\n\", dest); memcpy(dest, src, strlen(src)); printf(\"使用 memcpy 后: %s\\n\", dest); return 0; } 让我们编译并运行上面的程序，这将产生以下结果： 使用 memcpy 前: abcdefg 使用 memcpy 后: ***defg 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/memmove.html":{"url":"include/string.h/memmove.html","title":"void memmove(void dest, const void src, size_t n)","keywords":"","body":"void memmove(void dest, const void src, size_t n) 描述 C 库函数 void *memmove(void str1, const void str2, size_t n) 从 str2 复制 n 个字符到 str1，但是在重叠内存块这方面，memmove() 是比 memcpy() 更安全的方法。如果目标区域和源区域有重叠的话，memmove() 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，复制后源区域的内容会被更改。如果目标区域与源区域没有重叠，则和 memcpy() 函数功能相同。 声明 下面是 memmove() 函数的声明。 void *memmove(void *str1, const void *str2, size_t n) 参数 str1 -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。 str2 -- 指向要复制的数据源，类型强制转换为 void* 指针。 n -- 要被复制的字节数。 返回值 该函数返回一个指向目标存储区 str1 的指针。 实例 下面的实例演示了 memmove() 函数的用法。 #include #include int main () { const char dest[] = \"oldstring\"; const char src[] = \"newstring\"; printf(\"Before memmove dest = %s, src = %s\\n\", dest, src); memmove(dest, src, 9); printf(\"After memmove dest = %s, src = %s\\n\", dest, src); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： Before memmove dest = oldstring, src = newstring After memmove dest = newstring, src = newstring 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/*memset.html":{"url":"include/string.h/*memset.html","title":"void *memset(void str, int c, size_t n)","keywords":"","body":"void memset(void str, int c, size_t n) 描述 C 库函数 void *memset(void *str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。 声明 下面是 memset() 函数的声明。 void *memset(void *str, int c, size_t n) 参数 str -- 指向要填充的内存块。 c -- 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。 n -- 要被设置为该值的字节数。 返回值 该值返回一个指向存储区 str 的指针。 实例 下面的实例演示了 memset() 函数的用法。 #include #include int main () { char str[50]; strcpy(str,\"This is string.h library function\"); puts(str); memset(str,'$',7); puts(str); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： This is string.h library function $$$$$$$ string.h library function 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/*strcat.html":{"url":"include/string.h/*strcat.html","title":"char strcat(char dest, const char src)","keywords":"","body":"char *strcat(char dest, const char src) 描述 C 库函数 char *strcat(char dest, const char src) 把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。 声明 下面是 strcat() 函数的声明。 char *strcat(char *dest, const char *src) 参数 dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串。 src -- 指向要追加的字符串，该字符串不会覆盖目标字符串。 返回值 该函数返回一个指向最终的目标字符串 dest 的指针。 实例 下面的实例演示了 strcat() 函数的用法。 #include #include int main () { char src[50], dest[50]; strcpy(src, \"This is source\"); strcpy(dest, \"This is destination\"); strcat(dest, src); printf(\"最终的目标字符串： |%s|\", dest); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 最终的目标字符串： |This is destinationThis is source| 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/*strncat.html":{"url":"include/string.h/*strncat.html","title":"char strncat(char dest, const char src, size_t n)","keywords":"","body":"char *strncat(char dest, const char src, size_t n) 描述 C 库函数 char *strncat(char dest, const char src, size_t n) 把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。 声明 下面是 strncat() 函数的声明。 char *strncat(char *dest, const char *src, size_t n) 参数 dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串，包括额外的空字符。 src -- 要追加的字符串。 n -- 要追加的最大字符数。 返回值 该函数返回一个指向最终的目标字符串 dest 的指针。 实例 下面的实例演示了 strncat() 函数的用法。 #include #include int main () { char src[50], dest[50]; strcpy(src, \"This is source\"); strcpy(dest, \"This is destination\"); strncat(dest, src, 15); printf(\"最终的目标字符串： |%s|\", dest); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 最终的目标字符串： |This is destinationThis is source| 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/*strchr.html":{"url":"include/string.h/*strchr.html","title":"char *strchr(const char str, int c)","keywords":"","body":"char strchr(const char str, int c) 描述 C 库函数 char *strchr(const char *str, int c) 在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。 声明 下面是 strchr() 函数的声明。 char *strchr(const char *str, int c) 参数 str -- 要被检索的 C 字符串。 c -- 在 str 中要搜索的字符。 返回值 该函数返回在字符串 str 中第一次出现字符 c 的位置，如果未找到该字符则返回 NULL。 实例 下面的实例演示了 strchr() 函数的用法。 #include #include int main () { const char str[] = \"http://www.runoob.com\"; const char ch = '.'; char *ret; ret = strchr(str, ch); printf(\"|%c| 之后的字符串是 - |%s|\\n\", ch, ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： |.| 之后的字符串是 - |.runoob.com| 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/strcmp.html":{"url":"include/string.h/strcmp.html","title":"int strcmp(const char str1, const char str2)","keywords":"","body":"int strcmp(const char str1, const char str2) 描述 C 库函数 int strcmp(const char *str1, const char *str2) 把 str1 所指向的字符串和 str2 所指向的字符串进行比较。 声明 下面是 strcmp() 函数的声明。 int strcmp(const char *str1, const char *str2) 参数 str1 -- 要进行比较的第一个字符串。 str2 -- 要进行比较的第二个字符串。 返回值 该函数返回值如下： 如果返回值 如果返回值 > 0，则表示 str2 小于 str1。 如果返回值 = 0，则表示 str1 等于 str2。 实例 下面的实例演示了 strcmp() 函数的用法。 #include #include int main () { char str1[15]; char str2[15]; int ret; strcpy(str1, \"abcdef\"); strcpy(str2, \"ABCDEF\"); ret = strcmp(str1, str2); if(ret 0) { printf(\"str2 小于 str1\"); } else { printf(\"str1 等于 str2\"); } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： str2 小于 str1 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/strncmp.html":{"url":"include/string.h/strncmp.html","title":"int strncmp(const char str1, const char str2, size_t n)","keywords":"","body":"int strncmp(const char str1, const char str2, size_t n) 描述 C 库函数 int strncmp(const char *str1, const char *str2, size_t n) 把 str1 和 str2 进行比较，最多比较前 n 个字节。 声明 下面是 strncmp() 函数的声明。 int strncmp(const char *str1, const char *str2, size_t n) 参数 str1 -- 要进行比较的第一个字符串。 str2 -- 要进行比较的第二个字符串。 n -- 要比较的最大字符数。 返回值 该函数返回值如下： 如果返回值 如果返回值 > 0，则表示 str2 小于 str1。 如果返回值 = 0，则表示 str1 等于 str2。 实例 下面的实例演示了 strncmp() 函数的用法。 #include #include int main () { char str1[15]; char str2[15]; int ret; strcpy(str1, \"abcdef\"); strcpy(str2, \"ABCDEF\"); ret = strncmp(str1, str2, 4); if(ret 0) { printf(\"str2 小于 str1\"); } else { printf(\"str1 等于 str2\"); } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： str2 小于 str1 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/strcoll.html":{"url":"include/string.h/strcoll.html","title":"int strcoll(const char str1, const char str2)","keywords":"","body":"int strcoll(const char str1, const char str2) 描述 C 库函数 int strcoll(const char *str1, const char *str2) 把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。 声明 下面是 strcoll() 函数的声明。 int strcoll(const char *str1, const char *str2) 参数 str1 -- 要进行比较的第一个字符串。 str2 -- 要进行比较的第二个字符串。 返回值 该函数返回值如下： 如果返回值 如果返回值 > 0，则表示 str2 小于 str1。 如果返回值 = 0，则表示 str1 等于 str2。 实例 下面的实例演示了 strcoll() 函数的用法。. #include #include int main () { char str1[15]; char str2[15]; int ret; strcpy(str1, \"abc\"); strcpy(str2, \"ABC\"); ret = strcoll(str1, str2); if(ret > 0) { printf(\"str1 大于 str2\"); } else if(ret 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/*strcpy.html":{"url":"include/string.h/*strcpy.html","title":"char strcpy(char dest, const char src)","keywords":"","body":"char strcpy(char dest, const char *src) 描述 C 库函数 char *strcpy(char dest, const char src) 把 src 所指向的字符串复制到 dest。 需要注意的是如果目标数组 dest 不够大，而源字符串的长度又太长，可能会造成缓冲溢出的情况。 声明 下面是 strcpy() 函数的声明。 char *strcpy(char *dest, const char *src) 参数 dest -- 指向用于存储复制内容的目标数组。 src -- 要复制的字符串。 返回值 该函数返回一个指向最终的目标字符串 dest 的指针。 实例 下面的实例演示了 strcpy() 函数的用法。 #include #include int main() { char src[40]; char dest[100]; memset(dest, '\\0', sizeof(dest)); strcpy(src, \"This is runoob.com\"); strcpy(dest, src); printf(\"最终的目标字符串： %s\\n\", dest); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 最终的目标字符串： This is runoob.com #include #include int main () { char str1[]=\"Sample string\"; char str2[40]; char str3[40]; strcpy (str2,str1); strcpy (str3,\"copy successful\"); printf (\"str1: %s\\nstr2: %s\\nstr3: %s\\n\",str1,str2,str3); return 0; } 让我们编译并运行上面的程序，这将产生以下结果： str1: Sample string str2: Sample string str3: copy successful 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/*strncpy.html":{"url":"include/string.h/*strncpy.html","title":"char strncpy(char dest, const char src, size_t n)","keywords":"","body":"char *strncpy(char dest, const char src, size_t n) 描述 C 库函数 char *strncpy(char dest, const char src, size_t n) 把 src 所指向的字符串复制到 dest，最多复制 n 个字符。当 src 的长度小于 n 时，dest 的剩余部分将用空字节填充。 声明 下面是 strncpy() 函数的声明。 char *strncpy(char *dest, const char *src, size_t n) 参数 dest -- 指向用于存储复制内容的目标数组。 src -- 要复制的字符串。 n -- 要从源中复制的字符数。 返回值 该函数返回最终复制的字符串。 实例 下面的实例演示了 strncpy() 函数的用法。在这里，我们使用函数 memset() 来清除内存位置。 #include #include int main() { char src[40]; char dest[12]; memset(dest, '\\0', sizeof(dest)); strcpy(src, \"This is runoob.com\"); strncpy(dest, src, 10); printf(\"最终的目标字符串： %s\\n\", dest); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 最终的目标字符串： This is ru 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/strcspn.html":{"url":"include/string.h/strcspn.html","title":"size_t strcspn(const char str1, const char str2)","keywords":"","body":"size_t strcspn(const char str1, const char str2) 描述 C 库函数 size_t strcspn(const char *str1, const char *str2) 检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。 声明 下面是 strcspn() 函数的声明。 size_t strcspn(const char *str1, const char *str2) 参数 str1 -- 要被检索的 C 字符串。 str2 -- 该字符串包含了要在 str1 中进行匹配的字符列表。 返回值 该函数返回 str1 开头连续都不含字符串 str2 中字符的字符数。 实例 下面的实例演示了 strcspn() 函数的用法。 #include #include int main () { int len; const char str1[] = \"ABCDEF4960910\"; const char str2[] = \"013\"; len = strcspn(str1, str2); printf(\"第一个匹配的字符是在 %d\\n\", len + 1); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 第一个匹配的字符是在 10 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/*strerror.html":{"url":"include/string.h/*strerror.html","title":"char *strerror(int errnum)","keywords":"","body":"char *strerror(int errnum) 描述 C 库函数 char *strerror(int errnum) 从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。strerror 生成的错误字符串取决于开发平台和编译器。 声明 下面是 strerror() 函数的声明。 char *strerror(int errnum) 参数 errnum -- 错误号，通常是 errno。 返回值 该函数返回一个指向错误字符串的指针，该错误字符串描述了错误 errnum。 实例 下面的实例演示了 strerror() 函数的用法。 #include #include #include int main () { FILE *fp; fp = fopen(\"file.txt\",\"r\"); if( fp == NULL ) { printf(\"Error: %s\\n\", strerror(errno)); } return(0); } 让我们编译并运行上面的程序，这将产生以下结果，因为我们尝试打开一个不存在的文件： Error: No such file or directory 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/strlen.html":{"url":"include/string.h/strlen.html","title":"size_t strlen(const char *str)","keywords":"","body":"size_t strlen(const char *str) 描述 C 库函数 size_t strlen(const char *str) 计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。 声明 下面是 strlen() 函数的声明。 size_t strlen(const char *str) 参数 str -- 要计算长度的字符串。 返回值 该函数返回字符串的长度。 实例 下面的实例演示了 strlen() 函数的用法。 #include #include int main () { char str[50]; int len; strcpy(str, \"This is runoob.com\"); len = strlen(str); printf(\"|%s| 的长度是 |%d|\\n\", str, len); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： |This is runoob.com| 的长度是 |18| 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/strpbrk.html":{"url":"include/string.h/strpbrk.html","title":"char strpbrk(const char str1, const char str2)","keywords":"","body":"char strpbrk(const char str1, const char str2) 描述 C 库函数 char *strpbrk(const char str1, const char str2) 检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。 声明 下面是 strpbrk() 函数的声明。 char *strpbrk(const char *str1, const char *str2) 参数 str1 -- 要被检索的 C 字符串。 str2 -- 该字符串包含了要在 str1 中进行匹配的字符列表。 返回值 该函数返回 str1 中第一个匹配字符串 str2 中字符的字符数，如果未找到字符则返回 NULL。 实例 下面的实例演示了 strpbrk() 函数的用法。 #include #include int main () { const char str1[] = \"abcde2fghi3jk4l\"; const char str2[] = \"34\"; char *ret; ret = strpbrk(str1, str2); if(ret) { printf(\"第一个匹配的字符是： %c\\n\", *ret); } else { printf(\"未找到字符\"); } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 第一个匹配的字符是： 3 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/*strrchr.html":{"url":"include/string.h/*strrchr.html","title":"char *strrchr(const char str, int c)","keywords":"","body":"char *strrchr(const char str, int c) 描述 C 库函数 char *strrchr(const char *str, int c) 在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。 声明 下面是 strrchr() 函数的声明。 char *strrchr(const char *str, int c) 参数 str -- C 字符串。 c -- 要搜索的字符。以 int 形式传递，但是最终会转换回 char 形式。 返回值 该函数返回 str 中最后一次出现字符 c 的位置。如果未找到该值，则函数返回一个空指针。 实例 下面的实例演示了 strrchr() 函数的用法。 #include #include int main () { int len; const char str[] = \"https://www.runoob.com\"; const char ch = '.'; char *ret; ret = strrchr(str, ch); printf(\"|%c| 之后的字符串是 - |%s|\\n\", ch, ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： |.| 之后的字符串是 - |.com| 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/strspn.html":{"url":"include/string.h/strspn.html","title":"size_t strspn(const char str1, const char str2)","keywords":"","body":"size_t strspn(const char str1, const char str2) 描述 C 库函数 size_t strspn(const char *str1, const char *str2) 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。 声明 下面是 strspn() 函数的声明。 size_t strspn(const char *str1, const char *str2) 参数 str1 -- 要被检索的 C 字符串。 str2 -- 该字符串包含了要在 str1 中进行匹配的字符列表。 返回值 该函数返回 str1 中第一个不在字符串 str2 中出现的字符下标。 实例 下面的实例演示了 strspn() 函数的用法。 #include #include int main () { int len; const char str1[] = \"ABCDEFG019874\"; const char str2[] = \"ABCD\"; len = strspn(str1, str2); printf(\"初始段匹配长度 %d\\n\", len ); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 初始段匹配长度 4 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/*strstr.html":{"url":"include/string.h/*strstr.html","title":"char strstr(const char haystack, const char needle)","keywords":"","body":"char strstr(const char haystack, const char *needle) 描述 C 库函数 char *strstr(const char haystack, const char needle) 在字符串 haystack 中查找第一次出现字符串 needle 的位置，不包含终止符 '\\0'。 声明 下面是 strstr() 函数的声明。 char *strstr(const char *haystack, const char *needle) 参数 haystack -- 要被检索的 C 字符串。 needle -- 在 haystack 字符串内要搜索的小字符串。 返回值 该函数返回在 haystack 中第一次出现 needle 字符串的位置，如果未找到则返回 null。 实例 下面的实例演示了 strstr() 函数的用法。 #include #include int main() { const char haystack[20] = \"RUNOOB\"; const char needle[10] = \"NOOB\"; char *ret; ret = strstr(haystack, needle); printf(\"子字符串是： %s\\n\", ret); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 子字符串是： NOOB 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/*strtok.html":{"url":"include/string.h/*strtok.html","title":"char strtok(char str, const char delim)","keywords":"","body":"char *strtok(char str, const char delim) 描述 C 库函数 char *strtok(char str, const char delim) 分解字符串 str 为一组字符串，delim 为分隔符。 声明 下面是 strtok() 函数的声明。 char *strtok(char *str, const char *delim) 参数 str -- 要被分解成一组小字符串的字符串。 delim -- 包含分隔符的 C 字符串。 返回值 该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。 实例 下面的实例演示了 strtok() 函数的用法。 #include #include int main () { char str[80] = \"This is - www.runoob.com - website\"; const char s[2] = \"-\"; char *token; /* 获取第一个子字符串 */ token = strtok(str, s); /* 继续获取其他的子字符串 */ while( token != NULL ) { printf( \"%s\\n\", token ); token = strtok(NULL, s); } return(0); } 让我们编译并运行上面的程序，这将产生以下结果： This is www.runoob.com website 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/string.h/strxfrm.html":{"url":"include/string.h/strxfrm.html","title":"size_t strxfrm(char dest, const char src, size_t n)","keywords":"","body":"size_t strxfrm(char dest, const char src, size_t n) 描述 C 库函数 size_t strxfrm(char *dest, const char *src, size_t n) 根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src的前 n 个字符，并把它们放置在字符串 dest 中。 声明 下面是 strxfrm() 函数的声明。 size_t strxfrm(char *dest, const char *src, size_t n) 参数 dest -- 指向存储内容的目标数组的指针，如果参数 n 为 0，则它是一个空指针。 src -- 要被转换为当前区域设置的 C 字符串。 n -- 被复制到 str1 的最大字符数。 返回值 该函数返回被转换字符串的长度，不包括空结束字符。 实例 下面的实例演示了 strxfrm() 函数的用法。 #include #include int main() { char dest[20]; char src[20]; int len; strcpy(src, \"W3C School\"); len = strxfrm(dest, src, 20); printf(\"字符串 |%s| 的长度是： |%d|\", dest, len); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 字符串 |W3C School| 的长度是： |10| 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/time.h/":{"url":"include/time.h/","title":"time.h","keywords":"","body":"time.h C 标准库 - 简介 time.h 头文件定义了四个变量类型、两个宏和各种操作日期和时间的函数。 库变量 下面是头文件 time.h 中定义的变量类型： 序号 变量 & 描述 1 size_t 是无符号整数类型，它是 sizeof 关键字的结果。 2 clock_t 这是一个适合存储处理器时间的类型。 3 time_t is 这是一个适合存储日历时间类型。 4 struct tm 这是一个用来保存时间和日期的结构。 tm 结构的定义如下： struct tm { int tm_sec; /* 秒，范围从 0 到 59 */ int tm_min; /* 分，范围从 0 到 59 */ int tm_hour; /* 小时，范围从 0 到 23 */ int tm_mday; /* 一月中的第几天，范围从 1 到 31 */ int tm_mon; /* 月，范围从 0 到 11 */ int tm_year; /* 自 1900 年起的年数 */ int tm_wday; /* 一周中的第几天，范围从 0 到 6 */ int tm_yday; /* 一年中的第几天，范围从 0 到 365 */ int tm_isdst; /* 夏令时 */ }; 库宏 下面是头文件 time.h 中定义的宏： 序号 宏 & 描述 1 NULL 这个宏是一个空指针常量的值。 2 CLOCKS_PER_SEC 这个宏表示每秒的处理器时钟个数。 库函数 下面是头文件 time.h 中定义的函数： 序号 函数 & 描述 1 char asctime(const struct tm timeptr) 返回一个指向字符串的指针，它代表了结构 timeptr 的日期和时间。 2 clock_t clock(void) 返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。 3 char ctime(const time_t timer) 返回一个表示当地时间的字符串，当地时间是基于参数 timer。 4 double difftime(time_t time1, time_t time2) 返回 time1 和 time2 之间相差的秒数 (time1-time2)。 5 struct tm gmtime(const time_t timer) timer 的值被分解为 tm 结构，并用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 6 struct tm localtime(const time_t timer) timer 的值被分解为 tm 结构，并用本地时区表示。 7 time_t mktime(struct tm *timeptr) 把 timeptr 所指向的结构转换为一个依据本地时区的 time_t 值。 8 size_t strftime(char str, size_t maxsize, const char format, const struct tm *timeptr) 根据 format 中定义的格式化规则，格式化结构 timeptr 表示的时间，并把它存储在 str 中。 9 time_t time(time_t *timer) 计算当前日历时间，并把它编码成 time_t 格式。 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/time.h/*asctime.html":{"url":"include/time.h/*asctime.html","title":"char asctime(const struct tm timeptr)","keywords":"","body":"char *asctime(const struct tm timeptr) 描述 C 库函数 char *asctime(const struct tm *timeptr) 返回一个指向字符串的指针，它代表了结构 struct timeptr 的日期和时间。 声明 下面是 asctime() 函数的声明。 char *asctime(const struct tm *timeptr) 参数 timeptr 是指向 tm 结构的指针，包含了分解为如下各部分的日历时间： struct tm { int tm_sec; /* 秒，范围从 0 到 59 */ int tm_min; /* 分，范围从 0 到 59 */ int tm_hour; /* 小时，范围从 0 到 23 */ int tm_mday; /* 一月中的第几天，范围从 1 到 31 */ int tm_mon; /* 月份，范围从 0 到 11 */ int tm_year; /* 自 1900 起的年数 */ int tm_wday; /* 一周中的第几天，范围从 0 到 6 */ int tm_yday; /* 一年中的第几天，范围从 0 到 365 */ int tm_isdst; /* 夏令时 */ }; 返回值 该函数返回一个 C 字符串，包含了可读格式的日期和时间信息 Www Mmm dd hh:mm:ss yyyy，其中，Www 表示星期几，Mmm是以字母表示的月份，dd 表示一月中的第几天，hh:mm:ss 表示时间，yyyy 表示年份。 实例 下面的实例演示了 asctime() 函数的用法。 #include #include #include int main() { struct tm t; t.tm_sec = 10; t.tm_min = 10; t.tm_hour = 6; t.tm_mday = 25; t.tm_mon = 2; t.tm_year = 89; t.tm_wday = 6; puts(asctime(&t)); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： Sat Mar 25 06:10:10 1989 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/time.h/clock.html":{"url":"include/time.h/clock.html","title":"clock_t clock(void)","keywords":"","body":"clock_t clock(void) 描述 C 库函数 clock_t clock(void) 返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。为了获取 CPU 所使用的秒数，您需要除以 CLOCKS_PER_SEC。 在 32 位系统中，CLOCKS_PER_SEC 等于 1000000，该函数大约每 72 分钟会返回相同的值。 声明 下面是 clock() 函数的声明。 clock_t clock(void) 参数 NA 返回值 该函数返回自程序启动起，处理器时钟所使用的时间。如果失败，则返回 -1 值。 实例 下面的实例演示了 clock() 函数的用法。 #include #include int main() { clock_t start_t, end_t; double total_t; int i; start_t = clock(); printf(\"程序启动，start_t = %ld\\n\", start_t); printf(\"开始一个大循环，start_t = %ld\\n\", start_t); for(i=0; i让我们编译并运行上面的程序，这将产生以下结果： 程序启动，start_t = 2614 开始一个大循环，start_t = 2614 大循环结束，end_t = 28021 CPU 占用的总时间：0.025407 程序退出... 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/time.h/*ctime.html":{"url":"include/time.h/*ctime.html","title":"char ctime(const time_t timer)","keywords":"","body":"char *ctime(const time_t timer) 描述 C 库函数 char *ctime(const time_t *timer) 返回一个表示当地时间的字符串，当地时间是基于参数 timer。 返回的字符串格式如下： Www Mmm dd hh:mm:ss yyyy 其中，Www 表示星期几，Mmm 是以字母表示的月份，dd 表示一月中的第几天，hh:mm:ss 表示时间，yyyy 表示年份。 声明 下面是 ctime() 函数的声明。 char *ctime(const time_t *timer) 参数 timer -- 这是指向 time_t 对象的指针，该对象包含了一个日历时间。 返回值 该函数返回一个 C 字符串，该字符串包含了可读格式的日期和时间信息。 实例 下面的实例演示了 ctime() 函数的用法。 #include #include int main () { time_t curtime; time(&curtime); printf(\"当前时间 = %s\", ctime(&curtime)); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 当前时间 = Mon Aug 13 08:23:14 2012 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/time.h/difftime.html":{"url":"include/time.h/difftime.html","title":"double difftime(time_t time1, time_t time2)","keywords":"","body":"double difftime(time_t time1, time_t time2) 描述 C 库函数 double difftime(time_t time1, time_t time2) 返回 time1 和 time2 之间相差的秒数 (time1 - time2)。这两个时间是在日历时间中指定的，表示了自纪元 Epoch（协调世界时 UTC：1970-01-01 00:00:00）起经过的时间。 声明 下面是 difftime() 函数的声明。 double difftime(time_t time1, time_t time2) 参数 time1 -- 这是表示结束时间的 time_t 对象。 time2 -- 这是表示开始时间的 time_t 对象。 返回值 该函数返回以双精度浮点型 double 值表示的两个时间之间相差的秒数 (time1 - time2)。 实例 下面的实例演示了 difftime() 函数的用法。 #include #include #ifdef _WIN32 #include #else #include #endif int main () { time_t start_t, end_t; double diff_t; printf(\"程序启动...\\n\"); time(&start_t); printf(\"休眠 5 秒...\\n\"); sleep(5); time(&end_t); diff_t = difftime(end_t, start_t); printf(\"执行时间 = %f\\n\", diff_t); printf(\"程序退出...\\n\"); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 程序启动... 休眠 5 秒... 执行时间 = 5.000000 程序退出... 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/time.h/*gmtime.html":{"url":"include/time.h/*gmtime.html","title":"struct tm gmtime(const time_t timer)","keywords":"","body":"struct tm *gmtime(const time_t timer) 描述 C 库函数 struct tm *gmtime(const time_t *timer) 使用 timer 的值来填充 tm 结构，并用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 声明 下面是 gmtime() 函数的声明。 struct tm *gmtime(const time_t *timer) 参数 timeptr -- 这是指向表示日历时间的 time_t 值的指针。 返回值 该函数返回指向 tm 结构的指针，该结构带有被填充的时间信息。下面是 timeptr 结构的细节： struct tm { int tm_sec; /* 秒，范围从 0 到 59 */ int tm_min; /* 分，范围从 0 到 59 */ int tm_hour; /* 小时，范围从 0 到 23 */ int tm_mday; /* 一月中的第几天，范围从 1 到 31 */ int tm_mon; /* 月份，范围从 0 到 11 */ int tm_year; /* 自 1900 起的年数 */ int tm_wday; /* 一周中的第几天，范围从 0 到 6 */ int tm_yday; /* 一年中的第几天，范围从 0 到 365 */ int tm_isdst; /* 夏令时 */ }; 实例 下面的实例演示了 gmtime() 函数的用法。 #include #include #define BST (+1) #define CCT (+8) int main () { time_t rawtime; struct tm *info; time(&rawtime); /* 获取 GMT 时间 */ info = gmtime(&rawtime ); printf(\"当前的世界时钟：\\n\"); printf(\"伦敦：%2d:%02d\\n\", (info->tm_hour+BST)%24, info->tm_min); printf(\"中国：%2d:%02d\\n\", (info->tm_hour+CCT)%24, info->tm_min); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 当前的世界时钟： 伦敦：14:10 中国：21:10 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/time.h/*localtime.html":{"url":"include/time.h/*localtime.html","title":"struct tm localtime(const time_t timer)","keywords":"","body":"struct tm *localtime(const time_t timer) 描述 C 库函数 struct tm *localtime(const time_t *timer) 使用 timer 的值来填充 tm 结构。timer 的值被分解为 tm 结构，并用本地时区表示。 声明 下面是 localtime() 函数的声明。 struct tm *localtime(const time_t *timer) 参数 timer -- 这是指向表示日历时间的 time_t 值的指针。 返回值 该函数返回指向 tm 结构的指针，该结构带有被填充的时间信息。下面是 tm 结构的细节： struct tm { int tm_sec; /* 秒，范围从 0 到 59 */ int tm_min; /* 分，范围从 0 到 59 */ int tm_hour; /* 小时，范围从 0 到 23 */ int tm_mday; /* 一月中的第几天，范围从 1 到 31 */ int tm_mon; /* 月份，范围从 0 到 11 */ int tm_year; /* 自 1900 起的年数 */ int tm_wday; /* 一周中的第几天，范围从 0 到 6 */ int tm_yday; /* 一年中的第几天，范围从 0 到 365 */ int tm_isdst; /* 夏令时 */ }; 实例 下面的实例演示了 localtime() 函数的用法。 #include #include int main () { time_t rawtime; struct tm *info; char buffer[80]; time( &rawtime ); info = localtime( &rawtime ); printf(\"当前的本地时间和日期：%s\", asctime(info)); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 当前的本地时间和日期：Thu Aug 23 09:12:05 2012 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/time.h/mktime.html":{"url":"include/time.h/mktime.html","title":"time_t mktime(struct tm *timeptr)","keywords":"","body":"time_t mktime(struct tm *timeptr) 描述 C 库函数 time_t mktime(struct tm *timeptr) 把 timeptr 所指向的结构转换为一个依据本地时区的 time_t 值。 声明 下面是 mktime() 函数的声明。 time_t mktime(struct tm *timeptr) 参数 timeptr -- 这是指向表示日历时间的 time_t 值的指针，该日历时间被分解为以下各部分。下面是 timeptr 结构的细节： struct tm { int tm_sec; /* 秒，范围从 0 到 59 */ int tm_min; /* 分，范围从 0 到 59 */ int tm_hour; /* 小时，范围从 0 到 23 */ int tm_mday; /* 一月中的第几天，范围从 1 到 31 */ int tm_mon; /* 月份，范围从 0 到 11 */ int tm_year; /* 自 1900 起的年数 */ int tm_wday; /* 一周中的第几天，范围从 0 到 6 */ int tm_yday; /* 一年中的第几天，范围从 0 到 365 */ int tm_isdst; /* 夏令时 */ }; 返回值 该函数返回一个 time_t 值，该值对应于以参数传递的日历时间。如果发生错误，则返回 -1 值。 实例 下面的实例演示了 mktime() 函数的用法。 /* 输入日期判断是周几 */ #include /* printf, scanf */ #include /* time_t, struct tm, time, mktime */ int main () { time_t rawtime; struct tm * timeinfo; int year, month ,day; const char * weekday[] = { \"周日\", \"周一\",\"周二\", \"周三\",\"周四\", \"周五\", \"周六\"}; /* 用户输入日期 */ printf (\"年: \"); fflush(stdout); scanf (\"%d\",&year); printf (\"月: \"); fflush(stdout); scanf (\"%d\",&month); printf (\"日: \"); fflush(stdout); scanf (\"%d\",&day); /* 获取当前时间信息，并修改用户输入的输入信息 */ time ( &rawtime ); timeinfo = localtime ( &rawtime ); timeinfo->tm_year = year - 1900; timeinfo->tm_mon = month - 1; timeinfo->tm_mday = day; /* 调用 mktime: timeinfo->tm_wday */ mktime ( timeinfo ); printf (\"那一天是：%s\\n\", weekday[timeinfo->tm_wday]); return 0; } 让我们编译并运行上面的程序，这将产生以下结果： 年: 2018 月: 7 日: 26 那一天是：周四 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/time.h/strftime.html":{"url":"include/time.h/strftime.html","title":"size_t strftime(char str, size_t maxsize, const char format, const struct tm *timeptr)","keywords":"","body":"size_t strftime(char str, size_t maxsize, const char format, const struct tm *timeptr) 描述 C 库函数 size_t strftime(char *str, size_t maxsize, const char format, const struct tm timeptr) 根据 format 中定义的格式化规则，格式化结构 timeptr 表示的时间，并把它存储在 str 中。 声明 下面是 strftime() 函数的声明。 size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr) 参数 str -- 这是指向目标数组的指针，用来复制产生的 C 字符串。 maxsize -- 这是被复制到 str 的最大字符数。 format -- 这是 C 字符串，包含了普通字符和特殊格式说明符的任何组合。这些格式说明符由函数替换为表示 tm 中所指定时间的相对应值。格式说明符是： 说明符 替换为 实例 %a 缩写的星期几名称 Sun %A 完整的星期几名称 Sunday %b 缩写的月份名称 Mar %B 完整的月份名称 March %c 日期和时间表示法 Sun Aug 19 02:56:02 2012 %d 一月中的第几天（01-31） 19 %H 24 小时格式的小时（00-23） 14 %I 12 小时格式的小时（01-12） 05 %j 一年中的第几天（001-366） 231 %m 十进制数表示的月份（01-12） 08 %M 分（00-59） 55 %p AM 或 PM 名称 PM %S 秒（00-61） 02 %U 一年中的第几周，以第一个星期日作为第一周的第一天（00-53） 33 %w 十进制数表示的星期几，星期日表示为 0（0-6） 4 %W 一年中的第几周，以第一个星期一作为第一周的第一天（00-53） 34 %x 日期表示法 08/19/12 %X 时间表示法 02:50:06 %y 年份，最后两个数字（00-99） 01 %Y 年份 2012 %Z 时区的名称或缩写 CDT %% 一个 % 符号 % timeptr -- 这是指向 tm 结构的指针，该结构包含了一个呗分解为以下各部分的日历时间： struct tm { int tm_sec; /* 秒，范围从 0 到 59 */ int tm_min; /* 分，范围从 0 到 59 */ int tm_hour; /* 小时，范围从 0 到 23 */ int tm_mday; /* 一月中的第几天，范围从 1 到 31 */ int tm_mon; /* 月份，范围从 0 到 11 */ int tm_year; /* 自 1900 起的年数 */ int tm_wday; /* 一周中的第几天，范围从 0 到 6 */ int tm_yday; /* 一年中的第几天，范围从 0 到 365 */ int tm_isdst; /* 夏令时 */ }; 返回值 如果产生的 C 字符串小于 size 个字符（包括空结束字符），则会返回复制到 str 中的字符总数（不包括空结束字符），否则返回零。 实例 下面的实例演示了 strftime() 函数的用法。 #include #include int main () { time_t rawtime; struct tm *info; char buffer[80]; time( &rawtime ); info = localtime( &rawtime ); strftime(buffer, 80, \"%Y-%m-%d %H:%M:%S\", info); printf(\"格式化的日期 & 时间 : |%s|\\n\", buffer ); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 格式化的日期 & 时间 : |2018-09-19 08:59:07| 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"include/time.h/time.html":{"url":"include/time.h/time.html","title":"time_t time(time_t *timer)","keywords":"","body":"time_t time(time_t *timer) 描述 C 库函数 time_t time(time_t *seconds) 返回自纪元 Epoch（1970-01-01 00:00:00 UTC）起经过的时间，以秒为单位。如果 seconds 不为空，则返回值也存储在变量 seconds 中。 声明 下面是 time() 函数的声明。 time_t time(time_t *t) 参数 seconds -- 这是指向类型为 time_t 的对象的指针，用来存储 seconds 的值。 返回值 以 time_t 对象返回当前日历时间。 实例 下面的实例演示了 time() 函数的用法。 #include #include int main () { time_t seconds; seconds = time(NULL); printf(\"自 1970-01-01 起的小时数 = %ld\\n\", seconds/3600); return(0); } 让我们编译并运行上面的程序，这将产生以下结果： 自 1970-01-01 起的小时数 = 373711 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1038.html":{"url":"books/1038.html","title":"应用","keywords":"","body":"应用 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "},"books/1152.html":{"url":"books/1152.html","title":"end","keywords":"","body":"end 转载注明出处 © Zander Zhao All Right Reserved; Powered By Gitbook本文总阅读量次; 最新修订时间： 2020-01-17 14:44:12 "}}